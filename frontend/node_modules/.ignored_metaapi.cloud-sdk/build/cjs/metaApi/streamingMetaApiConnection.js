"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return StreamingMetaApiConnection;
    }
});
const _terminalState = /*#__PURE__*/ _interop_require_default(require("./terminalState"));
const _memoryHistoryStorage = /*#__PURE__*/ _interop_require_default(require("./memoryHistoryStorage"));
const _timeoutError = /*#__PURE__*/ _interop_require_default(require("../clients/timeoutError"));
const _randomstring = /*#__PURE__*/ _interop_require_default(require("randomstring"));
const _connectionHealthMonitor = /*#__PURE__*/ _interop_require_default(require("./connectionHealthMonitor"));
const _errorHandler = require("../clients/errorHandler");
const _optionsValidator = /*#__PURE__*/ _interop_require_default(require("../clients/optionsValidator"));
const _logger = /*#__PURE__*/ _interop_require_default(require("../logger"));
const _metaApiConnection = /*#__PURE__*/ _interop_require_default(require("./metaApiConnection"));
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let StreamingMetaApiConnection = class StreamingMetaApiConnection extends _metaApiConnection.default {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @param {string} instanceId connection instance id
   * @return {Promise} promise resolving when the connection is opened
   */ async connect(instanceId) {
        if (!this._openedInstances.includes(instanceId)) {
            this._openedInstances.push(instanceId);
        }
        if (!this._opened) {
            this._logger.trace(`${this._account.id}: Opening connection`);
            this._opened = true;
            try {
                this._healthMonitor.start();
                await this.initialize();
                await this.subscribe();
            } catch (err) {
                await this.close();
                throw err;
            }
        }
    }
    /**
   * Clears the order and transaction history of a specified application and removes application
   * @return {Promise} promise resolving when the history is cleared and application is removed
   */ removeApplication() {
        this._checkIsConnectionActive();
        this._historyStorage.clear();
        return this._websocketClient.removeApplication(this._account.id);
    }
    /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/)
   * @param {String} instanceIndex instance index
   * @returns {Promise} promise which resolves when synchronization started
   */ async synchronize(instanceIndex) {
        this._checkIsConnectionActive();
        const region = this.getRegion(instanceIndex);
        const instance = this.getInstanceNumber(instanceIndex);
        const host = this.getHostName(instanceIndex);
        let startingHistoryOrderTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastHistoryOrderTime(instance)).getTime()));
        let startingDealTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastDealTime(instance)).getTime()));
        let synchronizationId = _randomstring.default.generate(32);
        this._getState(instanceIndex).lastSynchronizationId = synchronizationId;
        const accountId = this._account.accountRegions[region];
        this._logger.debug(`${this._account.id}:${instanceIndex}: initiating synchronization ${synchronizationId}`);
        return this._websocketClient.synchronize(accountId, instance, host, synchronizationId, startingHistoryOrderTime, startingDealTime, this.terminalState.getHashes());
    }
    /**
   * Initializes meta api connection
   * @return {Promise} promise which resolves when meta api connection is initialized
   */ async initialize() {
        this._checkIsConnectionActive();
        await this._historyStorage.initialize(this._account.id, this._connectionRegistry.application);
        this._websocketClient.addAccountCache(this._account.id, this._account.accountRegions);
    }
    /**
   * Initiates subscription to MetaTrader terminal
   * @returns {Promise} promise which resolves when subscription is initiated
   */ async subscribe() {
        this._checkIsConnectionActive();
        const accountRegions = this._account.accountRegions;
        Object.entries(accountRegions).forEach(([region, replicaId])=>{
            if (!this._options.region || this._options.region === region) {
                this._websocketClient.ensureSubscribe(replicaId, 0);
                this._websocketClient.ensureSubscribe(replicaId, 1);
            }
        });
    }
    /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update. Please
   * note that this feature is not fully implemented on server-side yet
   * @param {number} [timeoutInSeconds] timeout to wait for prices in seconds, default is 30
   * @param {boolean} [waitForQuote] if set to false, the method will resolve without waiting for the first quote to
   * arrive. Default is to wait for quote if quotes subscription is requested.
   * @returns {Promise} promise which resolves when subscription request was processed
   */ async subscribeToMarketData(symbol, subscriptions, timeoutInSeconds, waitForQuote = true) {
        this._checkIsConnectionActive();
        if (!this._terminalState.specification(symbol)) {
            throw new _errorHandler.ValidationError(`${this._account.id}: Cannot subscribe to market data for symbol ${symbol} because ` + "symbol does not exist");
        } else {
            subscriptions = subscriptions || [
                {
                    type: "quotes"
                }
            ];
            if (this._subscriptions[symbol]) {
                const prevSubscriptions = this._subscriptions[symbol].subscriptions;
                subscriptions.forEach((subscription)=>{
                    const index = subscription.type === "candles" ? prevSubscriptions.findIndex((item)=>item.type === subscription.type && item.timeframe === subscription.timeframe) : prevSubscriptions.findIndex((item)=>item.type === subscription.type);
                    if (index === -1) {
                        prevSubscriptions.push(subscription);
                    } else {
                        prevSubscriptions[index] = subscription;
                    }
                });
            } else {
                this._subscriptions[symbol] = {
                    subscriptions
                };
            }
            await this._websocketClient.subscribeToMarketData(this._account.id, symbol, subscriptions, this._account.reliability);
            if (waitForQuote !== false && subscriptions.find((s)=>s.type === "quotes")) {
                return this.terminalState.waitForPrice(symbol, timeoutInSeconds);
            }
        }
    }
    /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */ unsubscribeFromMarketData(symbol, unsubscriptions) {
        this._checkIsConnectionActive();
        if (!unsubscriptions) {
            delete this._subscriptions[symbol];
        } else if (this._subscriptions[symbol]) {
            this._subscriptions[symbol].subscriptions = this._subscriptions[symbol].subscriptions.filter((subscription)=>{
                return !unsubscriptions.find((unsubscription)=>subscription.type === unsubscription.type && (!unsubscription.timeframe || subscription.timeframe === unsubscription.timeframe));
            });
            if (!this._subscriptions[symbol].subscriptions.length) {
                delete this._subscriptions[symbol];
            }
        }
        return this._websocketClient.unsubscribeFromMarketData(this._account.id, symbol, unsubscriptions, this._account.reliability);
    }
    /**
   * Invoked when subscription downgrade has occurred
   * @param {String} instanceIndex index of an account instance connected
   * @param {string} symbol symbol to update subscriptions for
   * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ // eslint-disable-next-line complexity
    async onSubscriptionDowngraded(instanceIndex, symbol, updates, unsubscriptions) {
        if (unsubscriptions === null || unsubscriptions === void 0 ? void 0 : unsubscriptions.length) {
            this.unsubscribeFromMarketData(symbol, unsubscriptions).catch((err)=>{
                let method = err.name !== "ValidationError" ? "error" : "trace";
                this._logger[method](`${this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
            });
        }
        if (updates === null || updates === void 0 ? void 0 : updates.length) {
            this.subscribeToMarketData(symbol, updates).catch((err)=>{
                this._logger.error(`${this._account.id}: failed do subscribe from market data on subscription downgraded`, err);
            });
        }
    }
    /**
   * Returns list of the symbols connection is subscribed to
   * @returns {Array<String>} list of the symbols connection is subscribed to
   */ get subscribedSymbols() {
        return Object.keys(this._subscriptions);
    }
    /**
   * Returns subscriptions for a symbol
   * @param {string} symbol symbol to retrieve subscriptions for
   * @returns {Array<MarketDataSubscription>} list of market data subscriptions for the symbol
   */ subscriptions(symbol) {
        this._checkIsConnectionActive();
        return (this._subscriptions[symbol] || {}).subscriptions;
    }
    /**
   * Returns local copy of terminal state
   * @returns {TerminalState} local copy of terminal state
   */ get terminalState() {
        return this._terminalState;
    }
    /**
   * Returns local history storage
   * @returns {HistoryStorage} local history storage
   */ get historyStorage() {
        return this._historyStorage;
    }
    /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onConnected(instanceIndex, replicas) {
        let key = _randomstring.default.generate(32);
        let state = this._getState(instanceIndex);
        const region = this.getRegion(instanceIndex);
        this.cancelRefresh(region);
        await this._terminalHashManager.refreshIgnoredFieldLists(region);
        state.shouldSynchronize = key;
        state.synchronizationRetryIntervalInSeconds = 1;
        state.synchronized = false;
        this._ensureSynchronized(instanceIndex, key);
        this._logger.debug(`${this._account.id}:${instanceIndex}: connected to broker`);
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */ async onDisconnected(instanceIndex) {
        let state = this._getState(instanceIndex);
        state.lastDisconnectedSynchronizationId = state.lastSynchronizationId;
        state.lastSynchronizationId = undefined;
        state.shouldSynchronize = undefined;
        state.synchronized = false;
        state.disconnected = true;
        const instanceNumber = this.getInstanceNumber(instanceIndex);
        const region = this.getRegion(instanceIndex);
        const instance = `${region}:${instanceNumber}`;
        delete this._refreshMarketDataSubscriptionSessions[instance];
        clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
        delete this._refreshMarketDataSubscriptionTimeouts[instance];
        clearTimeout(state.synchronizationTimeout);
        delete state.synchronizationTimeout;
        clearTimeout(state.ensureSynchronizeTimeout);
        delete state.ensureSynchronizeTimeout;
        this._logger.debug(`${this._account.id}:${instanceIndex}: disconnected from broker`);
    }
    /**
   * Invoked when a symbol specifications were updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */ async onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when position synchronization finished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */ async onPositionsSynchronized(instanceIndex, synchronizationId) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */ async onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when a synchronization of history deals on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onDealsSynchronized(instanceIndex, synchronizationId) {
        let state = this._getState(instanceIndex);
        state.dealsSynchronized[synchronizationId] = true;
        this._scheduleSynchronizationTimeout(instanceIndex);
        this._logger.debug(`${this._account.id}:${instanceIndex}: finished synchronization ${synchronizationId}`);
    }
    /**
   * Invoked when a synchronization of history orders on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onHistoryOrdersSynchronized(instanceIndex, synchronizationId) {
        let state = this._getState(instanceIndex);
        state.ordersSynchronized[synchronizationId] = true;
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect
   * @param {String} region reconnected region
   * @param {Number} instanceNumber reconnected instance number
   * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
   */ async onReconnected(region, instanceNumber) {
        const instanceTemplate = `${region}:${instanceNumber}`;
        Object.keys(this._stateByInstanceIndex).filter((key)=>key.startsWith(`${instanceTemplate}:`)).forEach((key)=>{
            delete this._stateByInstanceIndex[key];
        });
        delete this._refreshMarketDataSubscriptionSessions[instanceTemplate];
        clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instanceTemplate]);
        delete this._refreshMarketDataSubscriptionTimeouts[instanceTemplate];
    }
    /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onStreamClosed(instanceIndex) {
        delete this._stateByInstanceIndex[instanceIndex];
    }
    /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {string} instanceIndex index of an account instance connected
   * @param {string} specificationsHash specifications hash
   * @param {string} positionsHash positions hash
   * @param {string} ordersHash orders hash
   * @param {string} synchronizationId synchronization id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, synchronizationId) {
        this._logger.debug(`${this._account.id}:${instanceIndex}: starting synchronization ${synchronizationId}`);
        const instanceNumber = this.getInstanceNumber(instanceIndex);
        const region = this.getRegion(instanceIndex);
        const instance = `${region}:${instanceNumber}`;
        const accountId = this._account.accountRegions[region];
        delete this._refreshMarketDataSubscriptionSessions[instance];
        let sessionId = _randomstring.default.generate(32);
        this._refreshMarketDataSubscriptionSessions[instance] = sessionId;
        clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
        delete this._refreshMarketDataSubscriptionTimeouts[instance];
        await this._refreshMarketDataSubscriptions(accountId, instanceNumber, sessionId);
        this._scheduleSynchronizationTimeout(instanceIndex);
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            state.lastSynchronizationId = synchronizationId;
        }
    }
    /**
   * Invoked when account region has been unsubscribed
   * @param {String} region account region unsubscribed
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onUnsubscribeRegion(region) {
        Object.keys(this._refreshMarketDataSubscriptionTimeouts).filter((instance)=>instance.startsWith(`${region}:`)).forEach((instance)=>{
            clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
            delete this._refreshMarketDataSubscriptionTimeouts[instance];
            delete this._refreshMarketDataSubscriptionSessions[instance];
        });
        Object.keys(this._stateByInstanceIndex).filter((instance)=>instance.startsWith(`${region}:`)).forEach((instance)=>delete this._stateByInstanceIndex[instance]);
    }
    /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId optional synchronization request id, last synchronization request id will be used
   * by default
   * @return {Promise<Boolean>} promise resolving with a flag indicating status of state synchronization with MetaTrader
   * terminal
   */ async isSynchronized(instanceIndex, synchronizationId) {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>{
            if (instanceIndex !== undefined && s.instanceIndex !== instanceIndex) {
                return acc;
            }
            const checkSynchronizationId = synchronizationId || s.lastSynchronizationId;
            let synchronized = !!s.ordersSynchronized[checkSynchronizationId] && !!s.dealsSynchronized[checkSynchronizationId];
            return acc || synchronized;
        }, false);
    }
    /**
   * @typedef {Object} SynchronizationOptions
   * @property {String} [applicationPattern] application regular expression pattern, default is .*
   * @property {String} [synchronizationId] synchronization id, last synchronization request id will be used by
   * default
   * @property {Number} [instanceIndex] index of an account instance to ensure synchronization on, default is to wait
   * for the first instance to synchronize
   * @property {Number} [timeoutInSeconds] wait timeout in seconds, default is 5m
   * @property {Number} [intervalInMilliseconds] interval between account reloads while waiting for a change, default is 1s
   */ /**
   * Waits until synchronization to MetaTrader terminal is completed
   * @param {SynchronizationOptions} opts synchronization options
   * @return {Promise} promise which resolves when synchronization to MetaTrader terminal is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal within timeout allowed
   */ // eslint-disable-next-line complexity
    async waitSynchronized(opts) {
        this._checkIsConnectionActive();
        opts = opts || {};
        let instanceIndex = opts.instanceIndex;
        let synchronizationId = opts.synchronizationId;
        let timeoutInSeconds = opts.timeoutInSeconds || 300;
        let intervalInMilliseconds = opts.intervalInMilliseconds || 1000;
        let applicationPattern = opts.applicationPattern || (this._account.application === "CopyFactory" ? "CopyFactory.*|RPC" : "RPC");
        let startTime = Date.now();
        let synchronized;
        while(!(synchronized = await this.isSynchronized(instanceIndex, synchronizationId)) && startTime + timeoutInSeconds * 1000 > Date.now()){
            await new Promise((res)=>setTimeout(res, intervalInMilliseconds));
        }
        let state;
        if (instanceIndex === undefined) {
            for (let s of Object.values(this._stateByInstanceIndex)){
                if (await this.isSynchronized(s.instanceIndex, synchronizationId)) {
                    state = s;
                    instanceIndex = s.instanceIndex;
                }
            }
        } else {
            state = Object.values(this._stateByInstanceIndex).find((s)=>s.instanceIndex === instanceIndex);
        }
        if (!synchronized) {
            throw new _timeoutError.default("Timed out waiting for MetaApi to synchronize to MetaTrader account " + this._account.id + ", synchronization id " + (synchronizationId || state && state.lastSynchronizationId || state && state.lastDisconnectedSynchronizationId));
        }
        let timeLeftInSeconds = Math.max(0, timeoutInSeconds - (Date.now() - startTime) / 1000);
        const region = this.getRegion(state.instanceIndex);
        const accountId = this._account.accountRegions[region];
        await this._websocketClient.waitSynchronized(accountId, this.getInstanceNumber(instanceIndex), applicationPattern, timeLeftInSeconds);
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   * @param {string} instanceId connection instance id
   */ async close(instanceId) {
        if (this._opened) {
            this._openedInstances = this._openedInstances.filter((id)=>id !== instanceId);
            if (!this._openedInstances.length && !this._closed) {
                this._logger.debug(`${this._account.id}: Closing connection`);
                Object.values(this._stateByInstanceIndex).forEach((state)=>clearTimeout(state.synchronizationTimeout));
                this._stateByInstanceIndex = {};
                await this._connectionRegistry.removeStreaming(this._account);
                this._terminalState.close();
                const accountRegions = this._account.accountRegions;
                this._websocketClient.removeSynchronizationListener(this._account.id, this);
                this._websocketClient.removeSynchronizationListener(this._account.id, this._terminalState);
                this._websocketClient.removeSynchronizationListener(this._account.id, this._historyStorage);
                this._websocketClient.removeSynchronizationListener(this._account.id, this._healthMonitor);
                this._websocketClient.removeReconnectListener(this);
                this._healthMonitor.stop();
                this._refreshMarketDataSubscriptionSessions = {};
                Object.values(this._refreshMarketDataSubscriptionTimeouts).forEach((timeout)=>clearTimeout(timeout));
                this._refreshMarketDataSubscriptionTimeouts = {};
                Object.values(accountRegions).forEach((replicaId)=>this._websocketClient.removeAccountCache(replicaId));
                this._closed = true;
                this._logger.trace(`${this._account.id}: Closed connection`);
            }
        }
    }
    /**
   * Returns synchronization status
   * @return {boolean} synchronization status
   */ get synchronized() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.synchronized, false);
    }
    /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */ get account() {
        return this._account;
    }
    /**
   * Returns connection health monitor instance
   * @return {ConnectionHealthMonitor} connection health monitor instance
   */ get healthMonitor() {
        return this._healthMonitor;
    }
    async _refreshMarketDataSubscriptions(accountId, instanceNumber, session) {
        const region = this._websocketClient.getAccountRegion(accountId);
        const instance = `${region}:${instanceNumber}`;
        try {
            if (this._refreshMarketDataSubscriptionSessions[instance] === session) {
                const subscriptionsList = [];
                Object.keys(this._subscriptions).forEach((key)=>{
                    const subscriptions = this.subscriptions(key);
                    const subscriptionsItem = {
                        symbol: key
                    };
                    if (subscriptions) {
                        subscriptionsItem.subscriptions = subscriptions;
                    }
                    subscriptionsList.push(subscriptionsItem);
                });
                await this._websocketClient.refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptionsList);
            }
        } catch (err) {
            this._logger.error(`Error refreshing market data subscriptions job for account ${this._account.id} ` + `${instanceNumber}`, err);
        } finally{
            if (this._refreshMarketDataSubscriptionSessions[instance] === session) {
                let refreshInterval = (Math.random() * (this._maxSubscriptionRefreshInterval - this._minSubscriptionRefreshInterval) + this._minSubscriptionRefreshInterval) * 1000;
                this._refreshMarketDataSubscriptionTimeouts[instance] = setTimeout(()=>this._refreshMarketDataSubscriptions(accountId, instanceNumber, session), refreshInterval);
            }
        }
    }
    _generateStopOptions(stopLoss, takeProfit) {
        let trade = {};
        if (typeof stopLoss === "number") {
            trade.stopLoss = stopLoss;
        } else if (stopLoss) {
            trade.stopLoss = stopLoss.value;
            trade.stopLossUnits = stopLoss.units;
        }
        if (typeof takeProfit === "number") {
            trade.takeProfit = takeProfit;
        } else if (takeProfit) {
            trade.takeProfit = takeProfit.value;
            trade.takeProfitUnits = takeProfit.units;
        }
        return trade;
    }
    async _ensureSynchronized(instanceIndex, key) {
        let state = this._getState(instanceIndex);
        if (state && state.shouldSynchronize && !this._closed) {
            try {
                const synchronizationResult = await this.synchronize(instanceIndex);
                if (synchronizationResult) {
                    state.synchronized = true;
                    state.synchronizationRetryIntervalInSeconds = 1;
                    delete state.ensureSynchronizeTimeout;
                }
                this._scheduleSynchronizationTimeout(instanceIndex);
            } catch (err) {
                const level = this._latencyService.getSynchronizedAccountInstances(this._account.id).length ? "debug" : "error";
                this._logger[level]("MetaApi websocket client for account " + this._account.id + ":" + instanceIndex + " failed to synchronize", err);
                if (state.shouldSynchronize === key) {
                    clearTimeout(state.ensureSynchronizeTimeout);
                    state.ensureSynchronizeTimeout = setTimeout(this._ensureSynchronized.bind(this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
                    state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
                }
            }
        }
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex["" + instanceIndex]) {
            this._stateByInstanceIndex["" + instanceIndex] = {
                instanceIndex,
                ordersSynchronized: {},
                dealsSynchronized: {},
                shouldSynchronize: undefined,
                synchronizationRetryIntervalInSeconds: 1,
                synchronized: false,
                lastDisconnectedSynchronizationId: undefined,
                lastSynchronizationId: undefined,
                disconnected: false
            };
        }
        return this._stateByInstanceIndex["" + instanceIndex];
    }
    _scheduleSynchronizationTimeout(instanceIndex) {
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            clearTimeout(state.synchronizationTimeout);
            state.synchronizationTimeout = setTimeout(()=>this._checkSynchronizationTimedOut(instanceIndex), 2 * 60 * 1000);
            this._logger.debug(`${this._account.id}:${instanceIndex}: scheduled synchronization timeout`);
        }
    }
    _checkSynchronizationTimedOut(instanceIndex) {
        this._logger.debug(`${this._account.id}:${instanceIndex}: checking if synchronization timed out out`);
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            let synchronizationId = state.lastSynchronizationId;
            let synchronized = !!state.dealsSynchronized[synchronizationId];
            if (!synchronized && synchronizationId && state.shouldSynchronize) {
                this._logger.warn(`${this._account.id}:${instanceIndex}: resynchronized since latest synchronization ` + `${synchronizationId} did not finish in time`);
                this._ensureSynchronized(instanceIndex, state.shouldSynchronize);
            }
        }
    }
    /**
   * Constructs MetaApi MetaTrader streaming Api connection
   * @param {MetaApiOpts} options metaapi options
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {TerminalHashManager} terminalHashManager terminal hash manager
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {HistoryStorage} historyStorage terminal history storage. By default an instance of MemoryHistoryStorage
   * will be used.
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {Date} [historyStartTime] history start sync time
   * @param {RefreshSubscriptionsOpts} [refreshSubscriptionsOpts] subscriptions refresh options
   */ constructor(options, websocketClient, terminalHashManager, account, historyStorage, connectionRegistry, historyStartTime, refreshSubscriptionsOpts){
        super(options, websocketClient, account);
        _define_property(this, "_minSubscriptionRefreshInterval", void 0);
        _define_property(this, "_maxSubscriptionRefreshInterval", void 0);
        _define_property(this, "_historyStartTime", void 0);
        _define_property(this, "_terminalHashManager", void 0);
        _define_property(this, "_terminalState", void 0);
        _define_property(this, "_historyStorage", void 0);
        _define_property(this, "_healthMonitor", void 0);
        _define_property(this, "_subscriptions", void 0);
        _define_property(this, "_refreshMarketDataSubscriptionSessions", void 0);
        _define_property(this, "_refreshMarketDataSubscriptionTimeouts", void 0);
        _define_property(this, "_openedInstances", void 0);
        refreshSubscriptionsOpts = refreshSubscriptionsOpts || {};
        const validator = new _optionsValidator.default();
        this._minSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.minDelayInSeconds, 1, "refreshSubscriptionsOpts.minDelayInSeconds");
        this._maxSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.maxDelayInSeconds, 600, "refreshSubscriptionsOpts.maxDelayInSeconds");
        this._connectionRegistry = connectionRegistry;
        this._historyStartTime = historyStartTime;
        this._terminalHashManager = terminalHashManager;
        this._terminalState = new _terminalState.default(account, terminalHashManager, this._websocketClient);
        this._historyStorage = historyStorage || new _memoryHistoryStorage.default();
        this._healthMonitor = new _connectionHealthMonitor.default(this);
        this._websocketClient.addSynchronizationListener(account.id, this);
        this._websocketClient.addSynchronizationListener(account.id, this._terminalState);
        this._websocketClient.addSynchronizationListener(account.id, this._historyStorage);
        this._websocketClient.addSynchronizationListener(account.id, this._healthMonitor);
        Object.values(account.accountRegions).forEach((replicaId)=>this._websocketClient.addReconnectListener(this, replicaId));
        this._subscriptions = {};
        this._stateByInstanceIndex = {};
        this._refreshMarketDataSubscriptionSessions = {};
        this._refreshMarketDataSubscriptionTimeouts = {};
        this._openedInstances = [];
        this._logger = _logger.default.getLogger("MetaApiConnection");
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUZXJtaW5hbFN0YXRlIGZyb20gJy4vdGVybWluYWxTdGF0ZSc7XG5pbXBvcnQgTWVtb3J5SGlzdG9yeVN0b3JhZ2UgZnJvbSAnLi9tZW1vcnlIaXN0b3J5U3RvcmFnZSc7XG5pbXBvcnQgVGltZW91dEVycm9yIGZyb20gJy4uL2NsaWVudHMvdGltZW91dEVycm9yJztcbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBDb25uZWN0aW9uSGVhbHRoTW9uaXRvciBmcm9tICcuL2Nvbm5lY3Rpb25IZWFsdGhNb25pdG9yJztcbmltcG9ydCB7VmFsaWRhdGlvbkVycm9yfSBmcm9tICcuLi9jbGllbnRzL2Vycm9ySGFuZGxlcic7XG5pbXBvcnQgT3B0aW9uc1ZhbGlkYXRvciBmcm9tICcuLi9jbGllbnRzL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IExvZ2dlck1hbmFnZXIgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCBNZXRhQXBpQ29ubmVjdGlvbiBmcm9tICcuL21ldGFBcGlDb25uZWN0aW9uJztcblxuLyoqXG4gKiBFeHBvc2VzIE1ldGFBcGkgTWV0YVRyYWRlciBzdHJlYW1pbmcgQVBJIGNvbm5lY3Rpb24gdG8gY29uc3VtZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbWluZ01ldGFBcGlDb25uZWN0aW9uIGV4dGVuZHMgTWV0YUFwaUNvbm5lY3Rpb24ge1xuICBcbiAgcHJpdmF0ZSBfbWluU3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsOiBhbnk7XG4gIHByaXZhdGUgX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbDogYW55O1xuICBwcml2YXRlIF9oaXN0b3J5U3RhcnRUaW1lOiBhbnk7XG4gIHByaXZhdGUgX3Rlcm1pbmFsSGFzaE1hbmFnZXI6IGFueTtcbiAgcHJpdmF0ZSBfdGVybWluYWxTdGF0ZTogVGVybWluYWxTdGF0ZTtcbiAgcHJpdmF0ZSBfaGlzdG9yeVN0b3JhZ2U6IGFueTtcbiAgcHJpdmF0ZSBfaGVhbHRoTW9uaXRvcjogQ29ubmVjdGlvbkhlYWx0aE1vbml0b3I7XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbnM6IHt9O1xuICBwcml2YXRlIF9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zOiB7fTtcbiAgcHJpdmF0ZSBfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0czoge307XG4gIHByaXZhdGUgX29wZW5lZEluc3RhbmNlczogYW55W107XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgTWV0YUFwaSBNZXRhVHJhZGVyIHN0cmVhbWluZyBBcGkgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge01ldGFBcGlPcHRzfSBvcHRpb25zIG1ldGFhcGkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IHdlYnNvY2tldENsaWVudCBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnRcbiAgICogQHBhcmFtIHtUZXJtaW5hbEhhc2hNYW5hZ2VyfSB0ZXJtaW5hbEhhc2hNYW5hZ2VyIHRlcm1pbmFsIGhhc2ggbWFuYWdlclxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50fSBhY2NvdW50IE1ldGFUcmFkZXIgYWNjb3VudCBpZCB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSB7SGlzdG9yeVN0b3JhZ2V9IGhpc3RvcnlTdG9yYWdlIHRlcm1pbmFsIGhpc3Rvcnkgc3RvcmFnZS4gQnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBvZiBNZW1vcnlIaXN0b3J5U3RvcmFnZVxuICAgKiB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblJlZ2lzdHJ5fSBjb25uZWN0aW9uUmVnaXN0cnkgbWV0YXRyYWRlciBhY2NvdW50IGNvbm5lY3Rpb24gcmVnaXN0cnlcbiAgICogQHBhcmFtIHtEYXRlfSBbaGlzdG9yeVN0YXJ0VGltZV0gaGlzdG9yeSBzdGFydCBzeW5jIHRpbWVcbiAgICogQHBhcmFtIHtSZWZyZXNoU3Vic2NyaXB0aW9uc09wdHN9IFtyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHNdIHN1YnNjcmlwdGlvbnMgcmVmcmVzaCBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCB3ZWJzb2NrZXRDbGllbnQsIHRlcm1pbmFsSGFzaE1hbmFnZXIsIGFjY291bnQsIGhpc3RvcnlTdG9yYWdlLCBjb25uZWN0aW9uUmVnaXN0cnksXG4gICAgaGlzdG9yeVN0YXJ0VGltZSwgcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgd2Vic29ja2V0Q2xpZW50LCBhY2NvdW50KTtcbiAgICByZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMgPSByZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMgfHwge307XG4gICAgY29uc3QgdmFsaWRhdG9yID0gbmV3IE9wdGlvbnNWYWxpZGF0b3IoKTtcbiAgICB0aGlzLl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cy5taW5EZWxheUluU2Vjb25kcywgMSxcbiAgICAgICdyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWluRGVsYXlJblNlY29uZHMnKTtcbiAgICB0aGlzLl9tYXhTdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cy5tYXhEZWxheUluU2Vjb25kcywgNjAwLFxuICAgICAgJ3JlZnJlc2hTdWJzY3JpcHRpb25zT3B0cy5tYXhEZWxheUluU2Vjb25kcycpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeSA9IGNvbm5lY3Rpb25SZWdpc3RyeTtcbiAgICB0aGlzLl9oaXN0b3J5U3RhcnRUaW1lID0gaGlzdG9yeVN0YXJ0VGltZTtcbiAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyID0gdGVybWluYWxIYXNoTWFuYWdlcjtcbiAgICB0aGlzLl90ZXJtaW5hbFN0YXRlID0gbmV3IFRlcm1pbmFsU3RhdGUoYWNjb3VudCwgdGVybWluYWxIYXNoTWFuYWdlciwgdGhpcy5fd2Vic29ja2V0Q2xpZW50KTtcbiAgICB0aGlzLl9oaXN0b3J5U3RvcmFnZSA9IGhpc3RvcnlTdG9yYWdlIHx8IG5ldyBNZW1vcnlIaXN0b3J5U3RvcmFnZSgpO1xuICAgIHRoaXMuX2hlYWx0aE1vbml0b3IgPSBuZXcgQ29ubmVjdGlvbkhlYWx0aE1vbml0b3IodGhpcyk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzLl90ZXJtaW5hbFN0YXRlKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcy5faGlzdG9yeVN0b3JhZ2UpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzLl9oZWFsdGhNb25pdG9yKTtcbiAgICBPYmplY3QudmFsdWVzKGFjY291bnQuYWNjb3VudFJlZ2lvbnMpXG4gICAgICAuZm9yRWFjaChyZXBsaWNhSWQgPT4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFJlY29ubmVjdExpc3RlbmVyKHRoaXMsIHJlcGxpY2FJZCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzID0ge307XG4gICAgdGhpcy5fb3BlbmVkSW5zdGFuY2VzID0gW107XG4gICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyTWFuYWdlci5nZXRMb2dnZXIoJ01ldGFBcGlDb25uZWN0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGNvbm5lY3Rpb24uIENhbiBvbmx5IGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSwgbmV4dCBjYWxscyB3aWxsIGJlIGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoaW5zdGFuY2VJZCkge1xuICAgIGlmICghdGhpcy5fb3BlbmVkSW5zdGFuY2VzLmluY2x1ZGVzKGluc3RhbmNlSWQpKSB7XG4gICAgICB0aGlzLl9vcGVuZWRJbnN0YW5jZXMucHVzaChpbnN0YW5jZUlkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfTogT3BlbmluZyBjb25uZWN0aW9uYCk7XG4gICAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5faGVhbHRoTW9uaXRvci5zdGFydCgpO1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBvcmRlciBhbmQgdHJhbnNhY3Rpb24gaGlzdG9yeSBvZiBhIHNwZWNpZmllZCBhcHBsaWNhdGlvbiBhbmQgcmVtb3ZlcyBhcHBsaWNhdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGNsZWFyZWQgYW5kIGFwcGxpY2F0aW9uIGlzIHJlbW92ZWRcbiAgICovXG4gIHJlbW92ZUFwcGxpY2F0aW9uKCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgdGhpcy5faGlzdG9yeVN0b3JhZ2UuY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFwcGxpY2F0aW9uKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSB0ZXJtaW5hbCB0byBzdGFydCBzeW5jaHJvbml6YXRpb24gcHJvY2Vzc1xuICAgKiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvc3luY2hyb25pemluZy9zeW5jaHJvbml6ZS8pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluc3RhbmNlIGluZGV4XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIGFzeW5jIHN5bmNocm9uaXplKGluc3RhbmNlSW5kZXgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBob3N0ID0gdGhpcy5nZXRIb3N0TmFtZShpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lID0gbmV3IERhdGUoTWF0aC5tYXgoXG4gICAgICAodGhpcy5faGlzdG9yeVN0YXJ0VGltZSB8fCBuZXcgRGF0ZSgwKSkuZ2V0VGltZSgpLFxuICAgICAgKGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmxhc3RIaXN0b3J5T3JkZXJUaW1lKGluc3RhbmNlKSkuZ2V0VGltZSgpXG4gICAgKSk7XG4gICAgbGV0IHN0YXJ0aW5nRGVhbFRpbWUgPSBuZXcgRGF0ZShNYXRoLm1heChcbiAgICAgICh0aGlzLl9oaXN0b3J5U3RhcnRUaW1lIHx8IG5ldyBEYXRlKDApKS5nZXRUaW1lKCksXG4gICAgICAoYXdhaXQgdGhpcy5faGlzdG9yeVN0b3JhZ2UubGFzdERlYWxUaW1lKGluc3RhbmNlKSkuZ2V0VGltZSgpXG4gICAgKSk7XG4gICAgbGV0IHN5bmNocm9uaXphdGlvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KS5sYXN0U3luY2hyb25pemF0aW9uSWQgPSBzeW5jaHJvbml6YXRpb25JZDtcbiAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zW3JlZ2lvbl07XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IGluaXRpYXRpbmcgc3luY2hyb25pemF0aW9uICR7c3luY2hyb25pemF0aW9uSWR9YCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5zeW5jaHJvbml6ZShhY2NvdW50SWQsIGluc3RhbmNlLCBob3N0LCBzeW5jaHJvbml6YXRpb25JZCxcbiAgICAgIHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSwgc3RhcnRpbmdEZWFsVGltZSwgdGhpcy50ZXJtaW5hbFN0YXRlLmdldEhhc2hlcygpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIG1ldGEgYXBpIGNvbm5lY3Rpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIG1ldGEgYXBpIGNvbm5lY3Rpb24gaXMgaW5pdGlhbGl6ZWRcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICBhd2FpdCB0aGlzLl9oaXN0b3J5U3RvcmFnZS5pbml0aWFsaXplKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5hcHBsaWNhdGlvbik7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZEFjY291bnRDYWNoZSh0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgc3Vic2NyaXB0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzdWJzY3JpcHRpb24gaXMgaW5pdGlhdGVkXG4gICAqL1xuICBhc3luYyBzdWJzY3JpYmUoKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICBjb25zdCBhY2NvdW50UmVnaW9ucyA9IHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnM7XG4gICAgT2JqZWN0LmVudHJpZXMoYWNjb3VudFJlZ2lvbnMpLmZvckVhY2goKFtyZWdpb24sIHJlcGxpY2FJZF0pID0+IHtcbiAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5yZWdpb24gfHwgdGhpcy5fb3B0aW9ucy5yZWdpb24gPT09IHJlZ2lvbikge1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKHJlcGxpY2FJZCwgMCk7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5lbnN1cmVTdWJzY3JpYmUocmVwbGljYUlkLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIG9uIG1hcmtldCBkYXRhIG9mIHNwZWNpZmllZCBzeW1ib2wgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L21hcmtldERhdGFTdHJlYW1pbmcvc3Vic2NyaWJlVG9NYXJrZXREYXRhLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IHN1YnNjcmlwdGlvbnMgYXJyYXkgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uIHRvIGNyZWF0ZSBvciB1cGRhdGUuIFBsZWFzZVxuICAgKiBub3RlIHRoYXQgdGhpcyBmZWF0dXJlIGlzIG5vdCBmdWxseSBpbXBsZW1lbnRlZCBvbiBzZXJ2ZXItc2lkZSB5ZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSB0aW1lb3V0IHRvIHdhaXQgZm9yIHByaWNlcyBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDMwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dhaXRGb3JRdW90ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgbWV0aG9kIHdpbGwgcmVzb2x2ZSB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBmaXJzdCBxdW90ZSB0b1xuICAgKiBhcnJpdmUuIERlZmF1bHQgaXMgdG8gd2FpdCBmb3IgcXVvdGUgaWYgcXVvdGVzIHN1YnNjcmlwdGlvbiBpcyByZXF1ZXN0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3Vic2NyaXB0aW9uIHJlcXVlc3Qgd2FzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgc3Vic2NyaWJlVG9NYXJrZXREYXRhKHN5bWJvbCwgc3Vic2NyaXB0aW9ucywgdGltZW91dEluU2Vjb25kcz8sIHdhaXRGb3JRdW90ZSA9IHRydWUpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGlmICghdGhpcy5fdGVybWluYWxTdGF0ZS5zcGVjaWZpY2F0aW9uKHN5bWJvbCkpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7dGhpcy5fYWNjb3VudC5pZH06IENhbm5vdCBzdWJzY3JpYmUgdG8gbWFya2V0IGRhdGEgZm9yIHN5bWJvbCAke3N5bWJvbH0gYmVjYXVzZSBgICtcbiAgICAgICAgJ3N5bWJvbCBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucyB8fCBbe3R5cGU6ICdxdW90ZXMnfV07XG4gICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICAgIGNvbnN0IHByZXZTdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaXB0aW9uLnR5cGUgPT09ICdjYW5kbGVzJyA/IFxuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS50eXBlID09PSBzdWJzY3JpcHRpb24udHlwZSAmJiBcbiAgICAgICAgICAgICAgaXRlbS50aW1lZnJhbWUgPT09IHN1YnNjcmlwdGlvbi50aW1lZnJhbWUpIDpcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUpO1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnNbaW5kZXhdID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0gPSB7c3Vic2NyaXB0aW9uc307XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHRoaXMuX2FjY291bnQuaWQsIHN5bWJvbCwgc3Vic2NyaXB0aW9ucyxcbiAgICAgICAgdGhpcy5fYWNjb3VudC5yZWxpYWJpbGl0eSk7XG4gICAgICBpZiAod2FpdEZvclF1b3RlICE9PSBmYWxzZSAmJiBzdWJzY3JpcHRpb25zLmZpbmQocyA9PiBzLnR5cGUgPT09ICdxdW90ZXMnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbFN0YXRlLndhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhVW5zdWJzY3JpcHRpb24+fSB1bnN1YnNjcmlwdGlvbnMgYXJyYXkgb2Ygc3Vic2NyaXB0aW9ucyB0byBjYW5jZWxcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1bnN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIHVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCB1bnN1YnNjcmlwdGlvbnMpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGlmICghdW5zdWJzY3JpcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0uc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zLmZpbHRlcihzdWJzY3JpcHRpb24gPT4ge1xuICAgICAgICByZXR1cm4gIXVuc3Vic2NyaXB0aW9ucy5maW5kKHVuc3Vic2NyaXB0aW9uID0+IHN1YnNjcmlwdGlvbi50eXBlID09PSB1bnN1YnNjcmlwdGlvbi50eXBlICYmXG4gICAgICAgICAgKCF1bnN1YnNjcmlwdGlvbi50aW1lZnJhbWUgfHwgc3Vic2NyaXB0aW9uLnRpbWVmcmFtZSA9PT0gdW5zdWJzY3JpcHRpb24udGltZWZyYW1lKSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wsIHVuc3Vic2NyaXB0aW9ucyxcbiAgICAgIHRoaXMuX2FjY291bnQucmVsaWFiaWxpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBzdWJzY3JpcHRpb24gZG93bmdyYWRlIGhhcyBvY2N1cnJlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB1cGRhdGUgc3Vic2NyaXB0aW9ucyBmb3JcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhU3Vic2NyaXB0aW9uPn0gdXBkYXRlcyBhcnJheSBvZiBtYXJrZXQgZGF0YSBzdWJzY3JpcHRpb24gdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVVuc3Vic2NyaXB0aW9uPn0gdW5zdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgb25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkKGluc3RhbmNlSW5kZXgsIHN5bWJvbCwgdXBkYXRlcywgdW5zdWJzY3JpcHRpb25zKSB7XG4gICAgaWYgKHVuc3Vic2NyaXB0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCB1bnN1YnNjcmlwdGlvbnMpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGxldCBtZXRob2QgPSBlcnIubmFtZSAhPT0gJ1ZhbGlkYXRpb25FcnJvcicgPyAnZXJyb3InIDogJ3RyYWNlJztcbiAgICAgICAgdGhpcy5fbG9nZ2VyW21ldGhvZF0oYCR7dGhpcy5fYWNjb3VudC5pZH06IGZhaWxlZCBkbyB1bnN1YnNjcmliZSBmcm9tIG1hcmtldCBkYXRhIG9uIHN1YnNjcmlwdGlvbiBkb3duZ3JhZGVkYCxcbiAgICAgICAgICBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVzPy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHN5bWJvbCwgdXBkYXRlcykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke3RoaXMuX2FjY291bnQuaWR9OiBmYWlsZWQgZG8gc3Vic2NyaWJlIGZyb20gbWFya2V0IGRhdGEgb24gc3Vic2NyaXB0aW9uIGRvd25ncmFkZWRgLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiB0aGUgc3ltYm9scyBjb25uZWN0aW9uIGlzIHN1YnNjcmliZWQgdG9cbiAgICogQHJldHVybnMge0FycmF5PFN0cmluZz59IGxpc3Qgb2YgdGhlIHN5bWJvbHMgY29ubmVjdGlvbiBpcyBzdWJzY3JpYmVkIHRvXG4gICAqL1xuICBnZXQgc3Vic2NyaWJlZFN5bWJvbHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3Vic2NyaXB0aW9ucyBmb3IgYSBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgc3Vic2NyaXB0aW9ucyBmb3JcbiAgICogQHJldHVybnMge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBsaXN0IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgZm9yIHRoZSBzeW1ib2xcbiAgICovXG4gIHN1YnNjcmlwdGlvbnMoc3ltYm9sKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gKHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXSB8fCB7fSkuc3Vic2NyaXB0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGxvY2FsIGNvcHkgb2YgdGVybWluYWwgc3RhdGVcbiAgICogQHJldHVybnMge1Rlcm1pbmFsU3RhdGV9IGxvY2FsIGNvcHkgb2YgdGVybWluYWwgc3RhdGVcbiAgICovXG4gIGdldCB0ZXJtaW5hbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXJtaW5hbFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbG9jYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqIEByZXR1cm5zIHtIaXN0b3J5U3RvcmFnZX0gbG9jYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqL1xuICBnZXQgaGlzdG9yeVN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcnlTdG9yYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgZXN0YWJsaXNoZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcGxpY2FzIG51bWJlciBvZiBhY2NvdW50IHJlcGxpY2FzIGxhdW5jaGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25Db25uZWN0ZWQoaW5zdGFuY2VJbmRleCwgcmVwbGljYXMpIHtcbiAgICBsZXQga2V5ID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldFJlZ2lvbihpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLmNhbmNlbFJlZnJlc2gocmVnaW9uKTtcbiAgICBhd2FpdCB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlZnJlc2hJZ25vcmVkRmllbGRMaXN0cyhyZWdpb24pO1xuICAgIHN0YXRlLnNob3VsZFN5bmNocm9uaXplID0ga2V5O1xuICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSAxO1xuICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBrZXkpO1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBjb25uZWN0ZWQgdG8gYnJva2VyYCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCB0ZXJtaW5hdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqL1xuICBhc3luYyBvbkRpc2Nvbm5lY3RlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUubGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkID0gc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkO1xuICAgIHN0YXRlLmxhc3RTeW5jaHJvbml6YXRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5zeW5jaHJvbml6ZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgIGNvbnN0IGluc3RhbmNlTnVtYmVyID0gdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldFJlZ2lvbihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn1gO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZV0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXTtcbiAgICBjbGVhclRpbWVvdXQoc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCk7XG4gICAgZGVsZXRlIHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQ7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCk7XG4gICAgZGVsZXRlIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dDtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZGlzY29ubmVjdGVkIGZyb20gYnJva2VyYCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3ltYm9sIHNwZWNpZmljYXRpb25zIHdlcmUgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gc3BlY2lmaWNhdGlvbnMgdXBkYXRlZCBzcGVjaWZpY2F0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHJlbW92ZWRTeW1ib2xzIHJlbW92ZWQgc3ltYm9sc1xuICAgKi9cbiAgYXN5bmMgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzKSB7XG4gICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwb3NpdGlvbiBzeW5jaHJvbml6YXRpb24gZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW4gaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqL1xuICBhc3luYyBvblBvc2l0aW9uc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcGVuZGluZyBvcmRlciBzeW5jaHJvbml6YXRpb24gZm5pc2hlZCB0byBpbmRpY2F0ZSBwcm9ncmVzcyBvZiBhbiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlXG4gICAqIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICovXG4gIGFzeW5jIG9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzeW5jaHJvbml6YXRpb24gb2YgaGlzdG9yeSBkZWFscyBvbiBhIE1ldGFUcmFkZXIgYWNjb3VudCBoYXZlIGZpbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuXG4gICAqIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uRGVhbHNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5kZWFsc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF0gPSB0cnVlO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZmluaXNoZWQgc3luY2hyb25pemF0aW9uICR7c3luY2hyb25pemF0aW9uSWR9YCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3luY2hyb25pemF0aW9uIG9mIGhpc3Rvcnkgb3JkZXJzIG9uIGEgTWV0YVRyYWRlciBhY2NvdW50IGhhdmUgZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW5cbiAgICogaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUub3JkZXJzU3luY2hyb25pemVkW3N5bmNocm9uaXphdGlvbklkXSA9IHRydWU7XG4gICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFBcGkgd2Vic29ja2V0IEFQSSByZXN0b3JlZCBhZnRlciBhIGRpc2Nvbm5lY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiByZWNvbm5lY3RlZCByZWdpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIHJlY29ubmVjdGVkIGluc3RhbmNlIG51bWJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0XG4gICAqL1xuICBhc3luYyBvblJlY29ubmVjdGVkKHJlZ2lvbiwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICBjb25zdCBpbnN0YW5jZVRlbXBsYXRlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpXG4gICAgICAuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChgJHtpbnN0YW5jZVRlbXBsYXRlfTpgKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhba2V5XTtcbiAgICAgIH0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlVGVtcGxhdGVdO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlVGVtcGxhdGVdKTtcbiAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZVRlbXBsYXRlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzdHJlYW0gZm9yIGFuIGluc3RhbmNlIGluZGV4IGlzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIE1ldGFUcmFkZXIgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIGlzIHN0YXJ0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNwZWNpZmljYXRpb25zSGFzaCBzcGVjaWZpY2F0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbnNIYXNoIHBvc2l0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcnNIYXNoIG9yZGVycyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnNIYXNoLCBwb3NpdGlvbnNIYXNoLCBvcmRlcnNIYXNoLCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBzdGFydGluZyBzeW5jaHJvbml6YXRpb24gJHtzeW5jaHJvbml6YXRpb25JZH1gKTtcbiAgICBjb25zdCBpbnN0YW5jZU51bWJlciA9IHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRSZWdpb24oaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9YDtcbiAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zW3JlZ2lvbl07XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdO1xuICAgIGxldCBzZXNzaW9uSWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdID0gc2Vzc2lvbklkO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBzZXNzaW9uSWQpO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkID0gc3luY2hyb25pemF0aW9uSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhY2NvdW50IHJlZ2lvbiBoYXMgYmVlbiB1bnN1YnNjcmliZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBhY2NvdW50IHJlZ2lvbiB1bnN1YnNjcmliZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblVuc3Vic2NyaWJlUmVnaW9uKHJlZ2lvbikge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMpXG4gICAgICAuZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnN0YXJ0c1dpdGgoYCR7cmVnaW9ufTpgKSlcbiAgICAgIC5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV07XG4gICAgICB9KTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleClcbiAgICAgIC5maWx0ZXIoaW5zdGFuY2UgPT4gaW5zdGFuY2Uuc3RhcnRzV2l0aChgJHtyZWdpb259OmApKVxuICAgICAgLmZvckVhY2goaW5zdGFuY2UgPT4gZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIG9wdGlvbmFsIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkLCBsYXN0IHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkIHdpbGwgYmUgdXNlZFxuICAgKiBieSBkZWZhdWx0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8Qm9vbGVhbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYSBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXJcbiAgICogdGVybWluYWxcbiAgICovXG4gIGFzeW5jIGlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXM8YW55Pih0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZUluZGV4ICE9PSB1bmRlZmluZWQgJiYgcy5pbnN0YW5jZUluZGV4ICE9PSBpbnN0YW5jZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGVja1N5bmNocm9uaXphdGlvbklkID0gc3luY2hyb25pemF0aW9uSWQgfHwgcy5sYXN0U3luY2hyb25pemF0aW9uSWQ7XG4gICAgICBsZXQgc3luY2hyb25pemVkID0gISFzLm9yZGVyc1N5bmNocm9uaXplZFtjaGVja1N5bmNocm9uaXphdGlvbklkXSAmJiBcbiAgICAgICAgISFzLmRlYWxzU3luY2hyb25pemVkW2NoZWNrU3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgcmV0dXJuIGFjYyB8fCBzeW5jaHJvbml6ZWQ7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFN5bmNocm9uaXphdGlvbk9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFthcHBsaWNhdGlvblBhdHRlcm5dIGFwcGxpY2F0aW9uIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuLCBkZWZhdWx0IGlzIC4qXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3luY2hyb25pemF0aW9uSWRdIHN5bmNocm9uaXphdGlvbiBpZCwgbGFzdCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZCB3aWxsIGJlIHVzZWQgYnlcbiAgICogZGVmYXVsdFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2luc3RhbmNlSW5kZXhdIGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgdG8gZW5zdXJlIHN5bmNocm9uaXphdGlvbiBvbiwgZGVmYXVsdCBpcyB0byB3YWl0XG4gICAqIGZvciB0aGUgZmlyc3QgaW5zdGFuY2UgdG8gc3luY2hyb25pemVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSB3YWl0IHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyA1bVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2ludGVydmFsSW5NaWxsaXNlY29uZHNdIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBzeW5jaHJvbml6YXRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtTeW5jaHJvbml6YXRpb25PcHRpb25zfSBvcHRzIHN5bmNocm9uaXphdGlvbiBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb21wbGV0ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhcHBsaWNhdGlvbiBmYWlsZWQgdG8gc3luY2hyb25pemUgd2l0aCB0aGUgdGVtaW5hbCB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBhc3luYyB3YWl0U3luY2hyb25pemVkKG9wdHMpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGxldCBpbnN0YW5jZUluZGV4ID0gb3B0cy5pbnN0YW5jZUluZGV4O1xuICAgIGxldCBzeW5jaHJvbml6YXRpb25JZCA9IG9wdHMuc3luY2hyb25pemF0aW9uSWQ7XG4gICAgbGV0IHRpbWVvdXRJblNlY29uZHMgPSBvcHRzLnRpbWVvdXRJblNlY29uZHMgfHwgMzAwO1xuICAgIGxldCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gb3B0cy5pbnRlcnZhbEluTWlsbGlzZWNvbmRzIHx8IDEwMDA7XG4gICAgbGV0IGFwcGxpY2F0aW9uUGF0dGVybiA9IG9wdHMuYXBwbGljYXRpb25QYXR0ZXJuIHx8XG4gICAgICAoKHRoaXMuX2FjY291bnQgYXMgYW55KS5hcHBsaWNhdGlvbiA9PT0gJ0NvcHlGYWN0b3J5JyA/ICdDb3B5RmFjdG9yeS4qfFJQQycgOiAnUlBDJyk7XG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHN5bmNocm9uaXplZDtcbiAgICB3aGlsZSAoIShzeW5jaHJvbml6ZWQgPSBhd2FpdCB0aGlzLmlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSkgJiZcbiAgICAgIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIGludGVydmFsSW5NaWxsaXNlY29uZHMpKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlO1xuICAgIGlmIChpbnN0YW5jZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAobGV0IHMgb2YgT2JqZWN0LnZhbHVlczxhbnk+KHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KSkge1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5pc1N5bmNocm9uaXplZChzLmluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSkge1xuICAgICAgICAgIHN0YXRlID0gcztcbiAgICAgICAgICBpbnN0YW5jZUluZGV4ID0gcy5pbnN0YW5jZUluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gT2JqZWN0LnZhbHVlczxhbnk+KHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5maW5kKHMgPT4gcy5pbnN0YW5jZUluZGV4ID09PSBpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgaWYgKCFzeW5jaHJvbml6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBNZXRhQXBpIHRvIHN5bmNocm9uaXplIHRvIE1ldGFUcmFkZXIgYWNjb3VudCAnICtcbiAgICAgICAgdGhpcy5fYWNjb3VudC5pZCArICcsIHN5bmNocm9uaXphdGlvbiBpZCAnICsgKHN5bmNocm9uaXphdGlvbklkIHx8IChzdGF0ZSAmJiBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQpIHx8XG4gICAgICAgICAgKHN0YXRlICYmIHN0YXRlLmxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZCkpKTtcbiAgICB9XG4gICAgbGV0IHRpbWVMZWZ0SW5TZWNvbmRzID0gTWF0aC5tYXgoMCwgdGltZW91dEluU2Vjb25kcyAtIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDApO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKHN0YXRlLmluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnNbcmVnaW9uXTtcbiAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQud2FpdFN5bmNocm9uaXplZChhY2NvdW50SWQsIHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCksXG4gICAgICBhcHBsaWNhdGlvblBhdHRlcm4sIHRpbWVMZWZ0SW5TZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uIFRoZSBpbnN0YW5jZSBvZiB0aGUgY2xhc3Mgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICovXG4gIGFzeW5jIGNsb3NlKGluc3RhbmNlSWQ/KSB7XG4gICAgaWYgKHRoaXMuX29wZW5lZCkge1xuICAgICAgdGhpcy5fb3BlbmVkSW5zdGFuY2VzID0gdGhpcy5fb3BlbmVkSW5zdGFuY2VzLmZpbHRlcihpZCA9PiBpZCAhPT0gaW5zdGFuY2VJZCk7XG4gICAgICBpZiAoIXRoaXMuX29wZW5lZEluc3RhbmNlcy5sZW5ndGggJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06IENsb3NpbmcgY29ubmVjdGlvbmApO1xuICAgICAgICBPYmplY3QudmFsdWVzPGFueT4odGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLmZvckVhY2goc3RhdGUgPT4gY2xlYXJUaW1lb3V0KHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQpKTtcbiAgICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXggPSB7fTtcbiAgICAgICAgYXdhaXQgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LnJlbW92ZVN0cmVhbWluZyh0aGlzLl9hY2NvdW50KTtcbiAgICAgICAgdGhpcy5fdGVybWluYWxTdGF0ZS5jbG9zZSgpO1xuICAgICAgICBjb25zdCBhY2NvdW50UmVnaW9ucyA9IHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnM7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX3Rlcm1pbmFsU3RhdGUpO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5faGlzdG9yeVN0b3JhZ2UpO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5faGVhbHRoTW9uaXRvcik7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcih0aGlzKTtcbiAgICAgICAgdGhpcy5faGVhbHRoTW9uaXRvci5zdG9wKCk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LnZhbHVlczxhbnk+KHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMpLmZvckVhY2godGltZW91dCA9PiBjbGVhclRpbWVvdXQodGltZW91dCkpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzID0ge307XG4gICAgICAgIE9iamVjdC52YWx1ZXMoYWNjb3VudFJlZ2lvbnMpLmZvckVhY2gocmVwbGljYUlkID0+IFxuICAgICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVBY2NvdW50Q2FjaGUocmVwbGljYUlkKSk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfTogQ2xvc2VkIGNvbm5lY3Rpb25gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzeW5jaHJvbml6YXRpb24gc3RhdHVzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHN5bmNocm9uaXphdGlvbiBzdGF0dXNcbiAgICovXG4gIGdldCBzeW5jaHJvbml6ZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXM8YW55Pih0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IGFjYyB8fCBzLnN5bmNocm9uaXplZCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YUFwaSBhY2NvdW50XG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50fSBNZXRhQXBpIGFjY291bnRcbiAgICovXG4gIGdldCBhY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtDb25uZWN0aW9uSGVhbHRoTW9uaXRvcn0gY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGhlYWx0aE1vbml0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWx0aE1vbml0b3I7XG4gIH1cblxuICBhc3luYyBfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pIHtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXSA9PT0gc2Vzc2lvbikge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zTGlzdCA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucyhrZXkpO1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnNJdGVtOiBhbnkgPSB7c3ltYm9sOiBrZXl9O1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zSXRlbS5zdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QucHVzaChzdWJzY3JpcHRpb25zSXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBFcnJvciByZWZyZXNoaW5nIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgam9iIGZvciBhY2NvdW50ICR7dGhpcy5fYWNjb3VudC5pZH0gYCArXG4gICAgICBgJHtpbnN0YW5jZU51bWJlcn1gLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV0gPT09IHNlc3Npb24pIHtcbiAgICAgICAgbGV0IHJlZnJlc2hJbnRlcnZhbCA9IChNYXRoLnJhbmRvbSgpICogKHRoaXMuX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCAtIFxuICAgICAgICAgIHRoaXMuX21pblN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCkgKyB0aGlzLl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwpICogMTAwMDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZV0gPSBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pLCByZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSB7XG4gICAgbGV0IHRyYWRlOiBhbnkgPSB7fTtcbiAgICBpZiAodHlwZW9mIHN0b3BMb3NzID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcztcbiAgICB9IGVsc2UgaWYgKHN0b3BMb3NzKSB7XG4gICAgICB0cmFkZS5zdG9wTG9zcyA9IHN0b3BMb3NzLnZhbHVlO1xuICAgICAgdHJhZGUuc3RvcExvc3NVbml0cyA9IHN0b3BMb3NzLnVuaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRha2VQcm9maXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdDtcbiAgICB9IGVsc2UgaWYgKHRha2VQcm9maXQpIHtcbiAgICAgIHRyYWRlLnRha2VQcm9maXQgPSB0YWtlUHJvZml0LnZhbHVlO1xuICAgICAgdHJhZGUudGFrZVByb2ZpdFVuaXRzID0gdGFrZVByb2ZpdC51bml0cztcbiAgICB9XG4gICAgcmV0dXJuIHRyYWRlO1xuICB9XG5cbiAgYXN5bmMgX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBrZXkpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUuc2hvdWxkU3luY2hyb25pemUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3luY2hyb25pemF0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy5zeW5jaHJvbml6ZShpbnN0YW5jZUluZGV4KTtcbiAgICAgICAgaWYgKHN5bmNocm9uaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLl9sYXRlbmN5U2VydmljZS5nZXRTeW5jaHJvbml6ZWRBY2NvdW50SW5zdGFuY2VzKHRoaXMuX2FjY291bnQuaWQpLmxlbmd0aCA/ICdkZWJ1ZycgOiAnZXJyb3InO1xuICAgICAgICB0aGlzLl9sb2dnZXJbbGV2ZWxdKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgZm9yIGFjY291bnQgJyArIHRoaXMuX2FjY291bnQuaWQgK1xuICAgICAgICAgICc6JyArIGluc3RhbmNlSW5kZXggKyAnIGZhaWxlZCB0byBzeW5jaHJvbml6ZScsIGVycik7XG4gICAgICAgIGlmIChzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSA9PT0ga2V5KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCk7XG4gICAgICAgICAgc3RhdGUuZW5zdXJlU3luY2hyb25pemVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9lbnN1cmVTeW5jaHJvbml6ZWQuYmluZCh0aGlzLCBpbnN0YW5jZUluZGV4LCBrZXkpLFxuICAgICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDEwMDApO1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSBNYXRoLm1pbihzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzICogMiwgMzAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdKSB7XG4gICAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdID0ge1xuICAgICAgICBpbnN0YW5jZUluZGV4LFxuICAgICAgICBvcmRlcnNTeW5jaHJvbml6ZWQ6IHt9LFxuICAgICAgICBkZWFsc1N5bmNocm9uaXplZDoge30sXG4gICAgICAgIHNob3VsZFN5bmNocm9uaXplOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHM6IDEsXG4gICAgICAgIHN5bmNocm9uaXplZDogZmFsc2UsXG4gICAgICAgIGxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0U3luY2hyb25pemF0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGlzY29ubmVjdGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICBfc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQpO1xuICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fY2hlY2tTeW5jaHJvbml6YXRpb25UaW1lZE91dChpbnN0YW5jZUluZGV4KSwgMiAqIDYwICogMTAwMCk7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogc2NoZWR1bGVkIHN5bmNocm9uaXphdGlvbiB0aW1lb3V0YCk7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrU3luY2hyb25pemF0aW9uVGltZWRPdXQoaW5zdGFuY2VJbmRleCkge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBjaGVja2luZyBpZiBzeW5jaHJvbml6YXRpb24gdGltZWQgb3V0IG91dGApO1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIGlmIChzdGF0ZSAmJiAhdGhpcy5fY2xvc2VkKSB7XG4gICAgICBsZXQgc3luY2hyb25pemF0aW9uSWQgPSBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQ7XG4gICAgICBsZXQgc3luY2hyb25pemVkID0gISFzdGF0ZS5kZWFsc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF07XG4gICAgICBpZiAoIXN5bmNocm9uaXplZCAmJiBzeW5jaHJvbml6YXRpb25JZCAmJiBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSkge1xuICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiByZXN5bmNocm9uaXplZCBzaW5jZSBsYXRlc3Qgc3luY2hyb25pemF0aW9uIGAgK1xuICAgICAgICAgIGAke3N5bmNocm9uaXphdGlvbklkfSBkaWQgbm90IGZpbmlzaCBpbiB0aW1lYCk7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJTdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbiIsIk1ldGFBcGlDb25uZWN0aW9uIiwiY29ubmVjdCIsImluc3RhbmNlSWQiLCJfb3BlbmVkSW5zdGFuY2VzIiwiaW5jbHVkZXMiLCJwdXNoIiwiX29wZW5lZCIsIl9sb2dnZXIiLCJ0cmFjZSIsIl9hY2NvdW50IiwiaWQiLCJfaGVhbHRoTW9uaXRvciIsInN0YXJ0IiwiaW5pdGlhbGl6ZSIsInN1YnNjcmliZSIsImVyciIsImNsb3NlIiwicmVtb3ZlQXBwbGljYXRpb24iLCJfY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUiLCJfaGlzdG9yeVN0b3JhZ2UiLCJjbGVhciIsIl93ZWJzb2NrZXRDbGllbnQiLCJzeW5jaHJvbml6ZSIsImluc3RhbmNlSW5kZXgiLCJyZWdpb24iLCJnZXRSZWdpb24iLCJpbnN0YW5jZSIsImdldEluc3RhbmNlTnVtYmVyIiwiaG9zdCIsImdldEhvc3ROYW1lIiwic3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lIiwiRGF0ZSIsIk1hdGgiLCJtYXgiLCJfaGlzdG9yeVN0YXJ0VGltZSIsImdldFRpbWUiLCJsYXN0SGlzdG9yeU9yZGVyVGltZSIsInN0YXJ0aW5nRGVhbFRpbWUiLCJsYXN0RGVhbFRpbWUiLCJzeW5jaHJvbml6YXRpb25JZCIsInJhbmRvbXN0cmluZyIsImdlbmVyYXRlIiwiX2dldFN0YXRlIiwibGFzdFN5bmNocm9uaXphdGlvbklkIiwiYWNjb3VudElkIiwiYWNjb3VudFJlZ2lvbnMiLCJkZWJ1ZyIsInRlcm1pbmFsU3RhdGUiLCJnZXRIYXNoZXMiLCJfY29ubmVjdGlvblJlZ2lzdHJ5IiwiYXBwbGljYXRpb24iLCJhZGRBY2NvdW50Q2FjaGUiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsInJlcGxpY2FJZCIsIl9vcHRpb25zIiwiZW5zdXJlU3Vic2NyaWJlIiwic3Vic2NyaWJlVG9NYXJrZXREYXRhIiwic3ltYm9sIiwic3Vic2NyaXB0aW9ucyIsInRpbWVvdXRJblNlY29uZHMiLCJ3YWl0Rm9yUXVvdGUiLCJfdGVybWluYWxTdGF0ZSIsInNwZWNpZmljYXRpb24iLCJWYWxpZGF0aW9uRXJyb3IiLCJ0eXBlIiwiX3N1YnNjcmlwdGlvbnMiLCJwcmV2U3Vic2NyaXB0aW9ucyIsInN1YnNjcmlwdGlvbiIsImluZGV4IiwiZmluZEluZGV4IiwiaXRlbSIsInRpbWVmcmFtZSIsInJlbGlhYmlsaXR5IiwiZmluZCIsInMiLCJ3YWl0Rm9yUHJpY2UiLCJ1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhIiwidW5zdWJzY3JpcHRpb25zIiwiZmlsdGVyIiwidW5zdWJzY3JpcHRpb24iLCJsZW5ndGgiLCJvblN1YnNjcmlwdGlvbkRvd25ncmFkZWQiLCJ1cGRhdGVzIiwiY2F0Y2giLCJtZXRob2QiLCJuYW1lIiwiZXJyb3IiLCJzdWJzY3JpYmVkU3ltYm9scyIsImtleXMiLCJoaXN0b3J5U3RvcmFnZSIsIm9uQ29ubmVjdGVkIiwicmVwbGljYXMiLCJrZXkiLCJzdGF0ZSIsImNhbmNlbFJlZnJlc2giLCJfdGVybWluYWxIYXNoTWFuYWdlciIsInJlZnJlc2hJZ25vcmVkRmllbGRMaXN0cyIsInNob3VsZFN5bmNocm9uaXplIiwic3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyIsInN5bmNocm9uaXplZCIsIl9lbnN1cmVTeW5jaHJvbml6ZWQiLCJvbkRpc2Nvbm5lY3RlZCIsImxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZCIsInVuZGVmaW5lZCIsImRpc2Nvbm5lY3RlZCIsImluc3RhbmNlTnVtYmVyIiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnMiLCJjbGVhclRpbWVvdXQiLCJfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0cyIsInN5bmNocm9uaXphdGlvblRpbWVvdXQiLCJlbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCIsInNwZWNpZmljYXRpb25zIiwicmVtb3ZlZFN5bWJvbHMiLCJfc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0Iiwib25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQiLCJvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQiLCJvbkRlYWxzU3luY2hyb25pemVkIiwiZGVhbHNTeW5jaHJvbml6ZWQiLCJvbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWQiLCJvcmRlcnNTeW5jaHJvbml6ZWQiLCJvblJlY29ubmVjdGVkIiwiaW5zdGFuY2VUZW1wbGF0ZSIsIl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCIsInN0YXJ0c1dpdGgiLCJvblN0cmVhbUNsb3NlZCIsIm9uU3luY2hyb25pemF0aW9uU3RhcnRlZCIsInNwZWNpZmljYXRpb25zSGFzaCIsInBvc2l0aW9uc0hhc2giLCJvcmRlcnNIYXNoIiwic2Vzc2lvbklkIiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyIsIl9jbG9zZWQiLCJvblVuc3Vic2NyaWJlUmVnaW9uIiwiaXNTeW5jaHJvbml6ZWQiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJhY2MiLCJjaGVja1N5bmNocm9uaXphdGlvbklkIiwid2FpdFN5bmNocm9uaXplZCIsIm9wdHMiLCJpbnRlcnZhbEluTWlsbGlzZWNvbmRzIiwiYXBwbGljYXRpb25QYXR0ZXJuIiwic3RhcnRUaW1lIiwibm93IiwiUHJvbWlzZSIsInJlcyIsInNldFRpbWVvdXQiLCJUaW1lb3V0RXJyb3IiLCJ0aW1lTGVmdEluU2Vjb25kcyIsInJlbW92ZVN0cmVhbWluZyIsInJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwicmVtb3ZlUmVjb25uZWN0TGlzdGVuZXIiLCJzdG9wIiwidGltZW91dCIsInJlbW92ZUFjY291bnRDYWNoZSIsImFjY291bnQiLCJoZWFsdGhNb25pdG9yIiwic2Vzc2lvbiIsImdldEFjY291bnRSZWdpb24iLCJzdWJzY3JpcHRpb25zTGlzdCIsInN1YnNjcmlwdGlvbnNJdGVtIiwicmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zIiwicmVmcmVzaEludGVydmFsIiwicmFuZG9tIiwiX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCIsIl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwiLCJfZ2VuZXJhdGVTdG9wT3B0aW9ucyIsInN0b3BMb3NzIiwidGFrZVByb2ZpdCIsInRyYWRlIiwidmFsdWUiLCJzdG9wTG9zc1VuaXRzIiwidW5pdHMiLCJ0YWtlUHJvZml0VW5pdHMiLCJzeW5jaHJvbml6YXRpb25SZXN1bHQiLCJsZXZlbCIsIl9sYXRlbmN5U2VydmljZSIsImdldFN5bmNocm9uaXplZEFjY291bnRJbnN0YW5jZXMiLCJiaW5kIiwibWluIiwiX2NoZWNrU3luY2hyb25pemF0aW9uVGltZWRPdXQiLCJ3YXJuIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwid2Vic29ja2V0Q2xpZW50IiwidGVybWluYWxIYXNoTWFuYWdlciIsImNvbm5lY3Rpb25SZWdpc3RyeSIsImhpc3RvcnlTdGFydFRpbWUiLCJyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMiLCJ2YWxpZGF0b3IiLCJPcHRpb25zVmFsaWRhdG9yIiwidmFsaWRhdGVOb25aZXJvIiwibWluRGVsYXlJblNlY29uZHMiLCJtYXhEZWxheUluU2Vjb25kcyIsIlRlcm1pbmFsU3RhdGUiLCJNZW1vcnlIaXN0b3J5U3RvcmFnZSIsIkNvbm5lY3Rpb25IZWFsdGhNb25pdG9yIiwiYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJhZGRSZWNvbm5lY3RMaXN0ZW5lciIsIkxvZ2dlck1hbmFnZXIiLCJnZXRMb2dnZXIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O2VBZXFCQTs7O3NFQWJLOzZFQUNPO3FFQUNSO3FFQUNBO2dGQUNXOzhCQUNOO3lFQUNEOytEQUNIOzBFQUNJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS2YsSUFBQSxBQUFNQSw2QkFBTixNQUFNQSxtQ0FBbUNDLDBCQUFpQjtJQXVEdkU7Ozs7R0FJQyxHQUNELE1BQU1DLFFBQVFDLFVBQVUsRUFBRTtRQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0MsUUFBUSxDQUFDRixhQUFhO1lBQy9DLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNFLElBQUksQ0FBQ0g7UUFDN0I7UUFDQSxJ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