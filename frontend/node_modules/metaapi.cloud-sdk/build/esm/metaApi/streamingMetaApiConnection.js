'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import TerminalState from './terminalState';
import MemoryHistoryStorage from './memoryHistoryStorage';
import TimeoutError from '../clients/timeoutError';
import randomstring from 'randomstring';
import ConnectionHealthMonitor from './connectionHealthMonitor';
import { ValidationError } from '../clients/errorHandler';
import OptionsValidator from '../clients/optionsValidator';
import LoggerManager from '../logger';
import MetaApiConnection from './metaApiConnection';
let StreamingMetaApiConnection = class StreamingMetaApiConnection extends MetaApiConnection {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @param {string} instanceId connection instance id
   * @return {Promise} promise resolving when the connection is opened
   */ connect(instanceId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this._openedInstances.includes(instanceId)) {
                _this._openedInstances.push(instanceId);
            }
            if (!_this._opened) {
                _this._logger.trace(`${_this._account.id}: Opening connection`);
                _this._opened = true;
                try {
                    _this._healthMonitor.start();
                    yield _this.initialize();
                    yield _this.subscribe();
                } catch (err) {
                    yield _this.close();
                    throw err;
                }
            }
        })();
    }
    /**
   * Clears the order and transaction history of a specified application and removes application
   * @return {Promise} promise resolving when the history is cleared and application is removed
   */ removeApplication() {
        this._checkIsConnectionActive();
        this._historyStorage.clear();
        return this._websocketClient.removeApplication(this._account.id);
    }
    /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/)
   * @param {String} instanceIndex instance index
   * @returns {Promise} promise which resolves when synchronization started
   */ synchronize(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            const region = _this.getRegion(instanceIndex);
            const instance = _this.getInstanceNumber(instanceIndex);
            const host = _this.getHostName(instanceIndex);
            let startingHistoryOrderTime = new Date(Math.max((_this._historyStartTime || new Date(0)).getTime(), (yield _this._historyStorage.lastHistoryOrderTime(instance)).getTime()));
            let startingDealTime = new Date(Math.max((_this._historyStartTime || new Date(0)).getTime(), (yield _this._historyStorage.lastDealTime(instance)).getTime()));
            let synchronizationId = randomstring.generate(32);
            _this._getState(instanceIndex).lastSynchronizationId = synchronizationId;
            const accountId = _this._account.accountRegions[region];
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: initiating synchronization ${synchronizationId}`);
            return _this._websocketClient.synchronize(accountId, instance, host, synchronizationId, startingHistoryOrderTime, startingDealTime, _this.terminalState.getHashes());
        })();
    }
    /**
   * Initializes meta api connection
   * @return {Promise} promise which resolves when meta api connection is initialized
   */ initialize() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            yield _this._historyStorage.initialize(_this._account.id, _this._connectionRegistry.application);
            _this._websocketClient.addAccountCache(_this._account.id, _this._account.accountRegions);
        })();
    }
    /**
   * Initiates subscription to MetaTrader terminal
   * @returns {Promise} promise which resolves when subscription is initiated
   */ subscribe() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            const accountRegions = _this._account.accountRegions;
            Object.entries(accountRegions).forEach(([region, replicaId])=>{
                if (!_this._options.region || _this._options.region === region) {
                    _this._websocketClient.ensureSubscribe(replicaId, 0);
                    _this._websocketClient.ensureSubscribe(replicaId, 1);
                }
            });
        })();
    }
    /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update. Please
   * note that this feature is not fully implemented on server-side yet
   * @param {number} [timeoutInSeconds] timeout to wait for prices in seconds, default is 30
   * @param {boolean} [waitForQuote] if set to false, the method will resolve without waiting for the first quote to
   * arrive. Default is to wait for quote if quotes subscription is requested.
   * @returns {Promise} promise which resolves when subscription request was processed
   */ subscribeToMarketData(symbol, subscriptions, timeoutInSeconds, waitForQuote = true) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            if (!_this._terminalState.specification(symbol)) {
                throw new ValidationError(`${_this._account.id}: Cannot subscribe to market data for symbol ${symbol} because ` + 'symbol does not exist');
            } else {
                subscriptions = subscriptions || [
                    {
                        type: 'quotes'
                    }
                ];
                if (_this._subscriptions[symbol]) {
                    const prevSubscriptions = _this._subscriptions[symbol].subscriptions;
                    subscriptions.forEach((subscription)=>{
                        const index = subscription.type === 'candles' ? prevSubscriptions.findIndex((item)=>item.type === subscription.type && item.timeframe === subscription.timeframe) : prevSubscriptions.findIndex((item)=>item.type === subscription.type);
                        if (index === -1) {
                            prevSubscriptions.push(subscription);
                        } else {
                            prevSubscriptions[index] = subscription;
                        }
                    });
                } else {
                    _this._subscriptions[symbol] = {
                        subscriptions
                    };
                }
                yield _this._websocketClient.subscribeToMarketData(_this._account.id, symbol, subscriptions, _this._account.reliability);
                if (waitForQuote !== false && subscriptions.find((s)=>s.type === 'quotes')) {
                    return _this.terminalState.waitForPrice(symbol, timeoutInSeconds);
                }
            }
        })();
    }
    /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */ unsubscribeFromMarketData(symbol, unsubscriptions) {
        this._checkIsConnectionActive();
        if (!unsubscriptions) {
            delete this._subscriptions[symbol];
        } else if (this._subscriptions[symbol]) {
            this._subscriptions[symbol].subscriptions = this._subscriptions[symbol].subscriptions.filter((subscription)=>{
                return !unsubscriptions.find((unsubscription)=>subscription.type === unsubscription.type && (!unsubscription.timeframe || subscription.timeframe === unsubscription.timeframe));
            });
            if (!this._subscriptions[symbol].subscriptions.length) {
                delete this._subscriptions[symbol];
            }
        }
        return this._websocketClient.unsubscribeFromMarketData(this._account.id, symbol, unsubscriptions, this._account.reliability);
    }
    /**
   * Invoked when subscription downgrade has occurred
   * @param {String} instanceIndex index of an account instance connected
   * @param {string} symbol symbol to update subscriptions for
   * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ // eslint-disable-next-line complexity
    onSubscriptionDowngraded(instanceIndex, symbol, updates, unsubscriptions) {
        var _this = this;
        return _async_to_generator(function*() {
            if (unsubscriptions === null || unsubscriptions === void 0 ? void 0 : unsubscriptions.length) {
                _this.unsubscribeFromMarketData(symbol, unsubscriptions).catch((err)=>{
                    let method = err.name !== 'ValidationError' ? 'error' : 'trace';
                    _this._logger[method](`${_this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
                });
            }
            if (updates === null || updates === void 0 ? void 0 : updates.length) {
                _this.subscribeToMarketData(symbol, updates).catch((err)=>{
                    _this._logger.error(`${_this._account.id}: failed do subscribe from market data on subscription downgraded`, err);
                });
            }
        })();
    }
    /**
   * Returns list of the symbols connection is subscribed to
   * @returns {Array<String>} list of the symbols connection is subscribed to
   */ get subscribedSymbols() {
        return Object.keys(this._subscriptions);
    }
    /**
   * Returns subscriptions for a symbol
   * @param {string} symbol symbol to retrieve subscriptions for
   * @returns {Array<MarketDataSubscription>} list of market data subscriptions for the symbol
   */ subscriptions(symbol) {
        this._checkIsConnectionActive();
        return (this._subscriptions[symbol] || {}).subscriptions;
    }
    /**
   * Returns local copy of terminal state
   * @returns {TerminalState} local copy of terminal state
   */ get terminalState() {
        return this._terminalState;
    }
    /**
   * Returns local history storage
   * @returns {HistoryStorage} local history storage
   */ get historyStorage() {
        return this._historyStorage;
    }
    /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onConnected(instanceIndex, replicas) {
        var _this = this;
        return _async_to_generator(function*() {
            let key = randomstring.generate(32);
            let state = _this._getState(instanceIndex);
            const region = _this.getRegion(instanceIndex);
            _this.cancelRefresh(region);
            yield _this._terminalHashManager.refreshIgnoredFieldLists(region);
            state.shouldSynchronize = key;
            state.synchronizationRetryIntervalInSeconds = 1;
            state.synchronized = false;
            _this._ensureSynchronized(instanceIndex, key);
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: connected to broker`);
        })();
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */ onDisconnected(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            state.lastDisconnectedSynchronizationId = state.lastSynchronizationId;
            state.lastSynchronizationId = undefined;
            state.shouldSynchronize = undefined;
            state.synchronized = false;
            state.disconnected = true;
            const instanceNumber = _this.getInstanceNumber(instanceIndex);
            const region = _this.getRegion(instanceIndex);
            const instance = `${region}:${instanceNumber}`;
            delete _this._refreshMarketDataSubscriptionSessions[instance];
            clearTimeout(_this._refreshMarketDataSubscriptionTimeouts[instance]);
            delete _this._refreshMarketDataSubscriptionTimeouts[instance];
            clearTimeout(state.synchronizationTimeout);
            delete state.synchronizationTimeout;
            clearTimeout(state.ensureSynchronizeTimeout);
            delete state.ensureSynchronizeTimeout;
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: disconnected from broker`);
        })();
    }
    /**
   * Invoked when a symbol specifications were updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */ onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._scheduleSynchronizationTimeout(instanceIndex);
        })();
    }
    /**
   * Invoked when position synchronization finished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */ onPositionsSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._scheduleSynchronizationTimeout(instanceIndex);
        })();
    }
    /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */ onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._scheduleSynchronizationTimeout(instanceIndex);
        })();
    }
    /**
   * Invoked when a synchronization of history deals on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onDealsSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            state.dealsSynchronized[synchronizationId] = true;
            _this._scheduleSynchronizationTimeout(instanceIndex);
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: finished synchronization ${synchronizationId}`);
        })();
    }
    /**
   * Invoked when a synchronization of history orders on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onHistoryOrdersSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            state.ordersSynchronized[synchronizationId] = true;
            _this._scheduleSynchronizationTimeout(instanceIndex);
        })();
    }
    /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect
   * @param {String} region reconnected region
   * @param {Number} instanceNumber reconnected instance number
   * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
   */ onReconnected(region, instanceNumber) {
        var _this = this;
        return _async_to_generator(function*() {
            const instanceTemplate = `${region}:${instanceNumber}`;
            Object.keys(_this._stateByInstanceIndex).filter((key)=>key.startsWith(`${instanceTemplate}:`)).forEach((key)=>{
                delete _this._stateByInstanceIndex[key];
            });
            delete _this._refreshMarketDataSubscriptionSessions[instanceTemplate];
            clearTimeout(_this._refreshMarketDataSubscriptionTimeouts[instanceTemplate]);
            delete _this._refreshMarketDataSubscriptionTimeouts[instanceTemplate];
        })();
    }
    /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onStreamClosed(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            delete _this._stateByInstanceIndex[instanceIndex];
        })();
    }
    /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {string} instanceIndex index of an account instance connected
   * @param {string} specificationsHash specifications hash
   * @param {string} positionsHash positions hash
   * @param {string} ordersHash orders hash
   * @param {string} synchronizationId synchronization id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: starting synchronization ${synchronizationId}`);
            const instanceNumber = _this.getInstanceNumber(instanceIndex);
            const region = _this.getRegion(instanceIndex);
            const instance = `${region}:${instanceNumber}`;
            const accountId = _this._account.accountRegions[region];
            delete _this._refreshMarketDataSubscriptionSessions[instance];
            let sessionId = randomstring.generate(32);
            _this._refreshMarketDataSubscriptionSessions[instance] = sessionId;
            clearTimeout(_this._refreshMarketDataSubscriptionTimeouts[instance]);
            delete _this._refreshMarketDataSubscriptionTimeouts[instance];
            yield _this._refreshMarketDataSubscriptions(accountId, instanceNumber, sessionId);
            _this._scheduleSynchronizationTimeout(instanceIndex);
            let state = _this._getState(instanceIndex);
            if (state && !_this._closed) {
                state.lastSynchronizationId = synchronizationId;
            }
        })();
    }
    /**
   * Invoked when account region has been unsubscribed
   * @param {String} region account region unsubscribed
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onUnsubscribeRegion(region) {
        var _this = this;
        return _async_to_generator(function*() {
            Object.keys(_this._refreshMarketDataSubscriptionTimeouts).filter((instance)=>instance.startsWith(`${region}:`)).forEach((instance)=>{
                clearTimeout(_this._refreshMarketDataSubscriptionTimeouts[instance]);
                delete _this._refreshMarketDataSubscriptionTimeouts[instance];
                delete _this._refreshMarketDataSubscriptionSessions[instance];
            });
            Object.keys(_this._stateByInstanceIndex).filter((instance)=>instance.startsWith(`${region}:`)).forEach((instance)=>delete _this._stateByInstanceIndex[instance]);
        })();
    }
    /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId optional synchronization request id, last synchronization request id will be used
   * by default
   * @return {Promise<Boolean>} promise resolving with a flag indicating status of state synchronization with MetaTrader
   * terminal
   */ isSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            return Object.values(_this._stateByInstanceIndex).reduce((acc, s)=>{
                if (instanceIndex !== undefined && s.instanceIndex !== instanceIndex) {
                    return acc;
                }
                const checkSynchronizationId = synchronizationId || s.lastSynchronizationId;
                let synchronized = !!s.ordersSynchronized[checkSynchronizationId] && !!s.dealsSynchronized[checkSynchronizationId];
                return acc || synchronized;
            }, false);
        })();
    }
    /**
   * @typedef {Object} SynchronizationOptions
   * @property {String} [applicationPattern] application regular expression pattern, default is .*
   * @property {String} [synchronizationId] synchronization id, last synchronization request id will be used by
   * default
   * @property {Number} [instanceIndex] index of an account instance to ensure synchronization on, default is to wait
   * for the first instance to synchronize
   * @property {Number} [timeoutInSeconds] wait timeout in seconds, default is 5m
   * @property {Number} [intervalInMilliseconds] interval between account reloads while waiting for a change, default is 1s
   */ /**
   * Waits until synchronization to MetaTrader terminal is completed
   * @param {SynchronizationOptions} opts synchronization options
   * @return {Promise} promise which resolves when synchronization to MetaTrader terminal is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal within timeout allowed
   */ // eslint-disable-next-line complexity
    waitSynchronized(opts) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            opts = opts || {};
            let instanceIndex = opts.instanceIndex;
            let synchronizationId = opts.synchronizationId;
            let timeoutInSeconds = opts.timeoutInSeconds || 300;
            let intervalInMilliseconds = opts.intervalInMilliseconds || 1000;
            let applicationPattern = opts.applicationPattern || (_this._account.application === 'CopyFactory' ? 'CopyFactory.*|RPC' : 'RPC');
            let startTime = Date.now();
            let synchronized;
            while(!(synchronized = yield _this.isSynchronized(instanceIndex, synchronizationId)) && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield new Promise((res)=>setTimeout(res, intervalInMilliseconds));
            }
            let state;
            if (instanceIndex === undefined) {
                for (let s of Object.values(_this._stateByInstanceIndex)){
                    if (yield _this.isSynchronized(s.instanceIndex, synchronizationId)) {
                        state = s;
                        instanceIndex = s.instanceIndex;
                    }
                }
            } else {
                state = Object.values(_this._stateByInstanceIndex).find((s)=>s.instanceIndex === instanceIndex);
            }
            if (!synchronized) {
                throw new TimeoutError('Timed out waiting for MetaApi to synchronize to MetaTrader account ' + _this._account.id + ', synchronization id ' + (synchronizationId || state && state.lastSynchronizationId || state && state.lastDisconnectedSynchronizationId));
            }
            let timeLeftInSeconds = Math.max(0, timeoutInSeconds - (Date.now() - startTime) / 1000);
            const region = _this.getRegion(state.instanceIndex);
            const accountId = _this._account.accountRegions[region];
            yield _this._websocketClient.waitSynchronized(accountId, _this.getInstanceNumber(instanceIndex), applicationPattern, timeLeftInSeconds);
        })();
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   * @param {string} instanceId connection instance id
   */ close(instanceId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._opened) {
                _this._openedInstances = _this._openedInstances.filter((id)=>id !== instanceId);
                if (!_this._openedInstances.length && !_this._closed) {
                    _this._logger.debug(`${_this._account.id}: Closing connection`);
                    Object.values(_this._stateByInstanceIndex).forEach((state)=>clearTimeout(state.synchronizationTimeout));
                    _this._stateByInstanceIndex = {};
                    yield _this._connectionRegistry.removeStreaming(_this._account);
                    _this._terminalState.close();
                    const accountRegions = _this._account.accountRegions;
                    _this._websocketClient.removeSynchronizationListener(_this._account.id, _this);
                    _this._websocketClient.removeSynchronizationListener(_this._account.id, _this._terminalState);
                    _this._websocketClient.removeSynchronizationListener(_this._account.id, _this._historyStorage);
                    _this._websocketClient.removeSynchronizationListener(_this._account.id, _this._healthMonitor);
                    _this._websocketClient.removeReconnectListener(_this);
                    _this._healthMonitor.stop();
                    _this._refreshMarketDataSubscriptionSessions = {};
                    Object.values(_this._refreshMarketDataSubscriptionTimeouts).forEach((timeout)=>clearTimeout(timeout));
                    _this._refreshMarketDataSubscriptionTimeouts = {};
                    Object.values(accountRegions).forEach((replicaId)=>_this._websocketClient.removeAccountCache(replicaId));
                    _this._closed = true;
                    _this._logger.trace(`${_this._account.id}: Closed connection`);
                }
            }
        })();
    }
    /**
   * Returns synchronization status
   * @return {boolean} synchronization status
   */ get synchronized() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.synchronized, false);
    }
    /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */ get account() {
        return this._account;
    }
    /**
   * Returns connection health monitor instance
   * @return {ConnectionHealthMonitor} connection health monitor instance
   */ get healthMonitor() {
        return this._healthMonitor;
    }
    _refreshMarketDataSubscriptions(accountId, instanceNumber, session) {
        var _this = this;
        return _async_to_generator(function*() {
            const region = _this._websocketClient.getAccountRegion(accountId);
            const instance = `${region}:${instanceNumber}`;
            try {
                if (_this._refreshMarketDataSubscriptionSessions[instance] === session) {
                    const subscriptionsList = [];
                    Object.keys(_this._subscriptions).forEach((key)=>{
                        const subscriptions = _this.subscriptions(key);
                        const subscriptionsItem = {
                            symbol: key
                        };
                        if (subscriptions) {
                            subscriptionsItem.subscriptions = subscriptions;
                        }
                        subscriptionsList.push(subscriptionsItem);
                    });
                    yield _this._websocketClient.refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptionsList);
                }
            } catch (err) {
                _this._logger.error(`Error refreshing market data subscriptions job for account ${_this._account.id} ` + `${instanceNumber}`, err);
            } finally{
                if (_this._refreshMarketDataSubscriptionSessions[instance] === session) {
                    let refreshInterval = (Math.random() * (_this._maxSubscriptionRefreshInterval - _this._minSubscriptionRefreshInterval) + _this._minSubscriptionRefreshInterval) * 1000;
                    _this._refreshMarketDataSubscriptionTimeouts[instance] = setTimeout(()=>_this._refreshMarketDataSubscriptions(accountId, instanceNumber, session), refreshInterval);
                }
            }
        })();
    }
    _generateStopOptions(stopLoss, takeProfit) {
        let trade = {};
        if (typeof stopLoss === 'number') {
            trade.stopLoss = stopLoss;
        } else if (stopLoss) {
            trade.stopLoss = stopLoss.value;
            trade.stopLossUnits = stopLoss.units;
        }
        if (typeof takeProfit === 'number') {
            trade.takeProfit = takeProfit;
        } else if (takeProfit) {
            trade.takeProfit = takeProfit.value;
            trade.takeProfitUnits = takeProfit.units;
        }
        return trade;
    }
    _ensureSynchronized(instanceIndex, key) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            if (state && state.shouldSynchronize && !_this._closed) {
                try {
                    const synchronizationResult = yield _this.synchronize(instanceIndex);
                    if (synchronizationResult) {
                        state.synchronized = true;
                        state.synchronizationRetryIntervalInSeconds = 1;
                        delete state.ensureSynchronizeTimeout;
                    }
                    _this._scheduleSynchronizationTimeout(instanceIndex);
                } catch (err) {
                    const level = _this._latencyService.getSynchronizedAccountInstances(_this._account.id).length ? 'debug' : 'error';
                    _this._logger[level]('MetaApi websocket client for account ' + _this._account.id + ':' + instanceIndex + ' failed to synchronize', err);
                    if (state.shouldSynchronize === key) {
                        clearTimeout(state.ensureSynchronizeTimeout);
                        state.ensureSynchronizeTimeout = setTimeout(_this._ensureSynchronized.bind(_this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
                        state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
                    }
                }
            }
        })();
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex['' + instanceIndex]) {
            this._stateByInstanceIndex['' + instanceIndex] = {
                instanceIndex,
                ordersSynchronized: {},
                dealsSynchronized: {},
                shouldSynchronize: undefined,
                synchronizationRetryIntervalInSeconds: 1,
                synchronized: false,
                lastDisconnectedSynchronizationId: undefined,
                lastSynchronizationId: undefined,
                disconnected: false
            };
        }
        return this._stateByInstanceIndex['' + instanceIndex];
    }
    _scheduleSynchronizationTimeout(instanceIndex) {
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            clearTimeout(state.synchronizationTimeout);
            state.synchronizationTimeout = setTimeout(()=>this._checkSynchronizationTimedOut(instanceIndex), 2 * 60 * 1000);
            this._logger.debug(`${this._account.id}:${instanceIndex}: scheduled synchronization timeout`);
        }
    }
    _checkSynchronizationTimedOut(instanceIndex) {
        this._logger.debug(`${this._account.id}:${instanceIndex}: checking if synchronization timed out out`);
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            let synchronizationId = state.lastSynchronizationId;
            let synchronized = !!state.dealsSynchronized[synchronizationId];
            if (!synchronized && synchronizationId && state.shouldSynchronize) {
                this._logger.warn(`${this._account.id}:${instanceIndex}: resynchronized since latest synchronization ` + `${synchronizationId} did not finish in time`);
                this._ensureSynchronized(instanceIndex, state.shouldSynchronize);
            }
        }
    }
    /**
   * Constructs MetaApi MetaTrader streaming Api connection
   * @param {MetaApiOpts} options metaapi options
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {TerminalHashManager} terminalHashManager terminal hash manager
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {HistoryStorage} historyStorage terminal history storage. By default an instance of MemoryHistoryStorage
   * will be used.
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {Date} [historyStartTime] history start sync time
   * @param {RefreshSubscriptionsOpts} [refreshSubscriptionsOpts] subscriptions refresh options
   */ constructor(options, websocketClient, terminalHashManager, account, historyStorage, connectionRegistry, historyStartTime, refreshSubscriptionsOpts){
        super(options, websocketClient, account);
        _define_property(this, "_minSubscriptionRefreshInterval", void 0);
        _define_property(this, "_maxSubscriptionRefreshInterval", void 0);
        _define_property(this, "_historyStartTime", void 0);
        _define_property(this, "_terminalHashManager", void 0);
        _define_property(this, "_terminalState", void 0);
        _define_property(this, "_historyStorage", void 0);
        _define_property(this, "_healthMonitor", void 0);
        _define_property(this, "_subscriptions", void 0);
        _define_property(this, "_refreshMarketDataSubscriptionSessions", void 0);
        _define_property(this, "_refreshMarketDataSubscriptionTimeouts", void 0);
        _define_property(this, "_openedInstances", void 0);
        refreshSubscriptionsOpts = refreshSubscriptionsOpts || {};
        const validator = new OptionsValidator();
        this._minSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.minDelayInSeconds, 1, 'refreshSubscriptionsOpts.minDelayInSeconds');
        this._maxSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.maxDelayInSeconds, 600, 'refreshSubscriptionsOpts.maxDelayInSeconds');
        this._connectionRegistry = connectionRegistry;
        this._historyStartTime = historyStartTime;
        this._terminalHashManager = terminalHashManager;
        this._terminalState = new TerminalState(account, terminalHashManager, this._websocketClient);
        this._historyStorage = historyStorage || new MemoryHistoryStorage();
        this._healthMonitor = new ConnectionHealthMonitor(this);
        this._websocketClient.addSynchronizationListener(account.id, this);
        this._websocketClient.addSynchronizationListener(account.id, this._terminalState);
        this._websocketClient.addSynchronizationListener(account.id, this._historyStorage);
        this._websocketClient.addSynchronizationListener(account.id, this._healthMonitor);
        Object.values(account.accountRegions).forEach((replicaId)=>this._websocketClient.addReconnectListener(this, replicaId));
        this._subscriptions = {};
        this._stateByInstanceIndex = {};
        this._refreshMarketDataSubscriptionSessions = {};
        this._refreshMarketDataSubscriptionTimeouts = {};
        this._openedInstances = [];
        this._logger = LoggerManager.getLogger('MetaApiConnection');
    }
};
/**
 * Exposes MetaApi MetaTrader streaming API connection to consumers
 */ export { StreamingMetaApiConnection as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUZXJtaW5hbFN0YXRlIGZyb20gJy4vdGVybWluYWxTdGF0ZSc7XG5pbXBvcnQgTWVtb3J5SGlzdG9yeVN0b3JhZ2UgZnJvbSAnLi9tZW1vcnlIaXN0b3J5U3RvcmFnZSc7XG5pbXBvcnQgVGltZW91dEVycm9yIGZyb20gJy4uL2NsaWVudHMvdGltZW91dEVycm9yJztcbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBDb25uZWN0aW9uSGVhbHRoTW9uaXRvciBmcm9tICcuL2Nvbm5lY3Rpb25IZWFsdGhNb25pdG9yJztcbmltcG9ydCB7VmFsaWRhdGlvbkVycm9yfSBmcm9tICcuLi9jbGllbnRzL2Vycm9ySGFuZGxlcic7XG5pbXBvcnQgT3B0aW9uc1ZhbGlkYXRvciBmcm9tICcuLi9jbGllbnRzL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IExvZ2dlck1hbmFnZXIgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCBNZXRhQXBpQ29ubmVjdGlvbiBmcm9tICcuL21ldGFBcGlDb25uZWN0aW9uJztcblxuLyoqXG4gKiBFeHBvc2VzIE1ldGFBcGkgTWV0YVRyYWRlciBzdHJlYW1pbmcgQVBJIGNvbm5lY3Rpb24gdG8gY29uc3VtZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbWluZ01ldGFBcGlDb25uZWN0aW9uIGV4dGVuZHMgTWV0YUFwaUNvbm5lY3Rpb24ge1xuICBcbiAgcHJpdmF0ZSBfbWluU3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsOiBhbnk7XG4gIHByaXZhdGUgX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbDogYW55O1xuICBwcml2YXRlIF9oaXN0b3J5U3RhcnRUaW1lOiBhbnk7XG4gIHByaXZhdGUgX3Rlcm1pbmFsSGFzaE1hbmFnZXI6IGFueTtcbiAgcHJpdmF0ZSBfdGVybWluYWxTdGF0ZTogVGVybWluYWxTdGF0ZTtcbiAgcHJpdmF0ZSBfaGlzdG9yeVN0b3JhZ2U6IGFueTtcbiAgcHJpdmF0ZSBfaGVhbHRoTW9uaXRvcjogQ29ubmVjdGlvbkhlYWx0aE1vbml0b3I7XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbnM6IHt9O1xuICBwcml2YXRlIF9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zOiB7fTtcbiAgcHJpdmF0ZSBfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0czoge307XG4gIHByaXZhdGUgX29wZW5lZEluc3RhbmNlczogYW55W107XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgTWV0YUFwaSBNZXRhVHJhZGVyIHN0cmVhbWluZyBBcGkgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge01ldGFBcGlPcHRzfSBvcHRpb25zIG1ldGFhcGkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IHdlYnNvY2tldENsaWVudCBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnRcbiAgICogQHBhcmFtIHtUZXJtaW5hbEhhc2hNYW5hZ2VyfSB0ZXJtaW5hbEhhc2hNYW5hZ2VyIHRlcm1pbmFsIGhhc2ggbWFuYWdlclxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50fSBhY2NvdW50IE1ldGFUcmFkZXIgYWNjb3VudCBpZCB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSB7SGlzdG9yeVN0b3JhZ2V9IGhpc3RvcnlTdG9yYWdlIHRlcm1pbmFsIGhpc3Rvcnkgc3RvcmFnZS4gQnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBvZiBNZW1vcnlIaXN0b3J5U3RvcmFnZVxuICAgKiB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblJlZ2lzdHJ5fSBjb25uZWN0aW9uUmVnaXN0cnkgbWV0YXRyYWRlciBhY2NvdW50IGNvbm5lY3Rpb24gcmVnaXN0cnlcbiAgICogQHBhcmFtIHtEYXRlfSBbaGlzdG9yeVN0YXJ0VGltZV0gaGlzdG9yeSBzdGFydCBzeW5jIHRpbWVcbiAgICogQHBhcmFtIHtSZWZyZXNoU3Vic2NyaXB0aW9uc09wdHN9IFtyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHNdIHN1YnNjcmlwdGlvbnMgcmVmcmVzaCBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCB3ZWJzb2NrZXRDbGllbnQsIHRlcm1pbmFsSGFzaE1hbmFnZXIsIGFjY291bnQsIGhpc3RvcnlTdG9yYWdlLCBjb25uZWN0aW9uUmVnaXN0cnksXG4gICAgaGlzdG9yeVN0YXJ0VGltZSwgcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgd2Vic29ja2V0Q2xpZW50LCBhY2NvdW50KTtcbiAgICByZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMgPSByZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMgfHwge307XG4gICAgY29uc3QgdmFsaWRhdG9yID0gbmV3IE9wdGlvbnNWYWxpZGF0b3IoKTtcbiAgICB0aGlzLl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cy5taW5EZWxheUluU2Vjb25kcywgMSxcbiAgICAgICdyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWluRGVsYXlJblNlY29uZHMnKTtcbiAgICB0aGlzLl9tYXhTdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cy5tYXhEZWxheUluU2Vjb25kcywgNjAwLFxuICAgICAgJ3JlZnJlc2hTdWJzY3JpcHRpb25zT3B0cy5tYXhEZWxheUluU2Vjb25kcycpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeSA9IGNvbm5lY3Rpb25SZWdpc3RyeTtcbiAgICB0aGlzLl9oaXN0b3J5U3RhcnRUaW1lID0gaGlzdG9yeVN0YXJ0VGltZTtcbiAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyID0gdGVybWluYWxIYXNoTWFuYWdlcjtcbiAgICB0aGlzLl90ZXJtaW5hbFN0YXRlID0gbmV3IFRlcm1pbmFsU3RhdGUoYWNjb3VudCwgdGVybWluYWxIYXNoTWFuYWdlciwgdGhpcy5fd2Vic29ja2V0Q2xpZW50KTtcbiAgICB0aGlzLl9oaXN0b3J5U3RvcmFnZSA9IGhpc3RvcnlTdG9yYWdlIHx8IG5ldyBNZW1vcnlIaXN0b3J5U3RvcmFnZSgpO1xuICAgIHRoaXMuX2hlYWx0aE1vbml0b3IgPSBuZXcgQ29ubmVjdGlvbkhlYWx0aE1vbml0b3IodGhpcyk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzLl90ZXJtaW5hbFN0YXRlKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcy5faGlzdG9yeVN0b3JhZ2UpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzLl9oZWFsdGhNb25pdG9yKTtcbiAgICBPYmplY3QudmFsdWVzKGFjY291bnQuYWNjb3VudFJlZ2lvbnMpXG4gICAgICAuZm9yRWFjaChyZXBsaWNhSWQgPT4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFJlY29ubmVjdExpc3RlbmVyKHRoaXMsIHJlcGxpY2FJZCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzID0ge307XG4gICAgdGhpcy5fb3BlbmVkSW5zdGFuY2VzID0gW107XG4gICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyTWFuYWdlci5nZXRMb2dnZXIoJ01ldGFBcGlDb25uZWN0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGNvbm5lY3Rpb24uIENhbiBvbmx5IGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSwgbmV4dCBjYWxscyB3aWxsIGJlIGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoaW5zdGFuY2VJZCkge1xuICAgIGlmICghdGhpcy5fb3BlbmVkSW5zdGFuY2VzLmluY2x1ZGVzKGluc3RhbmNlSWQpKSB7XG4gICAgICB0aGlzLl9vcGVuZWRJbnN0YW5jZXMucHVzaChpbnN0YW5jZUlkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfTogT3BlbmluZyBjb25uZWN0aW9uYCk7XG4gICAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5faGVhbHRoTW9uaXRvci5zdGFydCgpO1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBvcmRlciBhbmQgdHJhbnNhY3Rpb24gaGlzdG9yeSBvZiBhIHNwZWNpZmllZCBhcHBsaWNhdGlvbiBhbmQgcmVtb3ZlcyBhcHBsaWNhdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGNsZWFyZWQgYW5kIGFwcGxpY2F0aW9uIGlzIHJlbW92ZWRcbiAgICovXG4gIHJlbW92ZUFwcGxpY2F0aW9uKCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgdGhpcy5faGlzdG9yeVN0b3JhZ2UuY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFwcGxpY2F0aW9uKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSB0ZXJtaW5hbCB0byBzdGFydCBzeW5jaHJvbml6YXRpb24gcHJvY2Vzc1xuICAgKiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvc3luY2hyb25pemluZy9zeW5jaHJvbml6ZS8pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluc3RhbmNlIGluZGV4XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIGFzeW5jIHN5bmNocm9uaXplKGluc3RhbmNlSW5kZXgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBob3N0ID0gdGhpcy5nZXRIb3N0TmFtZShpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lID0gbmV3IERhdGUoTWF0aC5tYXgoXG4gICAgICAodGhpcy5faGlzdG9yeVN0YXJ0VGltZSB8fCBuZXcgRGF0ZSgwKSkuZ2V0VGltZSgpLFxuICAgICAgKGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmxhc3RIaXN0b3J5T3JkZXJUaW1lKGluc3RhbmNlKSkuZ2V0VGltZSgpXG4gICAgKSk7XG4gICAgbGV0IHN0YXJ0aW5nRGVhbFRpbWUgPSBuZXcgRGF0ZShNYXRoLm1heChcbiAgICAgICh0aGlzLl9oaXN0b3J5U3RhcnRUaW1lIHx8IG5ldyBEYXRlKDApKS5nZXRUaW1lKCksXG4gICAgICAoYXdhaXQgdGhpcy5faGlzdG9yeVN0b3JhZ2UubGFzdERlYWxUaW1lKGluc3RhbmNlKSkuZ2V0VGltZSgpXG4gICAgKSk7XG4gICAgbGV0IHN5bmNocm9uaXphdGlvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KS5sYXN0U3luY2hyb25pemF0aW9uSWQgPSBzeW5jaHJvbml6YXRpb25JZDtcbiAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zW3JlZ2lvbl07XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IGluaXRpYXRpbmcgc3luY2hyb25pemF0aW9uICR7c3luY2hyb25pemF0aW9uSWR9YCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5zeW5jaHJvbml6ZShhY2NvdW50SWQsIGluc3RhbmNlLCBob3N0LCBzeW5jaHJvbml6YXRpb25JZCxcbiAgICAgIHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSwgc3RhcnRpbmdEZWFsVGltZSwgdGhpcy50ZXJtaW5hbFN0YXRlLmdldEhhc2hlcygpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIG1ldGEgYXBpIGNvbm5lY3Rpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIG1ldGEgYXBpIGNvbm5lY3Rpb24gaXMgaW5pdGlhbGl6ZWRcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICBhd2FpdCB0aGlzLl9oaXN0b3J5U3RvcmFnZS5pbml0aWFsaXplKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5hcHBsaWNhdGlvbik7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZEFjY291bnRDYWNoZSh0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgc3Vic2NyaXB0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzdWJzY3JpcHRpb24gaXMgaW5pdGlhdGVkXG4gICAqL1xuICBhc3luYyBzdWJzY3JpYmUoKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICBjb25zdCBhY2NvdW50UmVnaW9ucyA9IHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnM7XG4gICAgT2JqZWN0LmVudHJpZXMoYWNjb3VudFJlZ2lvbnMpLmZvckVhY2goKFtyZWdpb24sIHJlcGxpY2FJZF0pID0+IHtcbiAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5yZWdpb24gfHwgdGhpcy5fb3B0aW9ucy5yZWdpb24gPT09IHJlZ2lvbikge1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKHJlcGxpY2FJZCwgMCk7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5lbnN1cmVTdWJzY3JpYmUocmVwbGljYUlkLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIG9uIG1hcmtldCBkYXRhIG9mIHNwZWNpZmllZCBzeW1ib2wgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L21hcmtldERhdGFTdHJlYW1pbmcvc3Vic2NyaWJlVG9NYXJrZXREYXRhLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IHN1YnNjcmlwdGlvbnMgYXJyYXkgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uIHRvIGNyZWF0ZSBvciB1cGRhdGUuIFBsZWFzZVxuICAgKiBub3RlIHRoYXQgdGhpcyBmZWF0dXJlIGlzIG5vdCBmdWxseSBpbXBsZW1lbnRlZCBvbiBzZXJ2ZXItc2lkZSB5ZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSB0aW1lb3V0IHRvIHdhaXQgZm9yIHByaWNlcyBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDMwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dhaXRGb3JRdW90ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgbWV0aG9kIHdpbGwgcmVzb2x2ZSB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBmaXJzdCBxdW90ZSB0b1xuICAgKiBhcnJpdmUuIERlZmF1bHQgaXMgdG8gd2FpdCBmb3IgcXVvdGUgaWYgcXVvdGVzIHN1YnNjcmlwdGlvbiBpcyByZXF1ZXN0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3Vic2NyaXB0aW9uIHJlcXVlc3Qgd2FzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgc3Vic2NyaWJlVG9NYXJrZXREYXRhKHN5bWJvbCwgc3Vic2NyaXB0aW9ucywgdGltZW91dEluU2Vjb25kcz8sIHdhaXRGb3JRdW90ZSA9IHRydWUpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGlmICghdGhpcy5fdGVybWluYWxTdGF0ZS5zcGVjaWZpY2F0aW9uKHN5bWJvbCkpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYCR7dGhpcy5fYWNjb3VudC5pZH06IENhbm5vdCBzdWJzY3JpYmUgdG8gbWFya2V0IGRhdGEgZm9yIHN5bWJvbCAke3N5bWJvbH0gYmVjYXVzZSBgICtcbiAgICAgICAgJ3N5bWJvbCBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucyB8fCBbe3R5cGU6ICdxdW90ZXMnfV07XG4gICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICAgIGNvbnN0IHByZXZTdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaXB0aW9uLnR5cGUgPT09ICdjYW5kbGVzJyA/IFxuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS50eXBlID09PSBzdWJzY3JpcHRpb24udHlwZSAmJiBcbiAgICAgICAgICAgICAgaXRlbS50aW1lZnJhbWUgPT09IHN1YnNjcmlwdGlvbi50aW1lZnJhbWUpIDpcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUpO1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnNbaW5kZXhdID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0gPSB7c3Vic2NyaXB0aW9uc307XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHRoaXMuX2FjY291bnQuaWQsIHN5bWJvbCwgc3Vic2NyaXB0aW9ucyxcbiAgICAgICAgdGhpcy5fYWNjb3VudC5yZWxpYWJpbGl0eSk7XG4gICAgICBpZiAod2FpdEZvclF1b3RlICE9PSBmYWxzZSAmJiBzdWJzY3JpcHRpb25zLmZpbmQocyA9PiBzLnR5cGUgPT09ICdxdW90ZXMnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbFN0YXRlLndhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhVW5zdWJzY3JpcHRpb24+fSB1bnN1YnNjcmlwdGlvbnMgYXJyYXkgb2Ygc3Vic2NyaXB0aW9ucyB0byBjYW5jZWxcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1bnN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIHVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCB1bnN1YnNjcmlwdGlvbnMpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGlmICghdW5zdWJzY3JpcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0uc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zLmZpbHRlcihzdWJzY3JpcHRpb24gPT4ge1xuICAgICAgICByZXR1cm4gIXVuc3Vic2NyaXB0aW9ucy5maW5kKHVuc3Vic2NyaXB0aW9uID0+IHN1YnNjcmlwdGlvbi50eXBlID09PSB1bnN1YnNjcmlwdGlvbi50eXBlICYmXG4gICAgICAgICAgKCF1bnN1YnNjcmlwdGlvbi50aW1lZnJhbWUgfHwgc3Vic2NyaXB0aW9uLnRpbWVmcmFtZSA9PT0gdW5zdWJzY3JpcHRpb24udGltZWZyYW1lKSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wsIHVuc3Vic2NyaXB0aW9ucyxcbiAgICAgIHRoaXMuX2FjY291bnQucmVsaWFiaWxpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBzdWJzY3JpcHRpb24gZG93bmdyYWRlIGhhcyBvY2N1cnJlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB1cGRhdGUgc3Vic2NyaXB0aW9ucyBmb3JcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhU3Vic2NyaXB0aW9uPn0gdXBkYXRlcyBhcnJheSBvZiBtYXJrZXQgZGF0YSBzdWJzY3JpcHRpb24gdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVVuc3Vic2NyaXB0aW9uPn0gdW5zdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgb25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkKGluc3RhbmNlSW5kZXgsIHN5bWJvbCwgdXBkYXRlcywgdW5zdWJzY3JpcHRpb25zKSB7XG4gICAgaWYgKHVuc3Vic2NyaXB0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCB1bnN1YnNjcmlwdGlvbnMpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGxldCBtZXRob2QgPSBlcnIubmFtZSAhPT0gJ1ZhbGlkYXRpb25FcnJvcicgPyAnZXJyb3InIDogJ3RyYWNlJztcbiAgICAgICAgdGhpcy5fbG9nZ2VyW21ldGhvZF0oYCR7dGhpcy5fYWNjb3VudC5pZH06IGZhaWxlZCBkbyB1bnN1YnNjcmliZSBmcm9tIG1hcmtldCBkYXRhIG9uIHN1YnNjcmlwdGlvbiBkb3duZ3JhZGVkYCxcbiAgICAgICAgICBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVzPy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHN5bWJvbCwgdXBkYXRlcykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke3RoaXMuX2FjY291bnQuaWR9OiBmYWlsZWQgZG8gc3Vic2NyaWJlIGZyb20gbWFya2V0IGRhdGEgb24gc3Vic2NyaXB0aW9uIGRvd25ncmFkZWRgLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiB0aGUgc3ltYm9scyBjb25uZWN0aW9uIGlzIHN1YnNjcmliZWQgdG9cbiAgICogQHJldHVybnMge0FycmF5PFN0cmluZz59IGxpc3Qgb2YgdGhlIHN5bWJvbHMgY29ubmVjdGlvbiBpcyBzdWJzY3JpYmVkIHRvXG4gICAqL1xuICBnZXQgc3Vic2NyaWJlZFN5bWJvbHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3Vic2NyaXB0aW9ucyBmb3IgYSBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgc3Vic2NyaXB0aW9ucyBmb3JcbiAgICogQHJldHVybnMge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBsaXN0IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgZm9yIHRoZSBzeW1ib2xcbiAgICovXG4gIHN1YnNjcmlwdGlvbnMoc3ltYm9sKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICByZXR1cm4gKHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXSB8fCB7fSkuc3Vic2NyaXB0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGxvY2FsIGNvcHkgb2YgdGVybWluYWwgc3RhdGVcbiAgICogQHJldHVybnMge1Rlcm1pbmFsU3RhdGV9IGxvY2FsIGNvcHkgb2YgdGVybWluYWwgc3RhdGVcbiAgICovXG4gIGdldCB0ZXJtaW5hbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXJtaW5hbFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbG9jYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqIEByZXR1cm5zIHtIaXN0b3J5U3RvcmFnZX0gbG9jYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqL1xuICBnZXQgaGlzdG9yeVN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcnlTdG9yYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgZXN0YWJsaXNoZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcGxpY2FzIG51bWJlciBvZiBhY2NvdW50IHJlcGxpY2FzIGxhdW5jaGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25Db25uZWN0ZWQoaW5zdGFuY2VJbmRleCwgcmVwbGljYXMpIHtcbiAgICBsZXQga2V5ID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldFJlZ2lvbihpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLmNhbmNlbFJlZnJlc2gocmVnaW9uKTtcbiAgICBhd2FpdCB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlZnJlc2hJZ25vcmVkRmllbGRMaXN0cyhyZWdpb24pO1xuICAgIHN0YXRlLnNob3VsZFN5bmNocm9uaXplID0ga2V5O1xuICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSAxO1xuICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBrZXkpO1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBjb25uZWN0ZWQgdG8gYnJva2VyYCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCB0ZXJtaW5hdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqL1xuICBhc3luYyBvbkRpc2Nvbm5lY3RlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUubGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkID0gc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkO1xuICAgIHN0YXRlLmxhc3RTeW5jaHJvbml6YXRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5zeW5jaHJvbml6ZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgIGNvbnN0IGluc3RhbmNlTnVtYmVyID0gdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldFJlZ2lvbihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn1gO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZV0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXTtcbiAgICBjbGVhclRpbWVvdXQoc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCk7XG4gICAgZGVsZXRlIHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQ7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCk7XG4gICAgZGVsZXRlIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dDtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZGlzY29ubmVjdGVkIGZyb20gYnJva2VyYCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3ltYm9sIHNwZWNpZmljYXRpb25zIHdlcmUgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gc3BlY2lmaWNhdGlvbnMgdXBkYXRlZCBzcGVjaWZpY2F0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHJlbW92ZWRTeW1ib2xzIHJlbW92ZWQgc3ltYm9sc1xuICAgKi9cbiAgYXN5bmMgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzKSB7XG4gICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwb3NpdGlvbiBzeW5jaHJvbml6YXRpb24gZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW4gaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqL1xuICBhc3luYyBvblBvc2l0aW9uc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcGVuZGluZyBvcmRlciBzeW5jaHJvbml6YXRpb24gZm5pc2hlZCB0byBpbmRpY2F0ZSBwcm9ncmVzcyBvZiBhbiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlXG4gICAqIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICovXG4gIGFzeW5jIG9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzeW5jaHJvbml6YXRpb24gb2YgaGlzdG9yeSBkZWFscyBvbiBhIE1ldGFUcmFkZXIgYWNjb3VudCBoYXZlIGZpbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuXG4gICAqIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uRGVhbHNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5kZWFsc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF0gPSB0cnVlO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZmluaXNoZWQgc3luY2hyb25pemF0aW9uICR7c3luY2hyb25pemF0aW9uSWR9YCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3luY2hyb25pemF0aW9uIG9mIGhpc3Rvcnkgb3JkZXJzIG9uIGEgTWV0YVRyYWRlciBhY2NvdW50IGhhdmUgZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW5cbiAgICogaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUub3JkZXJzU3luY2hyb25pemVkW3N5bmNocm9uaXphdGlvbklkXSA9IHRydWU7XG4gICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFBcGkgd2Vic29ja2V0IEFQSSByZXN0b3JlZCBhZnRlciBhIGRpc2Nvbm5lY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiByZWNvbm5lY3RlZCByZWdpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIHJlY29ubmVjdGVkIGluc3RhbmNlIG51bWJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0XG4gICAqL1xuICBhc3luYyBvblJlY29ubmVjdGVkKHJlZ2lvbiwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICBjb25zdCBpbnN0YW5jZVRlbXBsYXRlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpXG4gICAgICAuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChgJHtpbnN0YW5jZVRlbXBsYXRlfTpgKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhba2V5XTtcbiAgICAgIH0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlVGVtcGxhdGVdO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlVGVtcGxhdGVdKTtcbiAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZVRlbXBsYXRlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzdHJlYW0gZm9yIGFuIGluc3RhbmNlIGluZGV4IGlzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIE1ldGFUcmFkZXIgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIGlzIHN0YXJ0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNwZWNpZmljYXRpb25zSGFzaCBzcGVjaWZpY2F0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbnNIYXNoIHBvc2l0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcnNIYXNoIG9yZGVycyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnNIYXNoLCBwb3NpdGlvbnNIYXNoLCBvcmRlcnNIYXNoLCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBzdGFydGluZyBzeW5jaHJvbml6YXRpb24gJHtzeW5jaHJvbml6YXRpb25JZH1gKTtcbiAgICBjb25zdCBpbnN0YW5jZU51bWJlciA9IHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRSZWdpb24oaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9YDtcbiAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zW3JlZ2lvbl07XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdO1xuICAgIGxldCBzZXNzaW9uSWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdID0gc2Vzc2lvbklkO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBzZXNzaW9uSWQpO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkID0gc3luY2hyb25pemF0aW9uSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhY2NvdW50IHJlZ2lvbiBoYXMgYmVlbiB1bnN1YnNjcmliZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBhY2NvdW50IHJlZ2lvbiB1bnN1YnNjcmliZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblVuc3Vic2NyaWJlUmVnaW9uKHJlZ2lvbikge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMpXG4gICAgICAuZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnN0YXJ0c1dpdGgoYCR7cmVnaW9ufTpgKSlcbiAgICAgIC5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV07XG4gICAgICB9KTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleClcbiAgICAgIC5maWx0ZXIoaW5zdGFuY2UgPT4gaW5zdGFuY2Uuc3RhcnRzV2l0aChgJHtyZWdpb259OmApKVxuICAgICAgLmZvckVhY2goaW5zdGFuY2UgPT4gZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIG9wdGlvbmFsIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkLCBsYXN0IHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkIHdpbGwgYmUgdXNlZFxuICAgKiBieSBkZWZhdWx0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8Qm9vbGVhbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYSBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXJcbiAgICogdGVybWluYWxcbiAgICovXG4gIGFzeW5jIGlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXM8YW55Pih0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZUluZGV4ICE9PSB1bmRlZmluZWQgJiYgcy5pbnN0YW5jZUluZGV4ICE9PSBpbnN0YW5jZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGVja1N5bmNocm9uaXphdGlvbklkID0gc3luY2hyb25pemF0aW9uSWQgfHwgcy5sYXN0U3luY2hyb25pemF0aW9uSWQ7XG4gICAgICBsZXQgc3luY2hyb25pemVkID0gISFzLm9yZGVyc1N5bmNocm9uaXplZFtjaGVja1N5bmNocm9uaXphdGlvbklkXSAmJiBcbiAgICAgICAgISFzLmRlYWxzU3luY2hyb25pemVkW2NoZWNrU3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgcmV0dXJuIGFjYyB8fCBzeW5jaHJvbml6ZWQ7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFN5bmNocm9uaXphdGlvbk9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFthcHBsaWNhdGlvblBhdHRlcm5dIGFwcGxpY2F0aW9uIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuLCBkZWZhdWx0IGlzIC4qXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3luY2hyb25pemF0aW9uSWRdIHN5bmNocm9uaXphdGlvbiBpZCwgbGFzdCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZCB3aWxsIGJlIHVzZWQgYnlcbiAgICogZGVmYXVsdFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2luc3RhbmNlSW5kZXhdIGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgdG8gZW5zdXJlIHN5bmNocm9uaXphdGlvbiBvbiwgZGVmYXVsdCBpcyB0byB3YWl0XG4gICAqIGZvciB0aGUgZmlyc3QgaW5zdGFuY2UgdG8gc3luY2hyb25pemVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSB3YWl0IHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyA1bVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2ludGVydmFsSW5NaWxsaXNlY29uZHNdIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBzeW5jaHJvbml6YXRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtTeW5jaHJvbml6YXRpb25PcHRpb25zfSBvcHRzIHN5bmNocm9uaXphdGlvbiBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb21wbGV0ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhcHBsaWNhdGlvbiBmYWlsZWQgdG8gc3luY2hyb25pemUgd2l0aCB0aGUgdGVtaW5hbCB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBhc3luYyB3YWl0U3luY2hyb25pemVkKG9wdHMpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGxldCBpbnN0YW5jZUluZGV4ID0gb3B0cy5pbnN0YW5jZUluZGV4O1xuICAgIGxldCBzeW5jaHJvbml6YXRpb25JZCA9IG9wdHMuc3luY2hyb25pemF0aW9uSWQ7XG4gICAgbGV0IHRpbWVvdXRJblNlY29uZHMgPSBvcHRzLnRpbWVvdXRJblNlY29uZHMgfHwgMzAwO1xuICAgIGxldCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gb3B0cy5pbnRlcnZhbEluTWlsbGlzZWNvbmRzIHx8IDEwMDA7XG4gICAgbGV0IGFwcGxpY2F0aW9uUGF0dGVybiA9IG9wdHMuYXBwbGljYXRpb25QYXR0ZXJuIHx8XG4gICAgICAoKHRoaXMuX2FjY291bnQgYXMgYW55KS5hcHBsaWNhdGlvbiA9PT0gJ0NvcHlGYWN0b3J5JyA/ICdDb3B5RmFjdG9yeS4qfFJQQycgOiAnUlBDJyk7XG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHN5bmNocm9uaXplZDtcbiAgICB3aGlsZSAoIShzeW5jaHJvbml6ZWQgPSBhd2FpdCB0aGlzLmlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSkgJiZcbiAgICAgIChzdGFydFRpbWUgKyB0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIGludGVydmFsSW5NaWxsaXNlY29uZHMpKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlO1xuICAgIGlmIChpbnN0YW5jZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAobGV0IHMgb2YgT2JqZWN0LnZhbHVlczxhbnk+KHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KSkge1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5pc1N5bmNocm9uaXplZChzLmluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSkge1xuICAgICAgICAgIHN0YXRlID0gcztcbiAgICAgICAgICBpbnN0YW5jZUluZGV4ID0gcy5pbnN0YW5jZUluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gT2JqZWN0LnZhbHVlczxhbnk+KHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5maW5kKHMgPT4gcy5pbnN0YW5jZUluZGV4ID09PSBpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgaWYgKCFzeW5jaHJvbml6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBNZXRhQXBpIHRvIHN5bmNocm9uaXplIHRvIE1ldGFUcmFkZXIgYWNjb3VudCAnICtcbiAgICAgICAgdGhpcy5fYWNjb3VudC5pZCArICcsIHN5bmNocm9uaXphdGlvbiBpZCAnICsgKHN5bmNocm9uaXphdGlvbklkIHx8IChzdGF0ZSAmJiBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQpIHx8XG4gICAgICAgICAgKHN0YXRlICYmIHN0YXRlLmxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZCkpKTtcbiAgICB9XG4gICAgbGV0IHRpbWVMZWZ0SW5TZWNvbmRzID0gTWF0aC5tYXgoMCwgdGltZW91dEluU2Vjb25kcyAtIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDApO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKHN0YXRlLmluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnNbcmVnaW9uXTtcbiAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQud2FpdFN5bmNocm9uaXplZChhY2NvdW50SWQsIHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCksXG4gICAgICBhcHBsaWNhdGlvblBhdHRlcm4sIHRpbWVMZWZ0SW5TZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uIFRoZSBpbnN0YW5jZSBvZiB0aGUgY2xhc3Mgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICovXG4gIGFzeW5jIGNsb3NlKGluc3RhbmNlSWQ/KSB7XG4gICAgaWYgKHRoaXMuX29wZW5lZCkge1xuICAgICAgdGhpcy5fb3BlbmVkSW5zdGFuY2VzID0gdGhpcy5fb3BlbmVkSW5zdGFuY2VzLmZpbHRlcihpZCA9PiBpZCAhPT0gaW5zdGFuY2VJZCk7XG4gICAgICBpZiAoIXRoaXMuX29wZW5lZEluc3RhbmNlcy5sZW5ndGggJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06IENsb3NpbmcgY29ubmVjdGlvbmApO1xuICAgICAgICBPYmplY3QudmFsdWVzPGFueT4odGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLmZvckVhY2goc3RhdGUgPT4gY2xlYXJUaW1lb3V0KHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQpKTtcbiAgICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXggPSB7fTtcbiAgICAgICAgYXdhaXQgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LnJlbW92ZVN0cmVhbWluZyh0aGlzLl9hY2NvdW50KTtcbiAgICAgICAgdGhpcy5fdGVybWluYWxTdGF0ZS5jbG9zZSgpO1xuICAgICAgICBjb25zdCBhY2NvdW50UmVnaW9ucyA9IHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnM7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX3Rlcm1pbmFsU3RhdGUpO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5faGlzdG9yeVN0b3JhZ2UpO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5faGVhbHRoTW9uaXRvcik7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcih0aGlzKTtcbiAgICAgICAgdGhpcy5faGVhbHRoTW9uaXRvci5zdG9wKCk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LnZhbHVlczxhbnk+KHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMpLmZvckVhY2godGltZW91dCA9PiBjbGVhclRpbWVvdXQodGltZW91dCkpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzID0ge307XG4gICAgICAgIE9iamVjdC52YWx1ZXMoYWNjb3VudFJlZ2lvbnMpLmZvckVhY2gocmVwbGljYUlkID0+IFxuICAgICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVBY2NvdW50Q2FjaGUocmVwbGljYUlkKSk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfTogQ2xvc2VkIGNvbm5lY3Rpb25gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzeW5jaHJvbml6YXRpb24gc3RhdHVzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHN5bmNocm9uaXphdGlvbiBzdGF0dXNcbiAgICovXG4gIGdldCBzeW5jaHJvbml6ZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXM8YW55Pih0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IGFjYyB8fCBzLnN5bmNocm9uaXplZCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YUFwaSBhY2NvdW50XG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50fSBNZXRhQXBpIGFjY291bnRcbiAgICovXG4gIGdldCBhY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtDb25uZWN0aW9uSGVhbHRoTW9uaXRvcn0gY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGhlYWx0aE1vbml0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWx0aE1vbml0b3I7XG4gIH1cblxuICBhc3luYyBfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pIHtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXSA9PT0gc2Vzc2lvbikge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zTGlzdCA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucyhrZXkpO1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnNJdGVtOiBhbnkgPSB7c3ltYm9sOiBrZXl9O1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zSXRlbS5zdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QucHVzaChzdWJzY3JpcHRpb25zSXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBFcnJvciByZWZyZXNoaW5nIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgam9iIGZvciBhY2NvdW50ICR7dGhpcy5fYWNjb3VudC5pZH0gYCArXG4gICAgICBgJHtpbnN0YW5jZU51bWJlcn1gLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV0gPT09IHNlc3Npb24pIHtcbiAgICAgICAgbGV0IHJlZnJlc2hJbnRlcnZhbCA9IChNYXRoLnJhbmRvbSgpICogKHRoaXMuX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCAtIFxuICAgICAgICAgIHRoaXMuX21pblN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCkgKyB0aGlzLl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwpICogMTAwMDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZV0gPSBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pLCByZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSB7XG4gICAgbGV0IHRyYWRlOiBhbnkgPSB7fTtcbiAgICBpZiAodHlwZW9mIHN0b3BMb3NzID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcztcbiAgICB9IGVsc2UgaWYgKHN0b3BMb3NzKSB7XG4gICAgICB0cmFkZS5zdG9wTG9zcyA9IHN0b3BMb3NzLnZhbHVlO1xuICAgICAgdHJhZGUuc3RvcExvc3NVbml0cyA9IHN0b3BMb3NzLnVuaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRha2VQcm9maXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdDtcbiAgICB9IGVsc2UgaWYgKHRha2VQcm9maXQpIHtcbiAgICAgIHRyYWRlLnRha2VQcm9maXQgPSB0YWtlUHJvZml0LnZhbHVlO1xuICAgICAgdHJhZGUudGFrZVByb2ZpdFVuaXRzID0gdGFrZVByb2ZpdC51bml0cztcbiAgICB9XG4gICAgcmV0dXJuIHRyYWRlO1xuICB9XG5cbiAgYXN5bmMgX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBrZXkpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUuc2hvdWxkU3luY2hyb25pemUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3luY2hyb25pemF0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy5zeW5jaHJvbml6ZShpbnN0YW5jZUluZGV4KTtcbiAgICAgICAgaWYgKHN5bmNocm9uaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLl9sYXRlbmN5U2VydmljZS5nZXRTeW5jaHJvbml6ZWRBY2NvdW50SW5zdGFuY2VzKHRoaXMuX2FjY291bnQuaWQpLmxlbmd0aCA/ICdkZWJ1ZycgOiAnZXJyb3InO1xuICAgICAgICB0aGlzLl9sb2dnZXJbbGV2ZWxdKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgZm9yIGFjY291bnQgJyArIHRoaXMuX2FjY291bnQuaWQgK1xuICAgICAgICAgICc6JyArIGluc3RhbmNlSW5kZXggKyAnIGZhaWxlZCB0byBzeW5jaHJvbml6ZScsIGVycik7XG4gICAgICAgIGlmIChzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSA9PT0ga2V5KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCk7XG4gICAgICAgICAgc3RhdGUuZW5zdXJlU3luY2hyb25pemVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9lbnN1cmVTeW5jaHJvbml6ZWQuYmluZCh0aGlzLCBpbnN0YW5jZUluZGV4LCBrZXkpLFxuICAgICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDEwMDApO1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgPSBNYXRoLm1pbihzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzICogMiwgMzAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdKSB7XG4gICAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdID0ge1xuICAgICAgICBpbnN0YW5jZUluZGV4LFxuICAgICAgICBvcmRlcnNTeW5jaHJvbml6ZWQ6IHt9LFxuICAgICAgICBkZWFsc1N5bmNocm9uaXplZDoge30sXG4gICAgICAgIHNob3VsZFN5bmNocm9uaXplOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHM6IDEsXG4gICAgICAgIHN5bmNocm9uaXplZDogZmFsc2UsXG4gICAgICAgIGxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0U3luY2hyb25pemF0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGlzY29ubmVjdGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICBfc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQpO1xuICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fY2hlY2tTeW5jaHJvbml6YXRpb25UaW1lZE91dChpbnN0YW5jZUluZGV4KSwgMiAqIDYwICogMTAwMCk7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogc2NoZWR1bGVkIHN5bmNocm9uaXphdGlvbiB0aW1lb3V0YCk7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrU3luY2hyb25pemF0aW9uVGltZWRPdXQoaW5zdGFuY2VJbmRleCkge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBjaGVja2luZyBpZiBzeW5jaHJvbml6YXRpb24gdGltZWQgb3V0IG91dGApO1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIGlmIChzdGF0ZSAmJiAhdGhpcy5fY2xvc2VkKSB7XG4gICAgICBsZXQgc3luY2hyb25pemF0aW9uSWQgPSBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQ7XG4gICAgICBsZXQgc3luY2hyb25pemVkID0gISFzdGF0ZS5kZWFsc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF07XG4gICAgICBpZiAoIXN5bmNocm9uaXplZCAmJiBzeW5jaHJvbml6YXRpb25JZCAmJiBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSkge1xuICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiByZXN5bmNocm9uaXplZCBzaW5jZSBsYXRlc3Qgc3luY2hyb25pemF0aW9uIGAgK1xuICAgICAgICAgIGAke3N5bmNocm9uaXphdGlvbklkfSBkaWQgbm90IGZpbmlzaCBpbiB0aW1lYCk7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJUZXJtaW5hbFN0YXRlIiwiTWVtb3J5SGlzdG9yeVN0b3JhZ2UiLCJUaW1lb3V0RXJyb3IiLCJyYW5kb21zdHJpbmciLCJDb25uZWN0aW9uSGVhbHRoTW9uaXRvciIsIlZhbGlkYXRpb25FcnJvciIsIk9wdGlvbnNWYWxpZGF0b3IiLCJMb2dnZXJNYW5hZ2VyIiwiTWV0YUFwaUNvbm5lY3Rpb24iLCJTdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbiIsImNvbm5lY3QiLCJpbnN0YW5jZUlkIiwiX29wZW5lZEluc3RhbmNlcyIsImluY2x1ZGVzIiwicHVzaCIsIl9vcGVuZWQiLCJfbG9nZ2VyIiwidHJhY2UiLCJfYWNjb3VudCIsImlkIiwiX2hlYWx0aE1vbml0b3IiLCJzdGFydCIsImluaXRpYWxpemUiLCJzdWJzY3JpYmUiLCJlcnIiLCJjbG9zZSIsInJlbW92ZUFwcGxpY2F0aW9uIiwiX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlIiwiX2hpc3RvcnlTdG9yYWdlIiwiY2xlYXIiLCJfd2Vic29ja2V0Q2xpZW50Iiwic3luY2hyb25pemUiLCJpbnN0YW5jZUluZGV4IiwicmVnaW9uIiwiZ2V0UmVnaW9uIiwiaW5zdGFuY2UiLCJnZXRJbnN0YW5jZU51bWJlciIsImhvc3QiLCJnZXRIb3N0TmFtZSIsInN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSIsIkRhdGUiLCJNYXRoIiwibWF4IiwiX2hpc3RvcnlTdGFydFRpbWUiLCJnZXRUaW1lIiwibGFzdEhpc3RvcnlPcmRlclRpbWUiLCJzdGFydGluZ0RlYWxUaW1lIiwibGFzdERlYWxUaW1lIiwic3luY2hyb25pemF0aW9uSWQiLCJnZW5lcmF0ZSIsIl9nZXRTdGF0ZSIsImxhc3RTeW5jaHJvbml6YXRpb25JZCIsImFjY291bnRJZCIsImFjY291bnRSZWdpb25zIiwiZGVidWciLCJ0ZXJtaW5hbFN0YXRlIiwiZ2V0SGFzaGVzIiwiX2Nvbm5lY3Rpb25SZWdpc3RyeSIsImFwcGxpY2F0aW9uIiwiYWRkQWNjb3VudENhY2hlIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJyZXBsaWNhSWQiLCJfb3B0aW9ucyIsImVuc3VyZVN1YnNjcmliZSIsInN1YnNjcmliZVRvTWFya2V0RGF0YSIsInN5bWJvbCIsInN1YnNjcmlwdGlvbnMiLCJ0aW1lb3V0SW5TZWNvbmRzIiwid2FpdEZvclF1b3RlIiwiX3Rlcm1pbmFsU3RhdGUiLCJzcGVjaWZpY2F0aW9uIiwidHlwZSIsIl9zdWJzY3JpcHRpb25zIiwicHJldlN1YnNjcmlwdGlvbnMiLCJzdWJzY3JpcHRpb24iLCJpbmRleCIsImZpbmRJbmRleCIsIml0ZW0iLCJ0aW1lZnJhbWUiLCJyZWxpYWJpbGl0eSIsImZpbmQiLCJzIiwid2FpdEZvclByaWNlIiwidW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSIsInVuc3Vic2NyaXB0aW9ucyIsImZpbHRlciIsInVuc3Vic2NyaXB0aW9uIiwibGVuZ3RoIiwib25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkIiwidXBkYXRlcyIsImNhdGNoIiwibWV0aG9kIiwibmFtZSIsImVycm9yIiwic3Vic2NyaWJlZFN5bWJvbHMiLCJrZXlzIiwiaGlzdG9yeVN0b3JhZ2UiLCJvbkNvbm5lY3RlZCIsInJlcGxpY2FzIiwia2V5Iiwic3RhdGUiLCJjYW5jZWxSZWZyZXNoIiwiX3Rlcm1pbmFsSGFzaE1hbmFnZXIiLCJyZWZyZXNoSWdub3JlZEZpZWxkTGlzdHMiLCJzaG91bGRTeW5jaHJvbml6ZSIsInN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMiLCJzeW5jaHJvbml6ZWQiLCJfZW5zdXJlU3luY2hyb25pemVkIiwib25EaXNjb25uZWN0ZWQiLCJsYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQiLCJ1bmRlZmluZWQiLCJkaXNjb25uZWN0ZWQiLCJpbnN0YW5jZU51bWJlciIsIl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zIiwiY2xlYXJUaW1lb3V0IiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMiLCJzeW5jaHJvbml6YXRpb25UaW1lb3V0IiwiZW5zdXJlU3luY2hyb25pemVUaW1lb3V0Iiwib25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQiLCJzcGVjaWZpY2F0aW9ucyIsInJlbW92ZWRTeW1ib2xzIiwiX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dCIsIm9uUG9zaXRpb25zU3luY2hyb25pemVkIiwib25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkIiwib25EZWFsc1N5bmNocm9uaXplZCIsImRlYWxzU3luY2hyb25pemVkIiwib25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkIiwib3JkZXJzU3luY2hyb25pemVkIiwib25SZWNvbm5lY3RlZCIsImluc3RhbmNlVGVtcGxhdGUiLCJfc3RhdGVCeUluc3RhbmNlSW5kZXgiLCJzdGFydHNXaXRoIiwib25TdHJlYW1DbG9zZWQiLCJvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQiLCJzcGVjaWZpY2F0aW9uc0hhc2giLCJwb3NpdGlvbnNIYXNoIiwib3JkZXJzSGFzaCIsInNlc3Npb25JZCIsIl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMiLCJfY2xvc2VkIiwib25VbnN1YnNjcmliZVJlZ2lvbiIsImlzU3luY2hyb25pemVkIiwidmFsdWVzIiwicmVkdWNlIiwiYWNjIiwiY2hlY2tTeW5jaHJvbml6YXRpb25JZCIsIndhaXRTeW5jaHJvbml6ZWQiLCJvcHRzIiwiaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyIsImFwcGxpY2F0aW9uUGF0dGVybiIsInN0YXJ0VGltZSIsIm5vdyIsIlByb21pc2UiLCJyZXMiLCJzZXRUaW1lb3V0IiwidGltZUxlZnRJblNlY29uZHMiLCJyZW1vdmVTdHJlYW1pbmciLCJyZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsInJlbW92ZVJlY29ubmVjdExpc3RlbmVyIiwic3RvcCIsInRpbWVvdXQiLCJyZW1vdmVBY2NvdW50Q2FjaGUiLCJhY2NvdW50IiwiaGVhbHRoTW9uaXRvciIsInNlc3Npb24iLCJnZXRBY2NvdW50UmVnaW9uIiwic3Vic2NyaXB0aW9uc0xpc3QiLCJzdWJzY3JpcHRpb25zSXRlbSIsInJlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyIsInJlZnJlc2hJbnRlcnZhbCIsInJhbmRvbSIsIl9tYXhTdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwiLCJfbWluU3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsIiwiX2dlbmVyYXRlU3RvcE9wdGlvbnMiLCJzdG9wTG9zcyIsInRha2VQcm9maXQiLCJ0cmFkZSIsInZhbHVlIiwic3RvcExvc3NVbml0cyIsInVuaXRzIiwidGFrZVByb2ZpdFVuaXRzIiwic3luY2hyb25pemF0aW9uUmVzdWx0IiwibGV2ZWwiLCJfbGF0ZW5jeVNlcnZpY2UiLCJnZXRTeW5jaHJvbml6ZWRBY2NvdW50SW5zdGFuY2VzIiwiYmluZCIsIm1pbiIsIl9jaGVja1N5bmNocm9uaXphdGlvblRpbWVkT3V0Iiwid2FybiIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIndlYnNvY2tldENsaWVudCIsInRlcm1pbmFsSGFzaE1hbmFnZXIiLCJjb25uZWN0aW9uUmVnaXN0cnkiLCJoaXN0b3J5U3RhcnRUaW1lIiwicmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzIiwidmFsaWRhdG9yIiwidmFsaWRhdGVOb25aZXJvIiwibWluRGVsYXlJblNlY29uZHMiLCJtYXhEZWxheUluU2Vjb25kcyIsImFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiYWRkUmVjb25uZWN0TGlzdGVuZXIiLCJnZXRMb2dnZXIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsT0FBT0EsbUJBQW1CLGtCQUFrQjtBQUM1QyxPQUFPQywwQkFBMEIseUJBQXlCO0FBQzFELE9BQU9DLGtCQUFrQiwwQkFBMEI7QUFDbkQsT0FBT0Msa0JBQWtCLGVBQWU7QUFDeEMsT0FBT0MsNkJBQTZCLDRCQUE0QjtBQUNoRSxTQUFRQyxlQUFlLFFBQU8sMEJBQTBCO0FBQ3hELE9BQU9DLHNCQUFzQiw4QkFBOEI7QUFDM0QsT0FBT0MsbUJBQW1CLFlBQVk7QUFDdEMsT0FBT0MsdUJBQXVCLHNCQUFzQjtBQUtyQyxJ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