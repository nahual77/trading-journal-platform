'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import MetaApiClient from '../metaApi.client';
let HistoricalMarketDataClient = class HistoricalMarketDataClient extends MetaApiClient {
    /**
   * Returns historical candles for a specific symbol and timeframe from a MetaTrader account.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalCandles/
   * @param {string} accountId MetaTrader account id
   * @param {string} region account region
   * @param {string} symbol symbol to retrieve candles for (e.g. a currency pair or an index)
   * @param {string} timeframe defines the timeframe according to which the candles must be generated. Allowed values
   * for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed
   * values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {Date} [startTime] time to start loading candles from. Note that candles are loaded in backwards direction, so
   * this should be the latest time. Leave empty to request latest candles.
   * @param {number} [limit] maximum number of candles to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderCandle>>} promise resolving with historical candles downloaded
   */ getHistoricalCandles(accountId, region, symbol, timeframe, startTime, limit) {
        var _this = this;
        return _async_to_generator(function*() {
            symbol = encodeURIComponent(symbol);
            const host = yield _this._domainClient.getUrl(_this._host, region);
            const opts = {
                url: `${host}/users/current/accounts/${accountId}/historical-market-data/symbols/${symbol}/` + `timeframes/${timeframe}/candles`,
                method: 'GET',
                params: {
                    startTime,
                    limit
                },
                headers: {
                    'auth-token': _this._token
                },
                json: true
            };
            let candles = yield _this._httpClient.request(opts, 'getHistoricalCandles');
            candles = candles || [];
            candles.forEach((c)=>c.time = new Date(c.time));
            return candles;
        })();
    }
    /**
   * Returns historical ticks for a specific symbol from a MetaTrader account. This API is not supported by MT4
   * accounts.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalTicks/
   * @param {string} accountId MetaTrader account id
   * @param {string} region account region
   * @param {string} symbol symbol to retrieve ticks for (e.g. a currency pair or an index)
   * @param {Date} [startTime] time to start loading ticks from. Note that candles are loaded in forward direction, so
   * this should be the earliest time. Leave empty to request latest candles.
   * @param {number} [offset] number of ticks to skip (you can use it to avoid requesting ticks from previous request
   * twice)
   * @param {number} [limit] maximum number of ticks to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderTick>>} promise resolving with historical ticks downloaded
   */ getHistoricalTicks(accountId, region, symbol, startTime, offset, limit) {
        var _this = this;
        return _async_to_generator(function*() {
            symbol = encodeURIComponent(symbol);
            const host = yield _this._domainClient.getUrl(_this._host, region);
            const opts = {
                url: `${host}/users/current/accounts/${accountId}/historical-market-data/symbols/${symbol}/ticks`,
                method: 'GET',
                params: {
                    startTime,
                    offset,
                    limit
                },
                headers: {
                    'auth-token': _this._token
                },
                json: true
            };
            let ticks = yield _this._httpClient.request(opts, 'getHistoricalTicks');
            ticks = ticks || [];
            ticks.forEach((t)=>t.time = new Date(t.time));
            return ticks;
        })();
    }
    /**
   * Constructs historical market data API client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {DomainClient} domainClient domain client
   */ constructor(httpClient, domainClient){
        super(httpClient, domainClient);
        this._host = 'https://mt-market-data-client-api-v1';
    }
};
/**
 * metaapi.cloud historical market data API client
 */ export { HistoricalMarketDataClient as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBNZXRhQXBpQ2xpZW50IGZyb20gJy4uL21ldGFBcGkuY2xpZW50JztcblxuLyoqXG4gKiBtZXRhYXBpLmNsb3VkIGhpc3RvcmljYWwgbWFya2V0IGRhdGEgQVBJIGNsaWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCBleHRlbmRzIE1ldGFBcGlDbGllbnQge1xuICBcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgaGlzdG9yaWNhbCBtYXJrZXQgZGF0YSBBUEkgY2xpZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SHR0cENsaWVudH0gaHR0cENsaWVudCBIVFRQIGNsaWVudFxuICAgKiBAcGFyYW0ge0RvbWFpbkNsaWVudH0gZG9tYWluQ2xpZW50IGRvbWFpbiBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQsIGRvbWFpbkNsaWVudCkge1xuICAgIHN1cGVyKGh0dHBDbGllbnQsIGRvbWFpbkNsaWVudCk7XG4gICAgdGhpcy5faG9zdCA9ICdodHRwczovL210LW1hcmtldC1kYXRhLWNsaWVudC1hcGktdjEnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yaWNhbCBjYW5kbGVzIGZvciBhIHNwZWNpZmljIHN5bWJvbCBhbmQgdGltZWZyYW1lIGZyb20gYSBNZXRhVHJhZGVyIGFjY291bnQuXG4gICAqIFNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvcmVzdEFwaS9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRIaXN0b3JpY2FsQ2FuZGxlcy9cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBNZXRhVHJhZGVyIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lvbiBhY2NvdW50IHJlZ2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBjYW5kbGVzIGZvciAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lZnJhbWUgZGVmaW5lcyB0aGUgdGltZWZyYW1lIGFjY29yZGluZyB0byB3aGljaCB0aGUgY2FuZGxlcyBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXNcbiAgICogZm9yIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWRcbiAgICogdmFsdWVzIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcGFyYW0ge0RhdGV9IFtzdGFydFRpbWVdIHRpbWUgdG8gc3RhcnQgbG9hZGluZyBjYW5kbGVzIGZyb20uIE5vdGUgdGhhdCBjYW5kbGVzIGFyZSBsb2FkZWQgaW4gYmFja3dhcmRzIGRpcmVjdGlvbiwgc29cbiAgICogdGhpcyBzaG91bGQgYmUgdGhlIGxhdGVzdCB0aW1lLiBMZWF2ZSBlbXB0eSB0byByZXF1ZXN0IGxhdGVzdCBjYW5kbGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBtYXhpbXVtIG51bWJlciBvZiBjYW5kbGVzIHRvIHJldHJpZXZlLiBNdXN0IGJlIGxlc3Mgb3IgZXF1YWwgdG8gMTAwMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJDYW5kbGU+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBoaXN0b3JpY2FsIGNhbmRsZXMgZG93bmxvYWRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0SGlzdG9yaWNhbENhbmRsZXMoYWNjb3VudElkLCByZWdpb24sIHN5bWJvbCwgdGltZWZyYW1lLCBzdGFydFRpbWUsIGxpbWl0KSB7XG4gICAgc3ltYm9sID0gZW5jb2RlVVJJQ29tcG9uZW50KHN5bWJvbCk7XG4gICAgY29uc3QgaG9zdCA9IGF3YWl0IHRoaXMuX2RvbWFpbkNsaWVudC5nZXRVcmwodGhpcy5faG9zdCwgcmVnaW9uKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdXJsOiBgJHtob3N0fS91c2Vycy9jdXJyZW50L2FjY291bnRzLyR7YWNjb3VudElkfS9oaXN0b3JpY2FsLW1hcmtldC1kYXRhL3N5bWJvbHMvJHtzeW1ib2x9L2AgK1xuICAgICAgICBgdGltZWZyYW1lcy8ke3RpbWVmcmFtZX0vY2FuZGxlc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgbGltaXRcbiAgICAgIH0sXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdGhpcy5fdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgY2FuZGxlcyA9IGF3YWl0IHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdChvcHRzLCAnZ2V0SGlzdG9yaWNhbENhbmRsZXMnKTtcbiAgICBjYW5kbGVzID0gY2FuZGxlcyB8fCBbXTtcbiAgICBjYW5kbGVzLmZvckVhY2goYyA9PiBjLnRpbWUgPSBuZXcgRGF0ZShjLnRpbWUpKTtcbiAgICByZXR1cm4gY2FuZGxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcmljYWwgdGlja3MgZm9yIGEgc3BlY2lmaWMgc3ltYm9sIGZyb20gYSBNZXRhVHJhZGVyIGFjY291bnQuIFRoaXMgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgTVQ0XG4gICAqIGFjY291bnRzLlxuICAgKiBTZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3Jlc3RBcGkvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkSGlzdG9yaWNhbFRpY2tzL1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIE1ldGFUcmFkZXIgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaW9uIGFjY291bnQgcmVnaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2tzIGZvciAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0VGltZV0gdGltZSB0byBzdGFydCBsb2FkaW5nIHRpY2tzIGZyb20uIE5vdGUgdGhhdCBjYW5kbGVzIGFyZSBsb2FkZWQgaW4gZm9yd2FyZCBkaXJlY3Rpb24sIHNvXG4gICAqIHRoaXMgc2hvdWxkIGJlIHRoZSBlYXJsaWVzdCB0aW1lLiBMZWF2ZSBlbXB0eSB0byByZXF1ZXN0IGxhdGVzdCBjYW5kbGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldF0gbnVtYmVyIG9mIHRpY2tzIHRvIHNraXAgKHlvdSBjYW4gdXNlIGl0IHRvIGF2b2lkIHJlcXVlc3RpbmcgdGlja3MgZnJvbSBwcmV2aW91cyByZXF1ZXN0XG4gICAqIHR3aWNlKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byByZXRyaWV2ZS4gTXVzdCBiZSBsZXNzIG9yIGVxdWFsIHRvIDEwMDBcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyVGljaz4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGhpc3RvcmljYWwgdGlja3MgZG93bmxvYWRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0SGlzdG9yaWNhbFRpY2tzKGFjY291bnRJZCwgcmVnaW9uLCBzeW1ib2wsIHN0YXJ0VGltZSwgb2Zmc2V0LCBsaW1pdCkge1xuICAgIHN5bWJvbCA9IGVuY29kZVVSSUNvbXBvbmVudChzeW1ib2wpO1xuICAgIGNvbnN0IGhvc3QgPSBhd2FpdCB0aGlzLl9kb21haW5DbGllbnQuZ2V0VXJsKHRoaXMuX2hvc3QsIHJlZ2lvbik7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHVybDogYCR7aG9zdH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy8ke2FjY291bnRJZH0vaGlzdG9yaWNhbC1tYXJrZXQtZGF0YS9zeW1ib2xzLyR7c3ltYm9sfS90aWNrc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsaW1pdFxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuICAgIGxldCB0aWNrcyA9IGF3YWl0IHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdChvcHRzLCAnZ2V0SGlzdG9yaWNhbFRpY2tzJyk7XG4gICAgdGlja3MgPSB0aWNrcyB8fCBbXTtcbiAgICB0aWNrcy5mb3JFYWNoKHQgPT4gdC50aW1lID0gbmV3IERhdGUodC50aW1lKSk7XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJNZXRhQXBpQ2xpZW50IiwiSGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQiLCJnZXRIaXN0b3JpY2FsQ2FuZGxlcyIsImFjY291bnRJZCIsInJlZ2lvbiIsInN5bWJvbCIsInRpbWVmcmFtZSIsInN0YXJ0VGltZSIsImxpbWl0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaG9zdCIsIl9kb21haW5DbGllbnQiLCJnZXRVcmwiLCJfaG9zdCIsIm9wdHMiLCJ1cmwiLCJtZXRob2QiLCJwYXJhbXMiLCJoZWFkZXJzIiwiX3Rva2VuIiwianNvbiIsImNhbmRsZXMiLCJfaHR0cENsaWVudCIsInJlcXVlc3QiLCJmb3JFYWNoIiwiYyIsInRpbWUiLCJEYXRlIiwiZ2V0SGlzdG9yaWNhbFRpY2tzIiwib2Zmc2V0IiwidGlja3MiLCJ0IiwiY29uc3RydWN0b3IiLCJodHRwQ2xpZW50IiwiZG9tYWluQ2xpZW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsT0FBT0EsbUJBQW1CLG9CQUFvQjtBQUsvQixJQUFBLEFBQU1DLDZCQUFOLE1BQU1BLG1DQUFtQ0Q7SUFZdEQ7Ozs7Ozs7Ozs7Ozs7R0FhQyxHQUNELEFBQU1FLHFCQUFxQkMsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLEtBQUs7O2VBQWpGLG9CQUFBO1lBQ0VILFNBQVNJLG1CQUFtQko7WUFDNUIsTUFBTUssT0FBTyxNQUFNLE1BQUtDLGFBQWEsQ0FBQ0MsTUFBTSxDQUFDLE1BQUtDLEtBQUssRUFBRVQ7WUFDekQsTUFBTVUsT0FBTztnQkFDWEMsS0FBSyxDQUFDLEVBQUVMLEtBQUssd0JBQXdCLEVBQUVQLFVBQVUsZ0NBQWdDLEVBQUVFLE9BQU8sQ0FBQyxDQUFDLEdBQzFGLENBQUMsV0FBVyxFQUFFQyxVQUFVLFFBQVEsQ0FBQztnQkFDbkNVLFFBQVE7Z0JBQ1JDLFFBQVE7b0JBQ05WO29CQUNBQztnQkFDRjtnQkFDQVUsU0FBUztvQkFDUCxjQUFjLE1BQUtDLE1BQU07Z0JBQzNCO2dCQUNBQyxNQUFNO1lBQ1I7WUFDQSxJQUFJQyxVQUFVLE1BQU0sTUFBS0MsV0FBVyxDQUFDQyxPQUFPLENBQUNULE1BQU07WUFDbkRPLFVBQVVBLFdBQVcsRUFBRTtZQUN2QkEsUUFBUUcsT0FBTyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLEdBQUcsSUFBSUMsS0FBS0YsRUFBRUMsSUFBSTtZQUM3QyxPQUFPTDtRQUNUOztJQUVBOzs7Ozs7Ozs7Ozs7O0dBYUMsR0FDRCxBQUFNTyxtQkFBbUJ6QixTQUFTLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFRSxTQUFTLEVBQUVzQixNQUFNLEVBQUVyQixLQUFLOztlQUE1RSxvQkFBQTtZQUNFSCxTQUFTSSxtQkFBbUJKO1lBQzVCLE1BQU1LLE9BQU8sTUFBTSxNQUFLQyxhQUFhLENBQUNDLE1BQU0sQ0FBQyxNQUFLQyxLQUFLLEVBQUVUO1lBQ3pELE1BQU1VLE9BQU87Z0JBQ1hDLEtBQUssQ0FBQyxFQUFFTCxLQUFLLHdCQUF3QixFQUFFUCxVQUFVLGdDQUFnQyxFQUFFRSxPQUFPLE1BQU0sQ0FBQztnQkFDakdXLFFBQVE7Z0JBQ1JDLFFBQVE7b0JBQ05WO29CQUNBc0I7b0JBQ0FyQjtnQkFDRjtnQkFDQVUsU0FBUztvQkFDUCxjQUFjLE1BQUtDLE1BQU07Z0JBQzNCO2dCQUNBQyxNQUFNO1lBQ1I7WUFDQSxJQUFJVSxRQUFRLE1BQU0sTUFBS1IsV0FBVyxDQUFDQyxPQUFPLENBQUNULE1BQU07WUFDakRnQixRQUFRQSxTQUFTLEVBQUU7WUFDbkJBLE1BQU1OLE9BQU8sQ0FBQ08sQ0FBQUEsSUFBS0EsRUFBRUwsSUFBSSxHQUFHLElBQUlDLEtBQUtJLEVBQUVMLElBQUk7WUFDM0MsT0FBT0k7UUFDVDs7SUFoRkE7Ozs7R0FJQyxHQUNERSxZQUFZQyxVQUFVLEVBQUVDLFlBQVksQ0FBRTtRQUNwQyxLQUFLLENBQUNELFlBQVlDO1FBQ2xCLElBQUksQ0FBQ3JCLEtBQUssR0FBRztJQUNmO0FBMEVGO0FBdkZBOztDQUVDLEdBQ0QsU0FBcUJaLHdDQW9GcEIifQ==