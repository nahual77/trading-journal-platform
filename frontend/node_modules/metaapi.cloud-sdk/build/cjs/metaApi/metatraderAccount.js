"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return MetatraderAccount;
    }
});
const _timeoutError = /*#__PURE__*/ _interop_require_default(require("../clients/timeoutError"));
const _rpcMetaApiConnectionInstance = /*#__PURE__*/ _interop_require_default(require("./rpcMetaApiConnectionInstance"));
const _streamingMetaApiConnectionInstance = /*#__PURE__*/ _interop_require_default(require("./streamingMetaApiConnectionInstance"));
const _index = /*#__PURE__*/ _interop_require_default(require("./historyDatabase/index"));
const _expertAdvisor = /*#__PURE__*/ _interop_require_default(require("./expertAdvisor"));
const _errorHandler = require("../clients/errorHandler");
const _metatraderAccountReplica = /*#__PURE__*/ _interop_require_default(require("./metatraderAccountReplica"));
const _metatraderAccountclient = require("../clients/metaApi/metatraderAccount.client");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let MetatraderAccount = class MetatraderAccount {
    /**
   * Returns unique account id
   * @return {string} unique account id
   */ get id() {
        return this._data._id;
    }
    /**
   * Returns current account state. One of CREATED, DEPLOYING, DEPLOYED, DEPLOY_FAILED, UNDEPLOYING,
   * UNDEPLOYED, UNDEPLOY_FAILED, DELETING, DELETE_FAILED, REDEPLOY_FAILED, DRAFT
   * @return {State} current account state
   */ get state() {
        return this._data.state;
    }
    /**
   * Returns MetaTrader magic to place trades using
   * @return {number} MetaTrader magic to place trades using
   */ get magic() {
        return this._data.magic;
    }
    /**
   * Returns terminal & broker connection status, one of CONNECTED, DISCONNECTED, DISCONNECTED_FROM_BROKER
   * @return {ConnectionStatus} terminal & broker connection status
   */ get connectionStatus() {
        return this._data.connectionStatus;
    }
    /**
   * Returns quote streaming interval in seconds 
   * @return {number} quote streaming interval in seconds
   */ get quoteStreamingIntervalInSeconds() {
        return this._data.quoteStreamingIntervalInSeconds;
    }
    /**
   * Returns symbol provided by broker 
   * @return {string} any symbol provided by broker
   */ get symbol() {
        return this._data.symbol;
    }
    /**
   * Returns reliability value. Possible values are regular and high
   * @return {Reliability} account reliability value
   */ get reliability() {
        return this._data.reliability;
    }
    /**
   * Returns user-defined account tags
   * @return {Array<string>} user-defined account tags
   */ get tags() {
        return this._data.tags;
    }
    /**
   * Returns extra information which can be stored together with your account
   * @return {Object} extra information which can be stored together with your account
   */ get metadata() {
        return this._data.metadata;
    }
    /**
   * Returns number of resource slots to allocate to account. Allocating extra resource slots
   * results in better account performance under load which is useful for some applications. E.g. if you have many
   * accounts copying the same strategy via CopyFactory API, then you can increase resourceSlots to get a lower trade
   * copying latency. Please note that allocating extra resource slots is a paid option. Please note that high
   * reliability accounts use redundant infrastructure, so that each resource slot for a high reliability account
   * is billed as 2 standard resource slots.
   * @return {number} number of resource slots to allocate to account
   */ get resourceSlots() {
        return this._data.resourceSlots;
    }
    /**
   * Returns the number of CopyFactory 2 resource slots to allocate to account.
   * Allocating extra resource slots results in lower trade copying latency. Please note that allocating extra resource
   * slots is a paid option. Please also note that CopyFactory 2 uses redundant infrastructure so that
   * each CopyFactory resource slot is billed as 2 standard resource slots. You will be billed for CopyFactory 2
   * resource slots only if you have added your account to CopyFactory 2 by specifying copyFactoryRoles field.
   * @return {number} number of CopyFactory 2 resource slots to allocate to account
   */ get copyFactoryResourceSlots() {
        return this._data.copyFactoryResourceSlots;
    }
    /**
   * Returns account region
   * @return {string} account region value
   */ get region() {
        return this._data.region;
    }
    /**
   * Returns the time account was created at, in ISO format
   * @returns {string} the time account was created at, in ISO format
   */ get createdAt() {
        return new Date(this._data.createdAt);
    }
    /**
   * Returns human-readable account name
   * @return {string} human-readable account name
   */ get name() {
        return this._data.name;
    }
    /**
   * Returns flag indicating if trades should be placed as manual trades on this account
   * @return {boolean} flag indicating if trades should be placed as manual trades on this account
   */ get manualTrades() {
        return this._data.manualTrades;
    }
    /**
   * Returns default trade slippage in points
   * @return {number} default trade slippage in points
   */ get slippage() {
        return this._data.slippage;
    }
    /**
   * Returns id of the account's provisioning profile
   * @return {string} id of the account's provisioning profile
   */ get provisioningProfileId() {
        return this._data.provisioningProfileId;
    }
    /**
   * Returns MetaTrader account login
   * @return {string} MetaTrader account number
   */ get login() {
        return this._data.login;
    }
    /**
   * Returns MetaTrader server name to connect to
   * @return {string} MetaTrader server name to connect to
   */ get server() {
        return this._data.server;
    }
    /**
   * Returns account type. Possible values are cloud-g1, cloud-g2
   * @return {Type} account type
   */ get type() {
        return this._data.type;
    }
    /**
   * Returns MT version. Possible values are 4 and 5
   * @return {Version} MT version
   */ get version() {
        return this._data.version;
    }
    /**
   * Returns hash-code of the account
   * @return {number} hash-code of the account
   */ get hash() {
        return this._data.hash;
    }
    /**
   * Returns 3-character ISO currency code of the account base currency. The setting is to be used
   * for copy trading accounts which use national currencies only, such as some Brazilian brokers. You should not alter
   * this setting unless you understand what you are doing.
   * @return {string} 3-character ISO currency code of the account base currency
   */ get baseCurrency() {
        return this._data.baseCurrency;
    }
    /**
   * Returns account roles for CopyFactory2 application. Possible values are `PROVIDER` and `SUBSCRIBER`
   * @return {Array<CopyFactoryRoles>} account roles for CopyFactory2 application
   */ get copyFactoryRoles() {
        return this._data.copyFactoryRoles;
    }
    /**
   * Returns flag indicating that risk management API is enabled on account
   * @return {boolean} flag indicating that risk management API is enabled on account
   */ get riskManagementApiEnabled() {
        return this._data.riskManagementApiEnabled;
    }
    /**
   * Returns flag indicating that MetaStats API is enabled on account
   * @return {boolean} flag indicating that MetaStats API is enabled on account
   */ get metastatsApiEnabled() {
        return this._data.metastatsApiEnabled;
    }
    /**
   * Returns configured dedicated IP protocol to connect to the trading account terminal
   * @return {DedicatedIp}
   */ get allocateDedicatedIp() {
        return this._data.allocateDedicatedIp;
    }
    /**
   * Returns active account connections
   * @return {Array<AccountConnection>} active account connections
   */ get connections() {
        return this._data.connections;
    }
    /**
   * Returns flag indicating that account is primary
   * @return {boolean} flag indicating that account is primary
   */ get primaryReplica() {
        return this._data.primaryReplica;
    }
    /**
   * Returns user id
   * @return {string} user id
   */ get userId() {
        return this._data.userId;
    }
    /**
   * Returns primary account id
   * @return {string} primary account id
   */ get primaryAccountId() {
        return this._data.primaryAccountId;
    }
    /**
   * Returns account replicas from DTO
   * @return {MetatraderAccountReplica[]} account replicas from DTO
   */ get accountReplicas() {
        return this._data.accountReplicas;
    }
    /**
   * Returns account replica instances
   * @return {MetatraderAccountReplica[]} account replica instances
   */ get replicas() {
        return this._replicas;
    }
    /**
   * Returns a dictionary with account's available regions and replicas
   * @returns {{[region: string]: string}}
   */ get accountRegions() {
        const regions = {
            [this.region]: this.id
        };
        this.replicas.forEach((replica)=>regions[replica.region] = replica.id);
        return regions;
    }
    /**
   * Reloads MetaTrader account from API
   * @return {Promise} promise resolving when MetaTrader account is updated
   */ async reload() {
        this._data = await this._metatraderAccountClient.getAccount(this.id);
        const updatedReplicaData = this._data.accountReplicas || [];
        const regions = updatedReplicaData.map((replica)=>replica.region);
        const createdReplicaRegions = this._replicas.map((replica)=>replica.region);
        this._replicas = this._replicas.filter((replica)=>regions.includes(replica.region));
        this._replicas.forEach((replica)=>{
            const updatedData = updatedReplicaData.find((replicaData)=>replicaData.region === replica.region);
            replica.updateData(updatedData);
        });
        updatedReplicaData.forEach((replica)=>{
            if (!createdReplicaRegions.includes(replica.region)) {
                this._replicas.push(new _metatraderAccountReplica.default(replica, this, this._metatraderAccountClient));
            }
        });
    }
    /**
   * Removes a trading account and stops the API server serving the account.
   * The account state such as downloaded market data history will be removed as well when you remove the account.
   * @return {Promise} promise resolving when account is scheduled for deletion
   */ async remove() {
        this._connectionRegistry.closeAllInstances(this.id);
        await this._metatraderAccountClient.deleteAccount(this.id);
        const fileManager = _index.default.getInstance();
        await fileManager.clear(this.id, this._application);
        if (this.type !== "self-hosted") {
            try {
                await this.reload();
            } catch (err) {
                if (err.name !== "NotFoundError") {
                    throw err;
                }
            }
        }
    }
    /**
   * Starts API server and trading terminal for trading account.
   * This request will be ignored if the account is already deployed.
   * @returns {Promise} promise resolving when account is scheduled for deployment
   */ async deploy() {
        await this._metatraderAccountClient.deployAccount(this.id);
        await this.reload();
    }
    /**
   * Stops API server and trading terminal for trading account.
   * This request will be ignored if trading account is already undeployed
   * @returns {Promise} promise resolving when account is scheduled for undeployment
   */ async undeploy() {
        this._connectionRegistry.closeAllInstances(this.id);
        await this._metatraderAccountClient.undeployAccount(this.id);
        await this.reload();
    }
    /**
   * Redeploys trading account. This is equivalent to undeploy immediately followed by deploy
   * @returns {Promise} promise resolving when account is scheduled for redeployment
   */ async redeploy() {
        await this._metatraderAccountClient.redeployAccount(this.id);
        await this.reload();
    }
    /**
   * Increases trading account reliability in order to increase the expected account uptime.
   * The account will be temporary stopped to perform this action.
   * Note that increasing reliability is a paid option
   * @returns {Promise} promise resolving when account reliability is increased
   */ async increaseReliability() {
        await this._metatraderAccountClient.increaseReliability(this.id);
        await this.reload();
    }
    /**
   * Enables risk management API for trading account.
   * The account will be temporary stopped to perform this action.
   * Note that risk management API is a paid option
   * @returns {Promise} promise resolving when account risk management is enabled
   */ async enableRiskManagementApi() {
        await this._metatraderAccountClient.enableRiskManagementApi(this.id);
        await this.reload();
    }
    /**
   * Enables MetaStats API for trading account.
   * The account will be temporary stopped to perform this action.
   * Note that this is a paid option
   * @returns {Promise} promise resolving when account MetaStats API is enabled
   */ async enableMetaStatsApi() {
        await this._metatraderAccountClient.enableMetaStatsApi(this.id);
        await this.reload();
    }
    /**
   * Waits until API server has finished deployment and account reached the DEPLOYED state
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deployed
   * @throws {TimeoutError} if account have not reached the DEPLOYED state within timeout allowed
   */ async waitDeployed(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        let startTime = Date.now();
        await this.reload();
        while(this.state !== "DEPLOYED" && startTime + timeoutInSeconds * 1000 > Date.now()){
            await this._delay(intervalInMilliseconds);
            await this.reload();
        }
        if (this.state !== "DEPLOYED") {
            throw new _timeoutError.default("Timed out waiting for account " + this.id + " to be deployed");
        }
    }
    /**
   * Waits until API server has finished undeployment and account reached the UNDEPLOYED state
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deployed
   * @throws {TimeoutError} if account have not reached the UNDEPLOYED state within timeout allowed
   */ async waitUndeployed(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        let startTime = Date.now();
        await this.reload();
        while(this.state !== "UNDEPLOYED" && startTime + timeoutInSeconds * 1000 > Date.now()){
            await this._delay(intervalInMilliseconds);
            await this.reload();
        }
        if (this.state !== "UNDEPLOYED") {
            throw new _timeoutError.default("Timed out waiting for account " + this.id + " to be undeployed");
        }
    }
    /**
   * Waits until account has been deleted
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when account is deleted
   * @throws {TimeoutError} if account was not deleted within timeout allowed
   */ async waitRemoved(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        let startTime = Date.now();
        try {
            await this.reload();
            while(startTime + timeoutInSeconds * 1000 > Date.now()){
                await this._delay(intervalInMilliseconds);
                await this.reload();
            }
            throw new _timeoutError.default("Timed out waiting for account " + this.id + " to be deleted");
        } catch (err) {
            if (err.name === "NotFoundError") {
                return;
            } else {
                throw err;
            }
        }
    }
    /**
   * Waits until API server has connected to the terminal and terminal has connected to the broker
   * @param {number} timeoutInSeconds wait timeout in seconds, default is 5m
   * @param {number} intervalInMilliseconds interval between account reloads while waiting for a change, default is 1s
   * @return {Promise} promise which resolves when API server is connected to the broker
   * @throws {TimeoutError} if account have not connected to the broker within timeout allowed
   */ async waitConnected(timeoutInSeconds = 300, intervalInMilliseconds = 1000) {
        const checkConnected = ()=>{
            return [
                this.connectionStatus
            ].concat(this.replicas.map((replica)=>replica.connectionStatus)).includes("CONNECTED");
        };
        let startTime = Date.now();
        await this.reload();
        while(!checkConnected() && startTime + timeoutInSeconds * 1000 > Date.now()){
            await this._delay(intervalInMilliseconds);
            await this.reload();
        }
        if (!checkConnected()) {
            throw new _timeoutError.default("Timed out waiting for account " + this.id + " to connect to the broker");
        }
    }
    /**
   * Connects to MetaApi. There is only one connection per account. Subsequent calls to this method will return the same connection.
   * @param {HistoryStorage} historyStorage optional history storage
   * @param {Date} [historyStartTime] history start time. Used for tests
   * @return {StreamingMetaApiConnectionInstance} MetaApi connection instance
   */ getStreamingConnection(historyStorage, historyStartTime) {
        if (this._metaApiWebsocketClient.region && this._metaApiWebsocketClient.region !== this.region) {
            throw new _errorHandler.ValidationError(`Account ${this.id} is not on specified region ${this._metaApiWebsocketClient.region}`);
        }
        return this._connectionRegistry.connectStreaming(this, historyStorage, historyStartTime);
    }
    /**
   * Connects to MetaApi via RPC connection instance.
   * @returns {RpcMetaApiConnectionInstance} MetaApi connection instance
   */ getRPCConnection() {
        if (this._metaApiWebsocketClient.region && this._metaApiWebsocketClient.region !== this.region) {
            throw new _errorHandler.ValidationError(`Account ${this.id} is not on specified region ${this._metaApiWebsocketClient.region}`);
        }
        return this._connectionRegistry.connectRpc(this);
    }
    /**
   * Updates trading account. 
   * Please redeploy the trading account in order for updated settings to take effect
   * @param {MetatraderAccountUpdateDto} account updated account information
   * @return {Promise} promise resolving when account is updated
   */ async update(account) {
        await this._metatraderAccountClient.updateAccount(this.id, account);
        await this.reload();
    }
    /**
   * Creates a trading account replica in a region different from trading account region and starts a cloud API server for it
   * @param {NewMetaTraderAccountDto} account MetaTrader account data
   * @return {Promise<MetatraderAccountReplica>} promise resolving with created MetaTrader account replica entity
   */ async createReplica(account) {
        await this._metatraderAccountClient.createAccountReplica(this.id, account);
        await this.reload();
        return this._replicas.find((r)=>r.region === account.region);
    }
    /**
   * Retrieves expert advisor of current account
   * @returns {Promise<ExpertAdvisor[]>} promise resolving with an array of expert advisor entities
   */ async getExpertAdvisors() {
        this._checkExpertAdvisorAllowed();
        let expertAdvisors = await this._expertAdvisorClient.getExpertAdvisors(this.id);
        return expertAdvisors.map((e)=>new _expertAdvisor.default(e, this.id, this._expertAdvisorClient));
    }
    /**
   * Retrieves a expert advisor of current account by id
   * @param {String} expertId expert advisor id
   * @returns {Promise<ExpertAdvisor>} promise resolving with expert advisor entity
   */ async getExpertAdvisor(expertId) {
        this._checkExpertAdvisorAllowed();
        let expertAdvisor = await this._expertAdvisorClient.getExpertAdvisor(this.id, expertId);
        return new _expertAdvisor.default(expertAdvisor, this.id, this._expertAdvisorClient);
    }
    /**
   * Creates an expert advisor
   * @param {string} expertId expert advisor id
   * @param {NewExpertAdvisorDto} expert expert advisor data
   * @returns {Promise<ExpertAdvisor>} promise resolving with expert advisor entity
   */ async createExpertAdvisor(expertId, expert) {
        this._checkExpertAdvisorAllowed();
        await this._expertAdvisorClient.updateExpertAdvisor(this.id, expertId, expert);
        return this.getExpertAdvisor(expertId);
    }
    /**
   * Returns historical candles for a specific symbol and timeframe from the MetaTrader account.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalCandles/
   * @param {string} symbol symbol to retrieve candles for (e.g. a currency pair or an index)
   * @param {string} timeframe defines the timeframe according to which the candles must be generated. Allowed values
   * for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed
   * values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {Date} [startTime] time to start loading candles from. Note that candles are loaded in backwards direction, so
   * this should be the latest time. Leave empty to request latest candles.
   * @param {number} [limit] maximum number of candles to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderCandle>>} promise resolving with historical candles downloaded
   */ getHistoricalCandles(symbol, timeframe, startTime, limit) {
        return this._historicalMarketDataClient.getHistoricalCandles(this.id, this.region, symbol, timeframe, startTime, limit);
    }
    /**
   * Returns historical ticks for a specific symbol from the MetaTrader account. This API is not supported by MT4
   * accounts.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalTicks/
   * @param {string} symbol symbol to retrieve ticks for (e.g. a currency pair or an index)
   * @param {Date} [startTime] time to start loading ticks from. Note that candles are loaded in forward direction, so
   * this should be the earliest time. Leave empty to request latest candles.
   * @param {number} [offset] number of ticks to skip (you can use it to avoid requesting ticks from previous request
   * twice)
   * @param {number} [limit] maximum number of ticks to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderTick>>} promise resolving with historical ticks downloaded
   */ getHistoricalTicks(symbol, startTime, offset, limit) {
        return this._historicalMarketDataClient.getHistoricalTicks(this.id, this.region, symbol, startTime, offset, limit);
    }
    /**
   * Generates trading account configuration link by account id.
   * @param {number} [ttlInDays] Lifetime of the link in days. Default is 7.
   * @return {Promise<ConfigurationLink>} promise resolving with configuration link
   */ async createConfigurationLink(ttlInDays) {
        const configurationLink = await this._metatraderAccountClient.createConfigurationLink(this.id, ttlInDays);
        return configurationLink;
    }
    _checkExpertAdvisorAllowed() {
        if (this.version !== 4 || this.type !== "cloud-g1") {
            throw new _errorHandler.ValidationError("Custom expert advisor is available only for MT4 G1 accounts");
        }
    }
    _delay(timeoutInMilliseconds) {
        return new Promise((res)=>setTimeout(res, timeoutInMilliseconds));
    }
    /**
   * Constructs a MetaTrader account entity
   * @param {MetatraderAccountDto} data MetaTrader account data
   * @param {MetatraderAccountClient} metatraderAccountClient MetaTrader account REST API client
   * @param {MetaApiWebsocketClient} metaApiWebsocketClient MetaApi websocket client
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {ExpertAdvisorClient} expertAdvisorClient expert advisor REST API client
   * @param {HistoricalMarketDataClient} historicalMarketDataClient historical market data HTTP API client
   * @param {string} application application name
   */ constructor(data, metatraderAccountClient, metaApiWebsocketClient, connectionRegistry, expertAdvisorClient, historicalMarketDataClient, application){
        this._data = data;
        this._metatraderAccountClient = metatraderAccountClient;
        this._metaApiWebsocketClient = metaApiWebsocketClient;
        this._connectionRegistry = connectionRegistry;
        this._expertAdvisorClient = expertAdvisorClient;
        this._historicalMarketDataClient = historicalMarketDataClient;
        this._application = application;
        this._replicas = (data.accountReplicas || []).map((replica)=>new _metatraderAccountReplica.default(replica, this, metatraderAccountClient));
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vY2xpZW50cy90aW1lb3V0RXJyb3InO1xuaW1wb3J0IFJwY01ldGFBcGlDb25uZWN0aW9uSW5zdGFuY2UgZnJvbSAnLi9ycGNNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlJztcbmltcG9ydCBTdHJlYW1pbmdNZXRhQXBpQ29ubmVjdGlvbkluc3RhbmNlIGZyb20gJy4vc3RyZWFtaW5nTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZSc7XG5pbXBvcnQgSGlzdG9yeURhdGFiYXNlIGZyb20gJy4vaGlzdG9yeURhdGFiYXNlL2luZGV4JztcbmltcG9ydCBFeHBlcnRBZHZpc29yIGZyb20gJy4vZXhwZXJ0QWR2aXNvcic7XG5pbXBvcnQge1ZhbGlkYXRpb25FcnJvcn0gZnJvbSAnLi4vY2xpZW50cy9lcnJvckhhbmRsZXInO1xuaW1wb3J0IE1ldGF0cmFkZXJBY2NvdW50UmVwbGljYSBmcm9tICcuL21ldGF0cmFkZXJBY2NvdW50UmVwbGljYSc7XG4vL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5pbXBvcnQge1xuICBSZWxpYWJpbGl0eSwgU3RhdGUsIFZlcnNpb24sIENvbm5lY3Rpb25TdGF0dXMsIENvcHlGYWN0b3J5Um9sZXMsIFR5cGUsIEFjY291bnRDb25uZWN0aW9uLCBDb25maWd1cmF0aW9uTGluayxcbiAgTWV0YXRyYWRlckFjY291bnREdG8sIERlZGljYXRlZElwXG59IGZyb20gJy4uL2NsaWVudHMvbWV0YUFwaS9tZXRhdHJhZGVyQWNjb3VudC5jbGllbnQnO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSBNZXRhVHJhZGVyIGFjY291bnQgZW50aXR5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ldGF0cmFkZXJBY2NvdW50IHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIE1ldGFUcmFkZXIgYWNjb3VudCBlbnRpdHlcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudER0b30gZGF0YSBNZXRhVHJhZGVyIGFjY291bnQgZGF0YVxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50Q2xpZW50fSBtZXRhdHJhZGVyQWNjb3VudENsaWVudCBNZXRhVHJhZGVyIGFjY291bnQgUkVTVCBBUEkgY2xpZW50XG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gbWV0YUFwaVdlYnNvY2tldENsaWVudCBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnRcbiAgICogQHBhcmFtIHtDb25uZWN0aW9uUmVnaXN0cnl9IGNvbm5lY3Rpb25SZWdpc3RyeSBtZXRhdHJhZGVyIGFjY291bnQgY29ubmVjdGlvbiByZWdpc3RyeVxuICAgKiBAcGFyYW0ge0V4cGVydEFkdmlzb3JDbGllbnR9IGV4cGVydEFkdmlzb3JDbGllbnQgZXhwZXJ0IGFkdmlzb3IgUkVTVCBBUEkgY2xpZW50XG4gICAqIEBwYXJhbSB7SGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnR9IGhpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50IGhpc3RvcmljYWwgbWFya2V0IGRhdGEgSFRUUCBBUEkgY2xpZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBsaWNhdGlvbiBhcHBsaWNhdGlvbiBuYW1lXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCBtZXRhdHJhZGVyQWNjb3VudENsaWVudCwgbWV0YUFwaVdlYnNvY2tldENsaWVudCwgY29ubmVjdGlvblJlZ2lzdHJ5LCBleHBlcnRBZHZpc29yQ2xpZW50LCBcbiAgICBoaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCwgYXBwbGljYXRpb24pIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudCA9IG1ldGF0cmFkZXJBY2NvdW50Q2xpZW50O1xuICAgIHRoaXMuX21ldGFBcGlXZWJzb2NrZXRDbGllbnQgPSBtZXRhQXBpV2Vic29ja2V0Q2xpZW50O1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeSA9IGNvbm5lY3Rpb25SZWdpc3RyeTtcbiAgICB0aGlzLl9leHBlcnRBZHZpc29yQ2xpZW50ID0gZXhwZXJ0QWR2aXNvckNsaWVudDtcbiAgICB0aGlzLl9oaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCA9IGhpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50O1xuICAgIHRoaXMuX2FwcGxpY2F0aW9uID0gYXBwbGljYXRpb247XG4gICAgdGhpcy5fcmVwbGljYXMgPSAoZGF0YS5hY2NvdW50UmVwbGljYXMgfHwgW10pXG4gICAgICAubWFwKHJlcGxpY2EgPT4gbmV3IE1ldGF0cmFkZXJBY2NvdW50UmVwbGljYShyZXBsaWNhLCB0aGlzLCBtZXRhdHJhZGVyQWNjb3VudENsaWVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdW5pcXVlIGFjY291bnQgaWRcbiAgICogQHJldHVybiB7c3RyaW5nfSB1bmlxdWUgYWNjb3VudCBpZFxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLl9pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgYWNjb3VudCBzdGF0ZS4gT25lIG9mIENSRUFURUQsIERFUExPWUlORywgREVQTE9ZRUQsIERFUExPWV9GQUlMRUQsIFVOREVQTE9ZSU5HLFxuICAgKiBVTkRFUExPWUVELCBVTkRFUExPWV9GQUlMRUQsIERFTEVUSU5HLCBERUxFVEVfRkFJTEVELCBSRURFUExPWV9GQUlMRUQsIERSQUZUXG4gICAqIEByZXR1cm4ge1N0YXRlfSBjdXJyZW50IGFjY291bnQgc3RhdGVcbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFUcmFkZXIgbWFnaWMgdG8gcGxhY2UgdHJhZGVzIHVzaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWV0YVRyYWRlciBtYWdpYyB0byBwbGFjZSB0cmFkZXMgdXNpbmdcbiAgICovXG4gIGdldCBtYWdpYygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5tYWdpYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRlcm1pbmFsICYgYnJva2VyIGNvbm5lY3Rpb24gc3RhdHVzLCBvbmUgb2YgQ09OTkVDVEVELCBESVNDT05ORUNURUQsIERJU0NPTk5FQ1RFRF9GUk9NX0JST0tFUlxuICAgKiBAcmV0dXJuIHtDb25uZWN0aW9uU3RhdHVzfSB0ZXJtaW5hbCAmIGJyb2tlciBjb25uZWN0aW9uIHN0YXR1c1xuICAgKi9cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuY29ubmVjdGlvblN0YXR1cztcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgcXVvdGUgc3RyZWFtaW5nIGludGVydmFsIGluIHNlY29uZHMgXG4gICAqIEByZXR1cm4ge251bWJlcn0gcXVvdGUgc3RyZWFtaW5nIGludGVydmFsIGluIHNlY29uZHNcbiAgICovXG4gIGdldCBxdW90ZVN0cmVhbWluZ0ludGVydmFsSW5TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnF1b3RlU3RyZWFtaW5nSW50ZXJ2YWxJblNlY29uZHM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN5bWJvbCBwcm92aWRlZCBieSBicm9rZXIgXG4gICAqIEByZXR1cm4ge3N0cmluZ30gYW55IHN5bWJvbCBwcm92aWRlZCBieSBicm9rZXJcbiAgICovXG4gIGdldCBzeW1ib2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc3ltYm9sO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyByZWxpYWJpbGl0eSB2YWx1ZS4gUG9zc2libGUgdmFsdWVzIGFyZSByZWd1bGFyIGFuZCBoaWdoXG4gICAqIEByZXR1cm4ge1JlbGlhYmlsaXR5fSBhY2NvdW50IHJlbGlhYmlsaXR5IHZhbHVlXG4gICAqL1xuICBnZXQgcmVsaWFiaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVsaWFiaWxpdHk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIHVzZXItZGVmaW5lZCBhY2NvdW50IHRhZ3NcbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gdXNlci1kZWZpbmVkIGFjY291bnQgdGFnc1xuICAgKi9cbiAgZ2V0IHRhZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEudGFncztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGV4dHJhIGluZm9ybWF0aW9uIHdoaWNoIGNhbiBiZSBzdG9yZWQgdG9nZXRoZXIgd2l0aCB5b3VyIGFjY291bnRcbiAgICogQHJldHVybiB7T2JqZWN0fSBleHRyYSBpbmZvcm1hdGlvbiB3aGljaCBjYW4gYmUgc3RvcmVkIHRvZ2V0aGVyIHdpdGggeW91ciBhY2NvdW50XG4gICAqL1xuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBudW1iZXIgb2YgcmVzb3VyY2Ugc2xvdHMgdG8gYWxsb2NhdGUgdG8gYWNjb3VudC4gQWxsb2NhdGluZyBleHRyYSByZXNvdXJjZSBzbG90c1xuICAgKiByZXN1bHRzIGluIGJldHRlciBhY2NvdW50IHBlcmZvcm1hbmNlIHVuZGVyIGxvYWQgd2hpY2ggaXMgdXNlZnVsIGZvciBzb21lIGFwcGxpY2F0aW9ucy4gRS5nLiBpZiB5b3UgaGF2ZSBtYW55XG4gICAqIGFjY291bnRzIGNvcHlpbmcgdGhlIHNhbWUgc3RyYXRlZ3kgdmlhIENvcHlGYWN0b3J5IEFQSSwgdGhlbiB5b3UgY2FuIGluY3JlYXNlIHJlc291cmNlU2xvdHMgdG8gZ2V0IGEgbG93ZXIgdHJhZGVcbiAgICogY29weWluZyBsYXRlbmN5LiBQbGVhc2Ugbm90ZSB0aGF0IGFsbG9jYXRpbmcgZXh0cmEgcmVzb3VyY2Ugc2xvdHMgaXMgYSBwYWlkIG9wdGlvbi4gUGxlYXNlIG5vdGUgdGhhdCBoaWdoXG4gICAqIHJlbGlhYmlsaXR5IGFjY291bnRzIHVzZSByZWR1bmRhbnQgaW5mcmFzdHJ1Y3R1cmUsIHNvIHRoYXQgZWFjaCByZXNvdXJjZSBzbG90IGZvciBhIGhpZ2ggcmVsaWFiaWxpdHkgYWNjb3VudFxuICAgKiBpcyBiaWxsZWQgYXMgMiBzdGFuZGFyZCByZXNvdXJjZSBzbG90cy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBudW1iZXIgb2YgcmVzb3VyY2Ugc2xvdHMgdG8gYWxsb2NhdGUgdG8gYWNjb3VudFxuICAgKi9cbiAgZ2V0IHJlc291cmNlU2xvdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVzb3VyY2VTbG90cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgQ29weUZhY3RvcnkgMiByZXNvdXJjZSBzbG90cyB0byBhbGxvY2F0ZSB0byBhY2NvdW50LlxuICAgKiBBbGxvY2F0aW5nIGV4dHJhIHJlc291cmNlIHNsb3RzIHJlc3VsdHMgaW4gbG93ZXIgdHJhZGUgY29weWluZyBsYXRlbmN5LiBQbGVhc2Ugbm90ZSB0aGF0IGFsbG9jYXRpbmcgZXh0cmEgcmVzb3VyY2VcbiAgICogc2xvdHMgaXMgYSBwYWlkIG9wdGlvbi4gUGxlYXNlIGFsc28gbm90ZSB0aGF0IENvcHlGYWN0b3J5IDIgdXNlcyByZWR1bmRhbnQgaW5mcmFzdHJ1Y3R1cmUgc28gdGhhdFxuICAgKiBlYWNoIENvcHlGYWN0b3J5IHJlc291cmNlIHNsb3QgaXMgYmlsbGVkIGFzIDIgc3RhbmRhcmQgcmVzb3VyY2Ugc2xvdHMuIFlvdSB3aWxsIGJlIGJpbGxlZCBmb3IgQ29weUZhY3RvcnkgMlxuICAgKiByZXNvdXJjZSBzbG90cyBvbmx5IGlmIHlvdSBoYXZlIGFkZGVkIHlvdXIgYWNjb3VudCB0byBDb3B5RmFjdG9yeSAyIGJ5IHNwZWNpZnlpbmcgY29weUZhY3RvcnlSb2xlcyBmaWVsZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBudW1iZXIgb2YgQ29weUZhY3RvcnkgMiByZXNvdXJjZSBzbG90cyB0byBhbGxvY2F0ZSB0byBhY2NvdW50XG4gICAqL1xuICBnZXQgY29weUZhY3RvcnlSZXNvdXJjZVNsb3RzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmNvcHlGYWN0b3J5UmVzb3VyY2VTbG90cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjY291bnQgcmVnaW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gYWNjb3VudCByZWdpb24gdmFsdWVcbiAgICovXG4gIGdldCByZWdpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmVnaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpbWUgYWNjb3VudCB3YXMgY3JlYXRlZCBhdCwgaW4gSVNPIGZvcm1hdFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdGltZSBhY2NvdW50IHdhcyBjcmVhdGVkIGF0LCBpbiBJU08gZm9ybWF0XG4gICAqL1xuICBnZXQgY3JlYXRlZEF0KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kYXRhLmNyZWF0ZWRBdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBodW1hbi1yZWFkYWJsZSBhY2NvdW50IG5hbWVcbiAgICogQHJldHVybiB7c3RyaW5nfSBodW1hbi1yZWFkYWJsZSBhY2NvdW50IG5hbWVcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLm5hbWU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyBpZiB0cmFkZXMgc2hvdWxkIGJlIHBsYWNlZCBhcyBtYW51YWwgdHJhZGVzIG9uIHRoaXMgYWNjb3VudFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBmbGFnIGluZGljYXRpbmcgaWYgdHJhZGVzIHNob3VsZCBiZSBwbGFjZWQgYXMgbWFudWFsIHRyYWRlcyBvbiB0aGlzIGFjY291bnRcbiAgICovXG4gIGdldCBtYW51YWxUcmFkZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWFudWFsVHJhZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdCB0cmFkZSBzbGlwcGFnZSBpbiBwb2ludHNcbiAgICogQHJldHVybiB7bnVtYmVyfSBkZWZhdWx0IHRyYWRlIHNsaXBwYWdlIGluIHBvaW50c1xuICAgKi9cbiAgZ2V0IHNsaXBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnNsaXBwYWdlO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJucyBpZCBvZiB0aGUgYWNjb3VudCdzIHByb3Zpc2lvbmluZyBwcm9maWxlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gaWQgb2YgdGhlIGFjY291bnQncyBwcm92aXNpb25pbmcgcHJvZmlsZVxuICAgKi9cbiAgZ2V0IHByb3Zpc2lvbmluZ1Byb2ZpbGVJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5wcm92aXNpb25pbmdQcm9maWxlSWQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFUcmFkZXIgYWNjb3VudCBsb2dpblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1ldGFUcmFkZXIgYWNjb3VudCBudW1iZXJcbiAgICovXG4gIGdldCBsb2dpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5sb2dpbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YVRyYWRlciBzZXJ2ZXIgbmFtZSB0byBjb25uZWN0IHRvXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWV0YVRyYWRlciBzZXJ2ZXIgbmFtZSB0byBjb25uZWN0IHRvXG4gICAqL1xuICBnZXQgc2VydmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnNlcnZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjY291bnQgdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSBjbG91ZC1nMSwgY2xvdWQtZzJcbiAgICogQHJldHVybiB7VHlwZX0gYWNjb3VudCB0eXBlXG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS50eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTVQgdmVyc2lvbi4gUG9zc2libGUgdmFsdWVzIGFyZSA0IGFuZCA1XG4gICAqIEByZXR1cm4ge1ZlcnNpb259IE1UIHZlcnNpb25cbiAgICovXG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoYXNoLWNvZGUgb2YgdGhlIGFjY291bnRcbiAgICogQHJldHVybiB7bnVtYmVyfSBoYXNoLWNvZGUgb2YgdGhlIGFjY291bnRcbiAgICovXG4gIGdldCBoYXNoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmhhc2g7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyAzLWNoYXJhY3RlciBJU08gY3VycmVuY3kgY29kZSBvZiB0aGUgYWNjb3VudCBiYXNlIGN1cnJlbmN5LiBUaGUgc2V0dGluZyBpcyB0byBiZSB1c2VkXG4gICAqIGZvciBjb3B5IHRyYWRpbmcgYWNjb3VudHMgd2hpY2ggdXNlIG5hdGlvbmFsIGN1cnJlbmNpZXMgb25seSwgc3VjaCBhcyBzb21lIEJyYXppbGlhbiBicm9rZXJzLiBZb3Ugc2hvdWxkIG5vdCBhbHRlclxuICAgKiB0aGlzIHNldHRpbmcgdW5sZXNzIHlvdSB1bmRlcnN0YW5kIHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSAzLWNoYXJhY3RlciBJU08gY3VycmVuY3kgY29kZSBvZiB0aGUgYWNjb3VudCBiYXNlIGN1cnJlbmN5XG4gICAqL1xuICBnZXQgYmFzZUN1cnJlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmJhc2VDdXJyZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjY291bnQgcm9sZXMgZm9yIENvcHlGYWN0b3J5MiBhcHBsaWNhdGlvbi4gUG9zc2libGUgdmFsdWVzIGFyZSBgUFJPVklERVJgIGFuZCBgU1VCU0NSSUJFUmBcbiAgICogQHJldHVybiB7QXJyYXk8Q29weUZhY3RvcnlSb2xlcz59IGFjY291bnQgcm9sZXMgZm9yIENvcHlGYWN0b3J5MiBhcHBsaWNhdGlvblxuICAgKi9cbiAgZ2V0IGNvcHlGYWN0b3J5Um9sZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuY29weUZhY3RvcnlSb2xlcztcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBpbmRpY2F0aW5nIHRoYXQgcmlzayBtYW5hZ2VtZW50IEFQSSBpcyBlbmFibGVkIG9uIGFjY291bnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gZmxhZyBpbmRpY2F0aW5nIHRoYXQgcmlzayBtYW5hZ2VtZW50IEFQSSBpcyBlbmFibGVkIG9uIGFjY291bnRcbiAgICovXG4gIGdldCByaXNrTWFuYWdlbWVudEFwaUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucmlza01hbmFnZW1lbnRBcGlFbmFibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBpbmRpY2F0aW5nIHRoYXQgTWV0YVN0YXRzIEFQSSBpcyBlbmFibGVkIG9uIGFjY291bnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gZmxhZyBpbmRpY2F0aW5nIHRoYXQgTWV0YVN0YXRzIEFQSSBpcyBlbmFibGVkIG9uIGFjY291bnRcbiAgICovXG4gIGdldCBtZXRhc3RhdHNBcGlFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLm1ldGFzdGF0c0FwaUVuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maWd1cmVkIGRlZGljYXRlZCBJUCBwcm90b2NvbCB0byBjb25uZWN0IHRvIHRoZSB0cmFkaW5nIGFjY291bnQgdGVybWluYWxcbiAgICogQHJldHVybiB7RGVkaWNhdGVkSXB9XG4gICAqL1xuICBnZXQgYWxsb2NhdGVEZWRpY2F0ZWRJcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5hbGxvY2F0ZURlZGljYXRlZElwO1xuICB9XG4gICAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjdGl2ZSBhY2NvdW50IGNvbm5lY3Rpb25zXG4gICAqIEByZXR1cm4ge0FycmF5PEFjY291bnRDb25uZWN0aW9uPn0gYWN0aXZlIGFjY291bnQgY29ubmVjdGlvbnNcbiAgICovXG4gIGdldCBjb25uZWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jb25uZWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyB0aGF0IGFjY291bnQgaXMgcHJpbWFyeVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBmbGFnIGluZGljYXRpbmcgdGhhdCBhY2NvdW50IGlzIHByaW1hcnlcbiAgICovXG4gIGdldCBwcmltYXJ5UmVwbGljYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5wcmltYXJ5UmVwbGljYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHVzZXIgaWRcbiAgICogQHJldHVybiB7c3RyaW5nfSB1c2VyIGlkXG4gICAqL1xuICBnZXQgdXNlcklkKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnVzZXJJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHByaW1hcnkgYWNjb3VudCBpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHByaW1hcnkgYWNjb3VudCBpZFxuICAgKi9cbiAgZ2V0IHByaW1hcnlBY2NvdW50SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEucHJpbWFyeUFjY291bnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjY291bnQgcmVwbGljYXMgZnJvbSBEVE9cbiAgICogQHJldHVybiB7TWV0YXRyYWRlckFjY291bnRSZXBsaWNhW119IGFjY291bnQgcmVwbGljYXMgZnJvbSBEVE9cbiAgICovXG4gIGdldCBhY2NvdW50UmVwbGljYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuYWNjb3VudFJlcGxpY2FzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWNjb3VudCByZXBsaWNhIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtNZXRhdHJhZGVyQWNjb3VudFJlcGxpY2FbXX0gYWNjb3VudCByZXBsaWNhIGluc3RhbmNlc1xuICAgKi9cbiAgZ2V0IHJlcGxpY2FzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXBsaWNhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZGljdGlvbmFyeSB3aXRoIGFjY291bnQncyBhdmFpbGFibGUgcmVnaW9ucyBhbmQgcmVwbGljYXNcbiAgICogQHJldHVybnMge3tbcmVnaW9uOiBzdHJpbmddOiBzdHJpbmd9fVxuICAgKi9cbiAgZ2V0IGFjY291bnRSZWdpb25zKCkge1xuICAgIGNvbnN0IHJlZ2lvbnMgPSB7W3RoaXMucmVnaW9uXTogdGhpcy5pZH07XG4gICAgdGhpcy5yZXBsaWNhcy5mb3JFYWNoKHJlcGxpY2EgPT4gcmVnaW9uc1tyZXBsaWNhLnJlZ2lvbl0gPSByZXBsaWNhLmlkKTtcbiAgICByZXR1cm4gcmVnaW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxvYWRzIE1ldGFUcmFkZXIgYWNjb3VudCBmcm9tIEFQSVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIE1ldGFUcmFkZXIgYWNjb3VudCBpcyB1cGRhdGVkXG4gICAqL1xuICBhc3luYyByZWxvYWQoKSB7XG4gICAgdGhpcy5fZGF0YSA9IGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmdldEFjY291bnQodGhpcy5pZCk7XG4gICAgY29uc3QgdXBkYXRlZFJlcGxpY2FEYXRhID0gKHRoaXMuX2RhdGEuYWNjb3VudFJlcGxpY2FzIHx8IFtdKTtcbiAgICBjb25zdCByZWdpb25zID0gdXBkYXRlZFJlcGxpY2FEYXRhLm1hcChyZXBsaWNhID0+IHJlcGxpY2EucmVnaW9uKTtcbiAgICBjb25zdCBjcmVhdGVkUmVwbGljYVJlZ2lvbnMgPSB0aGlzLl9yZXBsaWNhcy5tYXAocmVwbGljYSA9PiByZXBsaWNhLnJlZ2lvbik7XG4gICAgdGhpcy5fcmVwbGljYXMgPSB0aGlzLl9yZXBsaWNhcy5maWx0ZXIocmVwbGljYSA9PiByZWdpb25zLmluY2x1ZGVzKHJlcGxpY2EucmVnaW9uKSk7XG4gICAgdGhpcy5fcmVwbGljYXMuZm9yRWFjaChyZXBsaWNhID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gdXBkYXRlZFJlcGxpY2FEYXRhLmZpbmQocmVwbGljYURhdGEgPT4gcmVwbGljYURhdGEucmVnaW9uID09PSByZXBsaWNhLnJlZ2lvbik7XG4gICAgICByZXBsaWNhLnVwZGF0ZURhdGEodXBkYXRlZERhdGEpO1xuICAgIH0pO1xuICAgIHVwZGF0ZWRSZXBsaWNhRGF0YS5mb3JFYWNoKHJlcGxpY2EgPT4ge1xuICAgICAgaWYoIWNyZWF0ZWRSZXBsaWNhUmVnaW9ucy5pbmNsdWRlcyhyZXBsaWNhLnJlZ2lvbikpIHtcbiAgICAgICAgdGhpcy5fcmVwbGljYXMucHVzaChuZXcgTWV0YXRyYWRlckFjY291bnRSZXBsaWNhKHJlcGxpY2EsIHRoaXMsIHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHRyYWRpbmcgYWNjb3VudCBhbmQgc3RvcHMgdGhlIEFQSSBzZXJ2ZXIgc2VydmluZyB0aGUgYWNjb3VudC5cbiAgICogVGhlIGFjY291bnQgc3RhdGUgc3VjaCBhcyBkb3dubG9hZGVkIG1hcmtldCBkYXRhIGhpc3Rvcnkgd2lsbCBiZSByZW1vdmVkIGFzIHdlbGwgd2hlbiB5b3UgcmVtb3ZlIHRoZSBhY2NvdW50LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgaXMgc2NoZWR1bGVkIGZvciBkZWxldGlvblxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5jbG9zZUFsbEluc3RhbmNlcyh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5kZWxldGVBY2NvdW50KHRoaXMuaWQpO1xuICAgIGNvbnN0IGZpbGVNYW5hZ2VyID0gSGlzdG9yeURhdGFiYXNlLmdldEluc3RhbmNlKCk7XG4gICAgYXdhaXQgZmlsZU1hbmFnZXIuY2xlYXIodGhpcy5pZCwgdGhpcy5fYXBwbGljYXRpb24pO1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdzZWxmLWhvc3RlZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5uYW1lICE9PSAnTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIEFQSSBzZXJ2ZXIgYW5kIHRyYWRpbmcgdGVybWluYWwgZm9yIHRyYWRpbmcgYWNjb3VudC5cbiAgICogVGhpcyByZXF1ZXN0IHdpbGwgYmUgaWdub3JlZCBpZiB0aGUgYWNjb3VudCBpcyBhbHJlYWR5IGRlcGxveWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IGlzIHNjaGVkdWxlZCBmb3IgZGVwbG95bWVudFxuICAgKi9cbiAgYXN5bmMgZGVwbG95KCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmRlcGxveUFjY291bnQodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBBUEkgc2VydmVyIGFuZCB0cmFkaW5nIHRlcm1pbmFsIGZvciB0cmFkaW5nIGFjY291bnQuXG4gICAqIFRoaXMgcmVxdWVzdCB3aWxsIGJlIGlnbm9yZWQgaWYgdHJhZGluZyBhY2NvdW50IGlzIGFscmVhZHkgdW5kZXBsb3llZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IGlzIHNjaGVkdWxlZCBmb3IgdW5kZXBsb3ltZW50XG4gICAqL1xuICBhc3luYyB1bmRlcGxveSgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkuY2xvc2VBbGxJbnN0YW5jZXModGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5fbWV0YXRyYWRlckFjY291bnRDbGllbnQudW5kZXBsb3lBY2NvdW50KHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVkZXBsb3lzIHRyYWRpbmcgYWNjb3VudC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIHVuZGVwbG95IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGRlcGxveVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IGlzIHNjaGVkdWxlZCBmb3IgcmVkZXBsb3ltZW50XG4gICAqL1xuICBhc3luYyByZWRlcGxveSgpIHtcbiAgICBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5yZWRlcGxveUFjY291bnQodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZWFzZXMgdHJhZGluZyBhY2NvdW50IHJlbGlhYmlsaXR5IGluIG9yZGVyIHRvIGluY3JlYXNlIHRoZSBleHBlY3RlZCBhY2NvdW50IHVwdGltZS5cbiAgICogVGhlIGFjY291bnQgd2lsbCBiZSB0ZW1wb3Jhcnkgc3RvcHBlZCB0byBwZXJmb3JtIHRoaXMgYWN0aW9uLlxuICAgKiBOb3RlIHRoYXQgaW5jcmVhc2luZyByZWxpYWJpbGl0eSBpcyBhIHBhaWQgb3B0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgcmVsaWFiaWxpdHkgaXMgaW5jcmVhc2VkXG4gICAqL1xuICBhc3luYyBpbmNyZWFzZVJlbGlhYmlsaXR5KCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmluY3JlYXNlUmVsaWFiaWxpdHkodGhpcy5pZCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHJpc2sgbWFuYWdlbWVudCBBUEkgZm9yIHRyYWRpbmcgYWNjb3VudC5cbiAgICogVGhlIGFjY291bnQgd2lsbCBiZSB0ZW1wb3Jhcnkgc3RvcHBlZCB0byBwZXJmb3JtIHRoaXMgYWN0aW9uLlxuICAgKiBOb3RlIHRoYXQgcmlzayBtYW5hZ2VtZW50IEFQSSBpcyBhIHBhaWQgb3B0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGFjY291bnQgcmlzayBtYW5hZ2VtZW50IGlzIGVuYWJsZWRcbiAgICovXG4gIGFzeW5jIGVuYWJsZVJpc2tNYW5hZ2VtZW50QXBpKCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmVuYWJsZVJpc2tNYW5hZ2VtZW50QXBpKHRoaXMuaWQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBNZXRhU3RhdHMgQVBJIGZvciB0cmFkaW5nIGFjY291bnQuXG4gICAqIFRoZSBhY2NvdW50IHdpbGwgYmUgdGVtcG9yYXJ5IHN0b3BwZWQgdG8gcGVyZm9ybSB0aGlzIGFjdGlvbi5cbiAgICogTm90ZSB0aGF0IHRoaXMgaXMgYSBwYWlkIG9wdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiBhY2NvdW50IE1ldGFTdGF0cyBBUEkgaXMgZW5hYmxlZFxuICAgKi9cbiAgYXN5bmMgZW5hYmxlTWV0YVN0YXRzQXBpKCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmVuYWJsZU1ldGFTdGF0c0FwaSh0aGlzLmlkKTtcbiAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIHVudGlsIEFQSSBzZXJ2ZXIgaGFzIGZpbmlzaGVkIGRlcGxveW1lbnQgYW5kIGFjY291bnQgcmVhY2hlZCB0aGUgREVQTE9ZRUQgc3RhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRJblNlY29uZHMgd2FpdCB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgNW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsSW5NaWxsaXNlY29uZHMgaW50ZXJ2YWwgYmV0d2VlbiBhY2NvdW50IHJlbG9hZHMgd2hpbGUgd2FpdGluZyBmb3IgYSBjaGFuZ2UsIGRlZmF1bHQgaXMgMXNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFjY291bnQgaXMgZGVwbG95ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhY2NvdW50IGhhdmUgbm90IHJlYWNoZWQgdGhlIERFUExPWUVEIHN0YXRlIHdpdGhpbiB0aW1lb3V0IGFsbG93ZWRcbiAgICovXG4gIGFzeW5jIHdhaXREZXBsb3llZCh0aW1lb3V0SW5TZWNvbmRzID0gMzAwLCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gMTAwMCkge1xuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUgIT09ICdERVBMT1lFRCcgJiYgKHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSA+IERhdGUubm93KCkpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RlbGF5KGludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdERVBMT1lFRCcpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBhY2NvdW50ICcgKyB0aGlzLmlkICsgJyB0byBiZSBkZXBsb3llZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBBUEkgc2VydmVyIGhhcyBmaW5pc2hlZCB1bmRlcGxveW1lbnQgYW5kIGFjY291bnQgcmVhY2hlZCB0aGUgVU5ERVBMT1lFRCBzdGF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dEluU2Vjb25kcyB3YWl0IHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyA1bVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyBpbnRlcnZhbCBiZXR3ZWVuIGFjY291bnQgcmVsb2FkcyB3aGlsZSB3YWl0aW5nIGZvciBhIGNoYW5nZSwgZGVmYXVsdCBpcyAxc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gYWNjb3VudCBpcyBkZXBsb3llZFxuICAgKiBAdGhyb3dzIHtUaW1lb3V0RXJyb3J9IGlmIGFjY291bnQgaGF2ZSBub3QgcmVhY2hlZCB0aGUgVU5ERVBMT1lFRCBzdGF0ZSB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICBhc3luYyB3YWl0VW5kZXBsb3llZCh0aW1lb3V0SW5TZWNvbmRzID0gMzAwLCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gMTAwMCkge1xuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUgIT09ICdVTkRFUExPWUVEJyAmJiAoc3RhcnRUaW1lICsgdGltZW91dEluU2Vjb25kcyAqIDEwMDApID4gRGF0ZS5ub3coKSkge1xuICAgICAgYXdhaXQgdGhpcy5fZGVsYXkoaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyk7XG4gICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ1VOREVQTE9ZRUQnKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgYWNjb3VudCAnICsgdGhpcy5pZCArICcgdG8gYmUgdW5kZXBsb3llZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBhY2NvdW50IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRJblNlY29uZHMgd2FpdCB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgNW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsSW5NaWxsaXNlY29uZHMgaW50ZXJ2YWwgYmV0d2VlbiBhY2NvdW50IHJlbG9hZHMgd2hpbGUgd2FpdGluZyBmb3IgYSBjaGFuZ2UsIGRlZmF1bHQgaXMgMXNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFjY291bnQgaXMgZGVsZXRlZFxuICAgKiBAdGhyb3dzIHtUaW1lb3V0RXJyb3J9IGlmIGFjY291bnQgd2FzIG5vdCBkZWxldGVkIHdpdGhpbiB0aW1lb3V0IGFsbG93ZWRcbiAgICovXG4gIGFzeW5jIHdhaXRSZW1vdmVkKHRpbWVvdXRJblNlY29uZHMgPSAzMDAsIGludGVydmFsSW5NaWxsaXNlY29uZHMgPSAxMDAwKSB7XG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICB3aGlsZSAoc3RhcnRUaW1lICsgdGltZW91dEluU2Vjb25kcyAqIDEwMDAgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2RlbGF5KGludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcignVGltZWQgb3V0IHdhaXRpbmcgZm9yIGFjY291bnQgJyArIHRoaXMuaWQgKyAnIHRvIGJlIGRlbGV0ZWQnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgdW50aWwgQVBJIHNlcnZlciBoYXMgY29ubmVjdGVkIHRvIHRoZSB0ZXJtaW5hbCBhbmQgdGVybWluYWwgaGFzIGNvbm5lY3RlZCB0byB0aGUgYnJva2VyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHdhaXQgdGltZW91dCBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDVtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbEluTWlsbGlzZWNvbmRzIGludGVydmFsIGJldHdlZW4gYWNjb3VudCByZWxvYWRzIHdoaWxlIHdhaXRpbmcgZm9yIGEgY2hhbmdlLCBkZWZhdWx0IGlzIDFzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBBUEkgc2VydmVyIGlzIGNvbm5lY3RlZCB0byB0aGUgYnJva2VyXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYWNjb3VudCBoYXZlIG5vdCBjb25uZWN0ZWQgdG8gdGhlIGJyb2tlciB3aXRoaW4gdGltZW91dCBhbGxvd2VkXG4gICAqL1xuICBhc3luYyB3YWl0Q29ubmVjdGVkKHRpbWVvdXRJblNlY29uZHMgPSAzMDAsIGludGVydmFsSW5NaWxsaXNlY29uZHMgPSAxMDAwKSB7XG4gICAgY29uc3QgY2hlY2tDb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gW3RoaXMuY29ubmVjdGlvblN0YXR1c10uY29uY2F0KHRoaXMucmVwbGljYXMubWFwKHJlcGxpY2EgPT4gXG4gICAgICAgIHJlcGxpY2EuY29ubmVjdGlvblN0YXR1cykpLmluY2x1ZGVzKCdDT05ORUNURUQnKTtcbiAgICB9O1xuXG4gICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICB3aGlsZSAoIWNoZWNrQ29ubmVjdGVkKCkgJiYgKHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSA+IERhdGUubm93KCkpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RlbGF5KGludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgYWNjb3VudCAnICsgdGhpcy5pZCArICcgdG8gY29ubmVjdCB0byB0aGUgYnJva2VyJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIE1ldGFBcGkuIFRoZXJlIGlzIG9ubHkgb25lIGNvbm5lY3Rpb24gcGVyIGFjY291bnQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtIaXN0b3J5U3RvcmFnZX0gaGlzdG9yeVN0b3JhZ2Ugb3B0aW9uYWwgaGlzdG9yeSBzdG9yYWdlXG4gICAqIEBwYXJhbSB7RGF0ZX0gW2hpc3RvcnlTdGFydFRpbWVdIGhpc3Rvcnkgc3RhcnQgdGltZS4gVXNlZCBmb3IgdGVzdHNcbiAgICogQHJldHVybiB7U3RyZWFtaW5nTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZX0gTWV0YUFwaSBjb25uZWN0aW9uIGluc3RhbmNlXG4gICAqL1xuICBnZXRTdHJlYW1pbmdDb25uZWN0aW9uKGhpc3RvcnlTdG9yYWdlLCBoaXN0b3J5U3RhcnRUaW1lKSB7XG4gICAgaWYodGhpcy5fbWV0YUFwaVdlYnNvY2tldENsaWVudC5yZWdpb24gJiYgdGhpcy5fbWV0YUFwaVdlYnNvY2tldENsaWVudC5yZWdpb24gIT09IHRoaXMucmVnaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICBgQWNjb3VudCAke3RoaXMuaWR9IGlzIG5vdCBvbiBzcGVjaWZpZWQgcmVnaW9uICR7dGhpcy5fbWV0YUFwaVdlYnNvY2tldENsaWVudC5yZWdpb259YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LmNvbm5lY3RTdHJlYW1pbmcodGhpcywgaGlzdG9yeVN0b3JhZ2UsIGhpc3RvcnlTdGFydFRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIE1ldGFBcGkgdmlhIFJQQyBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7UnBjTWV0YUFwaUNvbm5lY3Rpb25JbnN0YW5jZX0gTWV0YUFwaSBjb25uZWN0aW9uIGluc3RhbmNlXG4gICAqL1xuICBnZXRSUENDb25uZWN0aW9uKCkge1xuICAgIGlmKHRoaXMuX21ldGFBcGlXZWJzb2NrZXRDbGllbnQucmVnaW9uICYmIHRoaXMuX21ldGFBcGlXZWJzb2NrZXRDbGllbnQucmVnaW9uICE9PSB0aGlzLnJlZ2lvbikge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgYEFjY291bnQgJHt0aGlzLmlkfSBpcyBub3Qgb24gc3BlY2lmaWVkIHJlZ2lvbiAke3RoaXMuX21ldGFBcGlXZWJzb2NrZXRDbGllbnQucmVnaW9ufWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkuY29ubmVjdFJwYyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRyYWRpbmcgYWNjb3VudC4gXG4gICAqIFBsZWFzZSByZWRlcGxveSB0aGUgdHJhZGluZyBhY2NvdW50IGluIG9yZGVyIGZvciB1cGRhdGVkIHNldHRpbmdzIHRvIHRha2UgZWZmZWN0XG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnRVcGRhdGVEdG99IGFjY291bnQgdXBkYXRlZCBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gYWNjb3VudCBpcyB1cGRhdGVkXG4gICAqL1xuICBhc3luYyB1cGRhdGUoYWNjb3VudCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LnVwZGF0ZUFjY291bnQodGhpcy5pZCwgYWNjb3VudCk7XG4gICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHJhZGluZyBhY2NvdW50IHJlcGxpY2EgaW4gYSByZWdpb24gZGlmZmVyZW50IGZyb20gdHJhZGluZyBhY2NvdW50IHJlZ2lvbiBhbmQgc3RhcnRzIGEgY2xvdWQgQVBJIHNlcnZlciBmb3IgaXRcbiAgICogQHBhcmFtIHtOZXdNZXRhVHJhZGVyQWNjb3VudER0b30gYWNjb3VudCBNZXRhVHJhZGVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1ldGF0cmFkZXJBY2NvdW50UmVwbGljYT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggY3JlYXRlZCBNZXRhVHJhZGVyIGFjY291bnQgcmVwbGljYSBlbnRpdHlcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVJlcGxpY2EoYWNjb3VudCkge1xuICAgIGF3YWl0IHRoaXMuX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50LmNyZWF0ZUFjY291bnRSZXBsaWNhKHRoaXMuaWQsIGFjY291bnQpO1xuICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGxpY2FzLmZpbmQociA9PiByLnJlZ2lvbiA9PT0gYWNjb3VudC5yZWdpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBleHBlcnQgYWR2aXNvciBvZiBjdXJyZW50IGFjY291bnRcbiAgICogQHJldHVybnMge1Byb21pc2U8RXhwZXJ0QWR2aXNvcltdPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhbiBhcnJheSBvZiBleHBlcnQgYWR2aXNvciBlbnRpdGllc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXhwZXJ0QWR2aXNvcnMoKSB7XG4gICAgdGhpcy5fY2hlY2tFeHBlcnRBZHZpc29yQWxsb3dlZCgpO1xuICAgIGxldCBleHBlcnRBZHZpc29ycyA9IGF3YWl0IHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQuZ2V0RXhwZXJ0QWR2aXNvcnModGhpcy5pZCk7XG4gICAgcmV0dXJuIGV4cGVydEFkdmlzb3JzLm1hcChlID0+IG5ldyBFeHBlcnRBZHZpc29yKGUsIHRoaXMuaWQsIHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBleHBlcnQgYWR2aXNvciBvZiBjdXJyZW50IGFjY291bnQgYnkgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cGVydElkIGV4cGVydCBhZHZpc29yIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEV4cGVydEFkdmlzb3I+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGV4cGVydCBhZHZpc29yIGVudGl0eVxuICAgKi9cbiAgYXN5bmMgZ2V0RXhwZXJ0QWR2aXNvcihleHBlcnRJZCkge1xuICAgIHRoaXMuX2NoZWNrRXhwZXJ0QWR2aXNvckFsbG93ZWQoKTtcbiAgICBsZXQgZXhwZXJ0QWR2aXNvciA9IGF3YWl0IHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQuZ2V0RXhwZXJ0QWR2aXNvcih0aGlzLmlkLCBleHBlcnRJZCk7XG4gICAgcmV0dXJuIG5ldyBFeHBlcnRBZHZpc29yKGV4cGVydEFkdmlzb3IsIHRoaXMuaWQsIHRoaXMuX2V4cGVydEFkdmlzb3JDbGllbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXhwZXJ0IGFkdmlzb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVydElkIGV4cGVydCBhZHZpc29yIGlkXG4gICAqIEBwYXJhbSB7TmV3RXhwZXJ0QWR2aXNvckR0b30gZXhwZXJ0IGV4cGVydCBhZHZpc29yIGRhdGFcbiAgICogQHJldHVybnMge1Byb21pc2U8RXhwZXJ0QWR2aXNvcj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggZXhwZXJ0IGFkdmlzb3IgZW50aXR5XG4gICAqL1xuICBhc3luYyBjcmVhdGVFeHBlcnRBZHZpc29yKGV4cGVydElkLCBleHBlcnQpIHtcbiAgICB0aGlzLl9jaGVja0V4cGVydEFkdmlzb3JBbGxvd2VkKCk7XG4gICAgYXdhaXQgdGhpcy5fZXhwZXJ0QWR2aXNvckNsaWVudC51cGRhdGVFeHBlcnRBZHZpc29yKHRoaXMuaWQsIGV4cGVydElkLCBleHBlcnQpO1xuICAgIHJldHVybiB0aGlzLmdldEV4cGVydEFkdmlzb3IoZXhwZXJ0SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yaWNhbCBjYW5kbGVzIGZvciBhIHNwZWNpZmljIHN5bWJvbCBhbmQgdGltZWZyYW1lIGZyb20gdGhlIE1ldGFUcmFkZXIgYWNjb3VudC5cbiAgICogU2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9yZXN0QXBpL2FwaS9yZXRyaWV2ZU1hcmtldERhdGEvcmVhZEhpc3RvcmljYWxDYW5kbGVzL1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBjYW5kbGVzIGZvciAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lZnJhbWUgZGVmaW5lcyB0aGUgdGltZWZyYW1lIGFjY29yZGluZyB0byB3aGljaCB0aGUgY2FuZGxlcyBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXNcbiAgICogZm9yIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWRcbiAgICogdmFsdWVzIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcGFyYW0ge0RhdGV9IFtzdGFydFRpbWVdIHRpbWUgdG8gc3RhcnQgbG9hZGluZyBjYW5kbGVzIGZyb20uIE5vdGUgdGhhdCBjYW5kbGVzIGFyZSBsb2FkZWQgaW4gYmFja3dhcmRzIGRpcmVjdGlvbiwgc29cbiAgICogdGhpcyBzaG91bGQgYmUgdGhlIGxhdGVzdCB0aW1lLiBMZWF2ZSBlbXB0eSB0byByZXF1ZXN0IGxhdGVzdCBjYW5kbGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBtYXhpbXVtIG51bWJlciBvZiBjYW5kbGVzIHRvIHJldHJpZXZlLiBNdXN0IGJlIGxlc3Mgb3IgZXF1YWwgdG8gMTAwMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJDYW5kbGU+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBoaXN0b3JpY2FsIGNhbmRsZXMgZG93bmxvYWRlZFxuICAgKi9cbiAgZ2V0SGlzdG9yaWNhbENhbmRsZXMoc3ltYm9sLCB0aW1lZnJhbWUsIHN0YXJ0VGltZSwgbGltaXQpIHtcbiAgICByZXR1cm4gdGhpcy5faGlzdG9yaWNhbE1hcmtldERhdGFDbGllbnQuZ2V0SGlzdG9yaWNhbENhbmRsZXModGhpcy5pZCwgdGhpcy5yZWdpb24sIHN5bWJvbCxcbiAgICAgIHRpbWVmcmFtZSwgc3RhcnRUaW1lLCBsaW1pdCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcmljYWwgdGlja3MgZm9yIGEgc3BlY2lmaWMgc3ltYm9sIGZyb20gdGhlIE1ldGFUcmFkZXIgYWNjb3VudC4gVGhpcyBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSBNVDRcbiAgICogYWNjb3VudHMuXG4gICAqIFNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvcmVzdEFwaS9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRIaXN0b3JpY2FsVGlja3MvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2tzIGZvciAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0VGltZV0gdGltZSB0byBzdGFydCBsb2FkaW5nIHRpY2tzIGZyb20uIE5vdGUgdGhhdCBjYW5kbGVzIGFyZSBsb2FkZWQgaW4gZm9yd2FyZCBkaXJlY3Rpb24sIHNvXG4gICAqIHRoaXMgc2hvdWxkIGJlIHRoZSBlYXJsaWVzdCB0aW1lLiBMZWF2ZSBlbXB0eSB0byByZXF1ZXN0IGxhdGVzdCBjYW5kbGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldF0gbnVtYmVyIG9mIHRpY2tzIHRvIHNraXAgKHlvdSBjYW4gdXNlIGl0IHRvIGF2b2lkIHJlcXVlc3RpbmcgdGlja3MgZnJvbSBwcmV2aW91cyByZXF1ZXN0XG4gICAqIHR3aWNlKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byByZXRyaWV2ZS4gTXVzdCBiZSBsZXNzIG9yIGVxdWFsIHRvIDEwMDBcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyVGljaz4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGhpc3RvcmljYWwgdGlja3MgZG93bmxvYWRlZFxuICAgKi9cbiAgZ2V0SGlzdG9yaWNhbFRpY2tzKHN5bWJvbCwgc3RhcnRUaW1lLCBvZmZzZXQsIGxpbWl0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50LmdldEhpc3RvcmljYWxUaWNrcyh0aGlzLmlkLCB0aGlzLnJlZ2lvbiwgc3ltYm9sLCBzdGFydFRpbWUsIG9mZnNldCwgbGltaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0cmFkaW5nIGFjY291bnQgY29uZmlndXJhdGlvbiBsaW5rIGJ5IGFjY291bnQgaWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdHRsSW5EYXlzXSBMaWZldGltZSBvZiB0aGUgbGluayBpbiBkYXlzLiBEZWZhdWx0IGlzIDcuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Q29uZmlndXJhdGlvbkxpbms+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGNvbmZpZ3VyYXRpb24gbGlua1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ29uZmlndXJhdGlvbkxpbmsodHRsSW5EYXlzKSB7XG4gICAgY29uc3QgY29uZmlndXJhdGlvbkxpbmsgPSBhd2FpdCB0aGlzLl9tZXRhdHJhZGVyQWNjb3VudENsaWVudC5jcmVhdGVDb25maWd1cmF0aW9uTGluayh0aGlzLmlkLCB0dGxJbkRheXMpO1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uTGluaztcbiAgfVxuXG4gIF9jaGVja0V4cGVydEFkdmlzb3JBbGxvd2VkKCkge1xuICAgIGlmICh0aGlzLnZlcnNpb24gIT09IDQgfHwgdGhpcy50eXBlICE9PSAnY2xvdWQtZzEnKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdDdXN0b20gZXhwZXJ0IGFkdmlzb3IgaXMgYXZhaWxhYmxlIG9ubHkgZm9yIE1UNCBHMSBhY2NvdW50cycpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWxheSh0aW1lb3V0SW5NaWxsaXNlY29uZHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCB0aW1lb3V0SW5NaWxsaXNlY29uZHMpKTtcbiAgfVxuXG59XG4iXSwibmFtZXMiOlsiTWV0YXRyYWRlckFjY291bnQiLCJpZCIsIl9kYXRhIiwiX2lkIiwic3RhdGUiLCJtYWdpYyIsImNvbm5lY3Rpb25TdGF0dXMiLCJxdW90ZVN0cmVhbWluZ0ludGVydmFsSW5TZWNvbmRzIiwic3ltYm9sIiwicmVsaWFiaWxpdHkiLCJ0YWdzIiwibWV0YWRhdGEiLCJyZXNvdXJjZVNsb3RzIiwiY29weUZhY3RvcnlSZXNvdXJjZVNsb3RzIiwicmVnaW9uIiwiY3JlYXRlZEF0IiwiRGF0ZSIsIm5hbWUiLCJtYW51YWxUcmFkZXMiLCJzbGlwcGFnZSIsInByb3Zpc2lvbmluZ1Byb2ZpbGVJZCIsImxvZ2luIiwic2VydmVyIiwidHlwZSIsInZlcnNpb24iLCJoYXNoIiwiYmFzZUN1cnJlbmN5IiwiY29weUZhY3RvcnlSb2xlcyIsInJpc2tNYW5hZ2VtZW50QXBpRW5hYmxlZCIsIm1ldGFzdGF0c0FwaUVuYWJsZWQiLCJhbGxvY2F0ZURlZGljYXRlZElwIiwiY29ubmVjdGlvbnMiLCJwcmltYXJ5UmVwbGljYSIsInVzZXJJZCIsInByaW1hcnlBY2NvdW50SWQiLCJhY2NvdW50UmVwbGljYXMiLCJyZXBsaWNhcyIsIl9yZXBsaWNhcyIsImFjY291bnRSZWdpb25zIiwicmVnaW9ucyIsImZvckVhY2giLCJyZXBsaWNhIiwicmVsb2FkIiwiX21ldGF0cmFkZXJBY2NvdW50Q2xpZW50IiwiZ2V0QWNjb3VudCIsInVwZGF0ZWRSZXBsaWNhRGF0YSIsIm1hcCIsImNyZWF0ZWRSZXBsaWNhUmVnaW9ucyIsImZpbHRlciIsImluY2x1ZGVzIiwidXBkYXRlZERhdGEiLCJmaW5kIiwicmVwbGljYURhdGEiLCJ1cGRhdGVEYXRhIiwicHVzaCIsIk1ldGF0cmFkZXJBY2NvdW50UmVwbGljYSIsInJlbW92ZSIsIl9jb25uZWN0aW9uUmVnaXN0cnkiLCJjbG9zZUFsbEluc3RhbmNlcyIsImRlbGV0ZUFjY291bnQiLCJmaWxlTWFuYWdlciIsIkhpc3RvcnlEYXRhYmFzZSIsImdldEluc3RhbmNlIiwiY2xlYXIiLCJfYXBwbGljYXRpb24iLCJlcnIiLCJkZXBsb3kiLCJkZXBsb3lBY2NvdW50IiwidW5kZXBsb3kiLCJ1bmRlcGxveUFjY291bnQiLCJyZWRlcGxveSIsInJlZGVwbG95QWNjb3VudCIsImluY3JlYXNlUmVsaWFiaWxpdHkiLCJlbmFibGVSaXNrTWFuYWdlbWVudEFwaSIsImVuYWJsZU1ldGFTdGF0c0FwaSIsIndhaXREZXBsb3llZCIsInRpbWVvdXRJblNlY29uZHMiLCJpbnRlcnZhbEluTWlsbGlzZWNvbmRzIiwic3RhcnRUaW1lIiwibm93IiwiX2RlbGF5IiwiVGltZW91dEVycm9yIiwid2FpdFVuZGVwbG95ZWQiLCJ3YWl0UmVtb3ZlZCIsIndhaXRDb25uZWN0ZWQiLCJjaGVja0Nvbm5lY3RlZCIsImNvbmNhdCIsImdldFN0cmVhbWluZ0Nvbm5lY3Rpb24iLCJoaXN0b3J5U3RvcmFnZSIsImhpc3RvcnlTdGFydFRpbWUiLCJfbWV0YUFwaVdlYnNvY2tldENsaWVudCIsIlZhbGlkYXRpb25FcnJvciIsImNvbm5lY3RTdHJlYW1pbmciLCJnZXRSUENDb25uZWN0aW9uIiwiY29ubmVjdFJwYyIsInVwZGF0ZSIsImFjY291bnQiLCJ1cGRhdGVBY2NvdW50IiwiY3JlYXRlUmVwbGljYSIsImNyZWF0ZUFjY291bnRSZXBsaWNhIiwiciIsImdldEV4cGVydEFkdmlzb3JzIiwiX2NoZWNrRXhwZXJ0QWR2aXNvckFsbG93ZWQiLCJleHBlcnRBZHZpc29ycyIsIl9leHBlcnRBZHZpc29yQ2xpZW50IiwiZSIsIkV4cGVydEFkdmlzb3IiLCJnZXRFeHBlcnRBZHZpc29yIiwiZXhwZXJ0SWQiLCJleHBlcnRBZHZpc29yIiwiY3JlYXRlRXhwZXJ0QWR2aXNvciIsImV4cGVydCIsInVwZGF0ZUV4cGVydEFkdmlzb3IiLCJnZXRIaXN0b3JpY2FsQ2FuZGxlcyIsInRpbWVmcmFtZSIsImxpbWl0IiwiX2hpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50IiwiZ2V0SGlzdG9yaWNhbFRpY2tzIiwib2Zmc2V0IiwiY3JlYXRlQ29uZmlndXJhdGlvbkxpbmsiLCJ0dGxJbkRheXMiLCJjb25maWd1cmF0aW9uTGluayIsInRpbWVvdXRJbk1pbGxpc2Vjb25kcyIsIlByb21pc2UiLCJyZXMiLCJzZXRUaW1lb3V0IiwiY29uc3RydWN0b3IiLCJkYXRhIiwibWV0YXRyYWRlckFjY291bnRDbGllbnQiLCJtZXRhQXBpV2Vic29ja2V0Q2xpZW50IiwiY29ubmVjdGlvblJlZ2lzdHJ5IiwiZXhwZXJ0QWR2aXNvckNsaWVudCIsImhpc3RvcmljYWxNYXJrZXREYXRhQ2xpZW50IiwiYXBwbGljYXRpb24iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O2VBa0JxQkE7OztxRUFoQkk7cUZBQ2dCOzJGQUNNOzhEQUNuQjtzRUFDRjs4QkFDSTtpRkFDTzt5Q0FLOUI7Ozs7OztBQUtRLElBQUEsQUFBTUEsb0JBQU4sTUFBTUE7SUF5Qm5COzs7R0FHQyxHQUNELElBQUlDLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHO0lBQ3ZCO0lBRUE7Ozs7R0FJQyxHQUNELElBQUlDLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQ0YsS0FBSyxDQUFDRSxLQUFLO0lBQ3pCO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNHLEtBQUs7SUFDekI7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ksZ0JBQWdCO0lBQ3BDO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsa0NBQWtDO1FBQ3BDLE9BQU8sSUFBSSxDQUFDTCxLQUFLLENBQUNLLCtCQUErQjtJQUNuRDtJQUVBOzs7R0FHQyxHQUNELElBQUlDLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ04sS0FBSyxDQUFDTSxNQUFNO0lBQzFCO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQ1AsS0FBSyxDQUFDTyxXQUFXO0lBQy9CO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDUixLQUFLLENBQUNRLElBQUk7SUFDeEI7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ1MsUUFBUTtJQUM1QjtJQUVBOzs7Ozs7OztHQVFDLEdBQ0QsSUFBSUMsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDVixLQUFLLENBQUNVLGFBQWE7SUFDakM7SUFFQTs7Ozs7OztHQU9DLEdBQ0QsSUFBSUMsMkJBQTJCO1FBQzdCLE9BQU8sSUFBSSxDQUFDWCxLQUFLLENBQUNXLHdCQUF3QjtJQUM1QztJQUVBOzs7R0FHQyxHQUNELElBQUlDLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ1osS0FBSyxDQUFDWSxNQUFNO0lBQzFCO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsWUFBWTtRQUNkLE9BQU8sSUFBSUMsS0FBSyxJQUFJLENBQUNkLEtBQUssQ0FBQ2EsU0FBUztJQUN0QztJQUVBOzs7R0FHQyxHQUNELElBQUlFLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ2YsS0FBSyxDQUFDZSxJQUFJO0lBQ3hCO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQ2hCLEtBQUssQ0FBQ2dCLFlBQVk7SUFDaEM7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNqQixLQUFLLENBQUNpQixRQUFRO0lBQzVCO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsd0JBQXdCO1FBQzFCLE9BQU8sSUFBSSxDQUFDbEIsS0FBSyxDQUFDa0IscUJBQXFCO0lBQ3pDO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDbkIsS0FBSyxDQUFDbUIsS0FBSztJQUN6QjtJQUVBOzs7R0FHQyxHQUNELElBQUlDLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ29CLE1BQU07SUFDMUI7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUNyQixLQUFLLENBQUNxQixJQUFJO0lBQ3hCO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDdEIsS0FBSyxDQUFDc0IsT0FBTztJQUMzQjtJQUVBOzs7R0FHQyxHQUNELElBQUlDLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ3ZCLEtBQUssQ0FBQ3VCLElBQUk7SUFDeEI7SUFFQTs7Ozs7R0FLQyxHQUNELElBQUlDLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUN4QixLQUFLLENBQUN3QixZQUFZO0lBQ2hDO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSSxDQUFDekIsS0FBSyxDQUFDeUIsZ0JBQWdCO0lBQ3BDO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsMkJBQTJCO1FBQzdCLE9BQU8sSUFBSSxDQUFDMUIsS0FBSyxDQUFDMEIsd0JBQXdCO0lBQzVDO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsc0JBQXNCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDM0IsS0FBSyxDQUFDMkIsbUJBQW1CO0lBQ3ZDO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsc0JBQXNCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDNUIsS0FBSyxDQUFDNEIsbUJBQW1CO0lBQ3ZDO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQzdCLEtBQUssQ0FBQzZCLFdBQVc7SUFDL0I7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUM5QixLQUFLLENBQUM4QixjQUFjO0lBQ2xDO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDL0IsS0FBSyxDQUFDK0IsTUFBTTtJQUMxQjtJQUVBOzs7R0FHQyxHQUNELElBQUlDLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQ2hDLEtBQUssQ0FBQ2dDLGdCQUFnQjtJQUNwQztJQUVBOzs7R0FHQyxHQUNELElBQUlDLGtCQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQ2pDLEtBQUssQ0FBQ2lDLGVBQWU7SUFDbkM7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNDLFNBQVM7SUFDdkI7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxpQkFBaUI7UUFDbkIsTUFBTUMsVUFBVTtZQUFDLENBQUMsSUFBSSxDQUFDekIsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDYixFQUFFO1FBQUE7UUFDdkMsSUFBSSxDQUFDbUMsUUFBUSxDQUFDSSxPQUFPLENBQUNDLENBQUFBLFVBQVdGLE9BQU8sQ0FBQ0UsUUFBUTNCLE1BQU0sQ0FBQyxHQUFHMkIsUUFBUXhDLEVBQUU7UUFDckUsT0FBT3NDO0lBQ1Q7SUFFQTs7O0dBR0MsR0FDRCxNQUFNRyxTQUFTO1FBQ2IsSUFBSSxDQUFDeEMsS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDeUMsd0JBQXdCLENBQUNDLFVBQVUsQ0FBQyxJQUFJLENBQUMzQyxFQUFFO1FBQ25FLE1BQU00QyxxQkFBc0IsSUFBSSxDQUFDM0MsS0FBSyxDQUFDaUMsZUFBZSxJQUFJLEVBQUU7UUFDNUQsTUFBTUksVUFBVU0sbUJBQW1CQyxHQUFHLENBQUNMLENBQUFBLFVBQVdBLFFBQVEzQixNQUFNO1FBQ2hFLE1BQU1pQyx3QkFBd0IsSUFBSSxDQUFDVixTQUFTLENBQUNTLEdBQUcsQ0FBQ0wsQ0FBQUEsVUFBV0EsUUFBUTNCLE1BQU07UUFDMUUsSUFBSSxDQUFDdUIsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUyxDQUFDVyxNQUFNLENBQUNQLENBQUFBLFVBQVdGLFFBQVFVLFFBQVEsQ0FBQ1IsUUFBUTNCLE1BQU07UUFDakYsSUFBSSxDQUFDdUIsU0FBUyxDQUFDRyxPQUFPLENBQUNDLENBQUFBO1lBQ3JCLE1BQU1TLGNBQWNMLG1CQUFtQk0sSUFBSSxDQUFDQyxDQUFBQSxjQUFlQSxZQUFZdEMsTUFBTSxLQUFLMkIsUUFBUTNCLE1BQU07WUFDaEcyQixRQUFRWSxVQUFVLENBQUNIO1FBQ3JCO1FBQ0FMLG1CQUFtQkwsT0FBTyxDQUFDQyxDQUFBQTtZQUN6QixJQUFHLENBQUNNLHNCQUFzQkUsUUFBUSxDQUFDUixRQUFRM0IsTUFBTSxHQUFHO2dCQUNsRCxJQUFJLENBQUN1QixTQUFTLENBQUNpQixJQUFJLENBQUMsSUFBSUMsaUNBQXdCLENBQUNkLFNBQVMsSUFBSSxFQUFFLElBQUksQ0FBQ0Usd0JBQXdCO1lBQy9GO1FBQ0Y7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRCxNQUFNYSxTQUFTO1FBQ2IsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0MsaUJBQWlCLENBQUMsSUFBSSxDQUFDekQsRUFBRTtRQUNsRCxNQUFNLElBQUksQ0FBQzBDLHdCQUF3QixDQUFDZ0IsYUFBYSxDQUFDLElBQUksQ0FBQzFELEVBQUU7UUFDekQsTUFBTTJELGNBQWNDLGNBQWUsQ0FBQ0MsV0FBVztRQUMvQyxNQUFNRixZQUFZRyxLQUFLLENBQUMsSUFBSSxDQUFDOUQsRUFBRSxFQUFFLElBQUksQ0FBQytELFlBQVk7UUFDbEQsSUFBSSxJQUFJLENBQUN6QyxJQUFJLEtBQUssZUFBZTtZQUMvQixJQUFJO2dCQUNGLE1BQU0sSUFBSSxDQUFDbUIsTUFBTTtZQUNuQixFQUFFLE9BQU91QixLQUFLO2dCQUNaLElBQUlBLElBQUloRCxJQUFJLEtBQUssaUJBQWlCO29CQUNoQyxNQUFNZ0Q7Z0JBQ1I7WUFDRjtRQUNGO0lBQ0Y7SUFFQTs7OztHQUlDLEdBQ0QsTUFBTUMsU0FBUztRQUNiLE1BQU0sSUFBSSxDQUFDdkIsd0JBQXdCLENBQUN3QixhQUFhLENBQUMsSUFBSSxDQUFDbEUsRUFBRTtRQUN6RCxNQUFNLElBQUksQ0FBQ3lDLE1BQU07SUFDbkI7SUFFQTs7OztHQUlDLEdBQ0QsTUFBTTBCLFdBQVc7UUFDZixJQUFJLENBQUNYLG1CQUFtQixDQUFDQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUN6RCxFQUFFO1FBQ2xELE1BQU0sSUFBSSxDQUFDMEMsd0JBQXdCLENBQUMwQixlQUFlLENBQUMsSUFBSSxDQUFDcEUsRUFBRTtRQUMzRCxNQUFNLElBQUksQ0FBQ3lDLE1BQU07SUFDbkI7SUFFQTs7O0dBR0MsR0FDRCxNQUFNNEIsV0FBVztRQUNmLE1BQU0sSUFBSSxDQUFDM0Isd0JBQXdCLENBQUM0QixlQUFlLENBQUMsSUFBSSxDQUFDdEUsRUFBRTtRQUMzRCxNQUFNLElBQUksQ0FBQ3lDLE1BQU07SUFDbkI7SUFFQTs7Ozs7R0FLQyxHQUNELE1BQU04QixzQkFBc0I7UUFDMUIsTUFBTSxJQUFJLENBQUM3Qix3QkFBd0IsQ0FBQzZCLG1CQUFtQixDQUFDLElBQUksQ0FBQ3ZFLEVBQUU7UUFDL0QsTUFBTSxJQUFJLENBQUN5QyxNQUFNO0lBQ25CO0lBRUE7Ozs7O0dBS0MsR0FDRCxNQUFNK0IsMEJBQTBCO1FBQzlCLE1BQU0sSUFBSSxDQUFDOUIsd0JBQXdCLENBQUM4Qix1QkFBdUIsQ0FBQyxJQUFJLENBQUN4RSxFQUFFO1FBQ25FLE1BQU0sSUFBSSxDQUFDeUMsTUFBTTtJQUNuQjtJQUVBOzs7OztHQUtDLEdBQ0QsTUFBTWdDLHFCQUFxQjtRQUN6QixNQUFNLElBQUksQ0FBQy9CLHdCQUF3QixDQUFDK0Isa0JBQWtCLENBQUMsSUFBSSxDQUFDekUsRUFBRTtRQUM5RCxNQUFNLElBQUksQ0FBQ3lDLE1BQU07SUFDbkI7SUFFQTs7Ozs7O0dBTUMsR0FDRCxNQUFNaUMsYUFBYUMsbUJBQW1CLEdBQUcsRUFBRUMseUJBQXlCLElBQUksRUFBRTtRQUN4RSxJQUFJQyxZQUFZOUQsS0FBSytELEdBQUc7UUFDeEIsTUFBTSxJQUFJLENBQUNyQyxNQUFNO1FBQ2pCLE1BQU8sSUFBSSxDQUFDdEMsS0FBSyxLQUFLLGNBQWMsQUFBQzBFLFlBQVlGLG1CQUFtQixPQUFRNUQsS0FBSytELEdBQUcsR0FBSTtZQUN0RixNQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDSDtZQUNsQixNQUFNLElBQUksQ0FBQ25DLE1BQU07UUFDbkI7UUFDQSxJQUFJLElBQUksQ0FBQ3RDLEtBQUssS0FBSyxZQUFZO1lBQzdCLE1BQU0sSUFBSTZFLHFCQUFZLENBQUMsbUNBQW1DLElBQUksQ0FBQ2hGLEVBQUUsR0FBRztRQUN0RTtJQUNGO0lBRUE7Ozs7OztHQU1DLEdBQ0QsTUFBTWlGLGVBQWVOLG1CQUFtQixHQUFHLEVBQUVDLHlCQUF5QixJQUFJLEVBQUU7UUFDMUUsSUFBSUMsWUFBWTlELEtBQUsrRCxHQUFHO1FBQ3hCLE1BQU0sSUFBSSxDQUFDckMsTUFBTTtRQUNqQixNQUFPLElBQUksQ0FBQ3RDLEtBQUssS0FBSyxnQkFBZ0IsQUFBQzBFLFlBQVlGLG1CQUFtQixPQUFRNUQsS0FBSytELEdBQUcsR0FBSTtZQUN4RixNQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDSDtZQUNsQixNQUFNLElBQUksQ0FBQ25DLE1BQU07UUFDbkI7UUFDQSxJQUFJLElBQUksQ0FBQ3RDLEtBQUssS0FBSyxjQUFjO1lBQy9CLE1BQU0sSUFBSTZFLHFCQUFZLENBQUMsbUNBQW1DLElBQUksQ0FBQ2hGLEVBQUUsR0FBRztRQUN0RTtJQUNGO0lBRUE7Ozs7OztHQU1DLEdBQ0QsTUFBTWtGLFlBQVlQLG1CQUFtQixHQUFHLEVBQUVDLHlCQUF5QixJQUFJLEVBQUU7UUFDdkUsSUFBSUMsWUFBWTlELEtBQUsrRCxHQUFHO1FBQ3hCLElBQUk7WUFDRixNQUFNLElBQUksQ0FBQ3JDLE1BQU07WUFDakIsTUFBT29DLFlBQVlGLG1CQUFtQixPQUFPNUQsS0FBSytELEdBQUcsR0FBSTtnQkFDdkQsTUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ0g7Z0JBQ2xCLE1BQU0sSUFBSSxDQUFDbkMsTUFBTTtZQUNuQjtZQUNBLE1BQU0sSUFBSXVDLHFCQUFZLENBQUMsbUNBQW1DLElBQUksQ0FBQ2hGLEVBQUUsR0FBRztRQUN0RSxFQUFFLE9BQU9nRSxLQUFLO1lBQ1osSUFBSUEsSUFBSWhELElBQUksS0FBSyxpQkFBaUI7Z0JBQ2hDO1lBQ0YsT0FBTztnQkFDTCxNQUFNZ0Q7WUFDUjtRQUNGO0lBQ0Y7SUFFQTs7Ozs7O0dBTUMsR0FDRCxNQUFNbUIsY0FBY1IsbUJBQW1CLEdBQUcsRUFBRUMseUJBQXlCLElBQUksRUFBRTtRQUN6RSxNQUFNUSxpQkFBaUI7WUFDckIsT0FBTztnQkFBQyxJQUFJLENBQUMvRSxnQkFBZ0I7YUFBQyxDQUFDZ0YsTUFBTSxDQUFDLElBQUksQ0FBQ2xELFFBQVEsQ0FBQ1UsR0FBRyxDQUFDTCxDQUFBQSxVQUN0REEsUUFBUW5DLGdCQUFnQixHQUFHMkMsUUFBUSxDQUFDO1FBQ3hDO1FBRUEsSUFBSTZCLFlBQVk5RCxLQUFLK0QsR0FBRztRQUN4QixNQUFNLElBQUksQ0FBQ3JDLE1BQU07UUFDakIsTUFBTyxDQUFDMkMsb0JBQW9CLEFBQUNQLFlBQVlGLG1CQUFtQixPQUFRNUQsS0FBSytELEdBQUcsR0FBSTtZQUM5RSxNQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDSDtZQUNsQixNQUFNLElBQUksQ0FBQ25DLE1BQU07UUFDbkI7UUFDQSxJQUFJLENBQUMyQyxrQkFBa0I7WUFDckIsTUFBTSxJQUFJSixxQkFBWSxDQUFDLG1DQUFtQyxJQUFJLENBQUNoRixFQUFFLEdBQUc7UUFDdEU7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0RzRix1QkFBdUJDLGNBQWMsRUFBRUMsZ0JBQWdCLEVBQUU7UUFDdkQsSUFBRyxJQUFJLENBQUNDLHVCQUF1QixDQUFDNUUsTUFBTSxJQUFJLElBQUksQ0FBQzRFLHVCQUF1QixDQUFDNUUsTUFBTSxLQUFLLElBQUksQ0FBQ0EsTUFBTSxFQUFFO1lBQzdGLE1BQU0sSUFBSTZFLDZCQUFlLENBQ3ZCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQzFGLEVBQUUsQ0FBQyw0QkFBNEIsRUFBRSxJQUFJLENBQUN5Rix1QkFBdUIsQ0FBQzVFLE1BQU0sQ0FBQyxDQUFDO1FBRTFGO1FBRUEsT0FBTyxJQUFJLENBQUMyQyxtQkFBbUIsQ0FBQ21DLGdCQUFnQixDQUFDLElBQUksRUFBRUosZ0JBQWdCQztJQUN6RTtJQUVBOzs7R0FHQyxHQUNESSxtQkFBbUI7UUFDakIsSUFBRyxJQUFJLENBQUNILHVCQUF1QixDQUFDNUUsTUFBTSxJQUFJLElBQUksQ0FBQzRFLHVCQUF1QixDQUFDNUUsTUFBTSxLQUFLLElBQUksQ0FBQ0EsTUFBTSxFQUFFO1lBQzdGLE1BQU0sSUFBSTZFLDZCQUFlLENBQ3ZCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQzFGLEVBQUUsQ0FBQyw0QkFBNEIsRUFBRSxJQUFJLENBQUN5Rix1QkFBdUIsQ0FBQzVFLE1BQU0sQ0FBQyxDQUFDO1FBRTFGO1FBQ0EsT0FBTyxJQUFJLENBQUMyQyxtQkFBbUIsQ0FBQ3FDLFVBQVUsQ0FBQyxJQUFJO0lBQ2pEO0lBRUE7Ozs7O0dBS0MsR0FDRCxNQUFNQyxPQUFPQyxPQUFPLEVBQUU7UUFDcEIsTUFBTSxJQUFJLENBQUNyRCx3QkFBd0IsQ0FBQ3NELGFBQWEsQ0FBQyxJQUFJLENBQUNoRyxFQUFFLEVBQUUrRjtRQUMzRCxNQUFNLElBQUksQ0FBQ3RELE1BQU07SUFDbkI7SUFFQTs7OztHQUlDLEdBQ0QsTUFBTXdELGNBQWNGLE9BQU8sRUFBRTtRQUMzQixNQUFNLElBQUksQ0FBQ3JELHdCQUF3QixDQUFDd0Qsb0JBQW9CLENBQUMsSUFBSSxDQUFDbEcsRUFBRSxFQUFFK0Y7UUFDbEUsTUFBTSxJQUFJLENBQUN0RCxNQUFNO1FBQ2pCLE9BQU8sSUFBSSxDQUFDTCxTQUFTLENBQUNjLElBQUksQ0FBQ2lELENBQUFBLElBQUtBLEVBQUV0RixNQUFNLEtBQUtrRixRQUFRbEYsTUFBTTtJQUM3RDtJQUVBOzs7R0FHQyxHQUNELE1BQU11RixvQkFBb0I7UUFDeEIsSUFBSSxDQUFDQywwQkFBMEI7UUFDL0IsSUFBSUMsaUJBQWlCLE1BQU0sSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0gsaUJBQWlCLENBQUMsSUFBSSxDQUFDcEcsRUFBRTtRQUM5RSxPQUFPc0csZUFBZXpELEdBQUcsQ0FBQzJELENBQUFBLElBQUssSUFBSUMsc0JBQWEsQ0FBQ0QsR0FBRyxJQUFJLENBQUN4RyxFQUFFLEVBQUUsSUFBSSxDQUFDdUcsb0JBQW9CO0lBQ3hGO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU1HLGlCQUFpQkMsUUFBUSxFQUFFO1FBQy9CLElBQUksQ0FBQ04sMEJBQTBCO1FBQy9CLElBQUlPLGdCQUFnQixNQUFNLElBQUksQ0FBQ0wsb0JBQW9CLENBQUNHLGdCQUFnQixDQUFDLElBQUksQ0FBQzFHLEVBQUUsRUFBRTJHO1FBQzlFLE9BQU8sSUFBSUYsc0JBQWEsQ0FBQ0csZUFBZSxJQUFJLENBQUM1RyxFQUFFLEVBQUUsSUFBSSxDQUFDdUcsb0JBQW9CO0lBQzVFO0lBRUE7Ozs7O0dBS0MsR0FDRCxNQUFNTSxvQkFBb0JGLFFBQVEsRUFBRUcsTUFBTSxFQUFFO1FBQzFDLElBQUksQ0FBQ1QsMEJBQTBCO1FBQy9CLE1BQU0sSUFBSSxDQUFDRSxvQkFBb0IsQ0FBQ1EsbUJBQW1CLENBQUMsSUFBSSxDQUFDL0csRUFBRSxFQUFFMkcsVUFBVUc7UUFDdkUsT0FBTyxJQUFJLENBQUNKLGdCQUFnQixDQUFDQztJQUMvQjtJQUVBOzs7Ozs7Ozs7OztHQVdDLEdBQ0RLLHFCQUFxQnpHLE1BQU0sRUFBRTBHLFNBQVMsRUFBRXBDLFNBQVMsRUFBRXFDLEtBQUssRUFBRTtRQUN4RCxPQUFPLElBQUksQ0FBQ0MsMkJBQTJCLENBQUNILG9CQUFvQixDQUFDLElBQUksQ0FBQ2hILEVBQUUsRUFBRSxJQUFJLENBQUNhLE1BQU0sRUFBRU4sUUFDakYwRyxXQUFXcEMsV0FBV3FDO0lBQzFCO0lBRUE7Ozs7Ozs7Ozs7O0dBV0MsR0FDREUsbUJBQW1CN0csTUFBTSxFQUFFc0UsU0FBUyxFQUFFd0MsTUFBTSxFQUFFSCxLQUFLLEVBQUU7UUFDbkQsT0FBTyxJQUFJLENBQUNDLDJCQUEyQixDQUFDQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUNwSCxFQUFFLEVBQUUsSUFBSSxDQUFDYSxNQUFNLEVBQUVOLFFBQVFzRSxXQUFXd0MsUUFBUUg7SUFDOUc7SUFFQTs7OztHQUlDLEdBQ0QsTUFBTUksd0JBQXdCQyxTQUFTLEVBQUU7UUFDdkMsTUFBTUMsb0JBQW9CLE1BQU0sSUFBSSxDQUFDOUUsd0JBQXdCLENBQUM0RSx1QkFBdUIsQ0FBQyxJQUFJLENBQUN0SCxFQUFFLEVBQUV1SDtRQUMvRixPQUFPQztJQUNUO0lBRUFuQiw2QkFBNkI7UUFDM0IsSUFBSSxJQUFJLENBQUM5RSxPQUFPLEtBQUssS0FBSyxJQUFJLENBQUNELElBQUksS0FBSyxZQUFZO1lBQ2xELE1BQU0sSUFBSW9FLDZCQUFlLENBQUM7UUFDNUI7SUFDRjtJQUVBWCxPQUFPMEMscUJBQXFCLEVBQUU7UUFDNUIsT0FBTyxJQUFJQyxRQUFRQyxDQUFBQSxNQUFPQyxXQUFXRCxLQUFLRjtJQUM1QztJQTVuQkE7Ozs7Ozs7OztHQVNDLEdBQ0RJLFlBQVlDLElBQUksRUFBRUMsdUJBQXVCLEVBQUVDLHNCQUFzQixFQUFFQyxrQkFBa0IsRUFBRUMsbUJBQW1CLEVBQ3hHQywwQkFBMEIsRUFBRUMsV0FBVyxDQUFFO1FBQ3pDLElBQUksQ0FBQ25JLEtBQUssR0FBRzZIO1FBQ2IsSUFBSSxDQUFDcEYsd0JBQXdCLEdBQUdxRjtRQUNoQyxJQUFJLENBQUN0Qyx1QkFBdUIsR0FBR3VDO1FBQy9CLElBQUksQ0FBQ3hFLG1CQUFtQixHQUFHeUU7UUFDM0IsSUFBSSxDQUFDMUIsb0JBQW9CLEdBQUcyQjtRQUM1QixJQUFJLENBQUNmLDJCQUEyQixHQUFHZ0I7UUFDbkMsSUFBSSxDQUFDcEUsWUFBWSxHQUFHcUU7UUFDcEIsSUFBSSxDQUFDaEcsU0FBUyxHQUFHLEFBQUMwRixDQUFBQSxLQUFLNUYsZUFBZSxJQUFJLEVBQUUsQUFBRCxFQUN4Q1csR0FBRyxDQUFDTCxDQUFBQSxVQUFXLElBQUljLGlDQUF3QixDQUFDZCxTQUFTLElBQUksRUFBRXVGO0lBQ2hFO0FBeW1CRiJ9