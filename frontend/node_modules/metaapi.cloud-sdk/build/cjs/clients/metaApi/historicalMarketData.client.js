"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return HistoricalMarketDataClient;
    }
});
const _metaApiclient = /*#__PURE__*/ _interop_require_default(require("../metaApi.client"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let HistoricalMarketDataClient = class HistoricalMarketDataClient extends _metaApiclient.default {
    /**
   * Returns historical candles for a specific symbol and timeframe from a MetaTrader account.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalCandles/
   * @param {string} accountId MetaTrader account id
   * @param {string} region account region
   * @param {string} symbol symbol to retrieve candles for (e.g. a currency pair or an index)
   * @param {string} timeframe defines the timeframe according to which the candles must be generated. Allowed values
   * for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed
   * values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {Date} [startTime] time to start loading candles from. Note that candles are loaded in backwards direction, so
   * this should be the latest time. Leave empty to request latest candles.
   * @param {number} [limit] maximum number of candles to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderCandle>>} promise resolving with historical candles downloaded
   */ async getHistoricalCandles(accountId, region, symbol, timeframe, startTime, limit) {
        symbol = encodeURIComponent(symbol);
        const host = await this._domainClient.getUrl(this._host, region);
        const opts = {
            url: `${host}/users/current/accounts/${accountId}/historical-market-data/symbols/${symbol}/` + `timeframes/${timeframe}/candles`,
            method: "GET",
            params: {
                startTime,
                limit
            },
            headers: {
                "auth-token": this._token
            },
            json: true
        };
        let candles = await this._httpClient.request(opts, "getHistoricalCandles");
        candles = candles || [];
        candles.forEach((c)=>c.time = new Date(c.time));
        return candles;
    }
    /**
   * Returns historical ticks for a specific symbol from a MetaTrader account. This API is not supported by MT4
   * accounts.
   * See https://metaapi.cloud/docs/client/restApi/api/retrieveMarketData/readHistoricalTicks/
   * @param {string} accountId MetaTrader account id
   * @param {string} region account region
   * @param {string} symbol symbol to retrieve ticks for (e.g. a currency pair or an index)
   * @param {Date} [startTime] time to start loading ticks from. Note that candles are loaded in forward direction, so
   * this should be the earliest time. Leave empty to request latest candles.
   * @param {number} [offset] number of ticks to skip (you can use it to avoid requesting ticks from previous request
   * twice)
   * @param {number} [limit] maximum number of ticks to retrieve. Must be less or equal to 1000
   * @return {Promise<Array<MetatraderTick>>} promise resolving with historical ticks downloaded
   */ async getHistoricalTicks(accountId, region, symbol, startTime, offset, limit) {
        symbol = encodeURIComponent(symbol);
        const host = await this._domainClient.getUrl(this._host, region);
        const opts = {
            url: `${host}/users/current/accounts/${accountId}/historical-market-data/symbols/${symbol}/ticks`,
            method: "GET",
            params: {
                startTime,
                offset,
                limit
            },
            headers: {
                "auth-token": this._token
            },
            json: true
        };
        let ticks = await this._httpClient.request(opts, "getHistoricalTicks");
        ticks = ticks || [];
        ticks.forEach((t)=>t.time = new Date(t.time));
        return ticks;
    }
    /**
   * Constructs historical market data API client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {DomainClient} domainClient domain client
   */ constructor(httpClient, domainClient){
        super(httpClient, domainClient);
        this._host = "https://mt-market-data-client-api-v1";
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBNZXRhQXBpQ2xpZW50IGZyb20gJy4uL21ldGFBcGkuY2xpZW50JztcblxuLyoqXG4gKiBtZXRhYXBpLmNsb3VkIGhpc3RvcmljYWwgbWFya2V0IGRhdGEgQVBJIGNsaWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCBleHRlbmRzIE1ldGFBcGlDbGllbnQge1xuICBcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgaGlzdG9yaWNhbCBtYXJrZXQgZGF0YSBBUEkgY2xpZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SHR0cENsaWVudH0gaHR0cENsaWVudCBIVFRQIGNsaWVudFxuICAgKiBAcGFyYW0ge0RvbWFpbkNsaWVudH0gZG9tYWluQ2xpZW50IGRvbWFpbiBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQsIGRvbWFpbkNsaWVudCkge1xuICAgIHN1cGVyKGh0dHBDbGllbnQsIGRvbWFpbkNsaWVudCk7XG4gICAgdGhpcy5faG9zdCA9ICdodHRwczovL210LW1hcmtldC1kYXRhLWNsaWVudC1hcGktdjEnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yaWNhbCBjYW5kbGVzIGZvciBhIHNwZWNpZmljIHN5bWJvbCBhbmQgdGltZWZyYW1lIGZyb20gYSBNZXRhVHJhZGVyIGFjY291bnQuXG4gICAqIFNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvcmVzdEFwaS9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRIaXN0b3JpY2FsQ2FuZGxlcy9cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBNZXRhVHJhZGVyIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lvbiBhY2NvdW50IHJlZ2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBjYW5kbGVzIGZvciAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lZnJhbWUgZGVmaW5lcyB0aGUgdGltZWZyYW1lIGFjY29yZGluZyB0byB3aGljaCB0aGUgY2FuZGxlcyBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXNcbiAgICogZm9yIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWRcbiAgICogdmFsdWVzIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcGFyYW0ge0RhdGV9IFtzdGFydFRpbWVdIHRpbWUgdG8gc3RhcnQgbG9hZGluZyBjYW5kbGVzIGZyb20uIE5vdGUgdGhhdCBjYW5kbGVzIGFyZSBsb2FkZWQgaW4gYmFja3dhcmRzIGRpcmVjdGlvbiwgc29cbiAgICogdGhpcyBzaG91bGQgYmUgdGhlIGxhdGVzdCB0aW1lLiBMZWF2ZSBlbXB0eSB0byByZXF1ZXN0IGxhdGVzdCBjYW5kbGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBtYXhpbXVtIG51bWJlciBvZiBjYW5kbGVzIHRvIHJldHJpZXZlLiBNdXN0IGJlIGxlc3Mgb3IgZXF1YWwgdG8gMTAwMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJDYW5kbGU+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBoaXN0b3JpY2FsIGNhbmRsZXMgZG93bmxvYWRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0SGlzdG9yaWNhbENhbmRsZXMoYWNjb3VudElkLCByZWdpb24sIHN5bWJvbCwgdGltZWZyYW1lLCBzdGFydFRpbWUsIGxpbWl0KSB7XG4gICAgc3ltYm9sID0gZW5jb2RlVVJJQ29tcG9uZW50KHN5bWJvbCk7XG4gICAgY29uc3QgaG9zdCA9IGF3YWl0IHRoaXMuX2RvbWFpbkNsaWVudC5nZXRVcmwodGhpcy5faG9zdCwgcmVnaW9uKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdXJsOiBgJHtob3N0fS91c2Vycy9jdXJyZW50L2FjY291bnRzLyR7YWNjb3VudElkfS9oaXN0b3JpY2FsLW1hcmtldC1kYXRhL3N5bWJvbHMvJHtzeW1ib2x9L2AgK1xuICAgICAgICBgdGltZWZyYW1lcy8ke3RpbWVmcmFtZX0vY2FuZGxlc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgbGltaXRcbiAgICAgIH0sXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdGhpcy5fdG9rZW5cbiAgICAgIH0sXG4gICAgICBqc29uOiB0cnVlXG4gICAgfTtcbiAgICBsZXQgY2FuZGxlcyA9IGF3YWl0IHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdChvcHRzLCAnZ2V0SGlzdG9yaWNhbENhbmRsZXMnKTtcbiAgICBjYW5kbGVzID0gY2FuZGxlcyB8fCBbXTtcbiAgICBjYW5kbGVzLmZvckVhY2goYyA9PiBjLnRpbWUgPSBuZXcgRGF0ZShjLnRpbWUpKTtcbiAgICByZXR1cm4gY2FuZGxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcmljYWwgdGlja3MgZm9yIGEgc3BlY2lmaWMgc3ltYm9sIGZyb20gYSBNZXRhVHJhZGVyIGFjY291bnQuIFRoaXMgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgTVQ0XG4gICAqIGFjY291bnRzLlxuICAgKiBTZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3Jlc3RBcGkvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkSGlzdG9yaWNhbFRpY2tzL1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIE1ldGFUcmFkZXIgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaW9uIGFjY291bnQgcmVnaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2tzIGZvciAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7RGF0ZX0gW3N0YXJ0VGltZV0gdGltZSB0byBzdGFydCBsb2FkaW5nIHRpY2tzIGZyb20uIE5vdGUgdGhhdCBjYW5kbGVzIGFyZSBsb2FkZWQgaW4gZm9yd2FyZCBkaXJlY3Rpb24sIHNvXG4gICAqIHRoaXMgc2hvdWxkIGJlIHRoZSBlYXJsaWVzdCB0aW1lLiBMZWF2ZSBlbXB0eSB0byByZXF1ZXN0IGxhdGVzdCBjYW5kbGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldF0gbnVtYmVyIG9mIHRpY2tzIHRvIHNraXAgKHlvdSBjYW4gdXNlIGl0IHRvIGF2b2lkIHJlcXVlc3RpbmcgdGlja3MgZnJvbSBwcmV2aW91cyByZXF1ZXN0XG4gICAqIHR3aWNlKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byByZXRyaWV2ZS4gTXVzdCBiZSBsZXNzIG9yIGVxdWFsIHRvIDEwMDBcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyVGljaz4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGhpc3RvcmljYWwgdGlja3MgZG93bmxvYWRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0SGlzdG9yaWNhbFRpY2tzKGFjY291bnRJZCwgcmVnaW9uLCBzeW1ib2wsIHN0YXJ0VGltZSwgb2Zmc2V0LCBsaW1pdCkge1xuICAgIHN5bWJvbCA9IGVuY29kZVVSSUNvbXBvbmVudChzeW1ib2wpO1xuICAgIGNvbnN0IGhvc3QgPSBhd2FpdCB0aGlzLl9kb21haW5DbGllbnQuZ2V0VXJsKHRoaXMuX2hvc3QsIHJlZ2lvbik7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHVybDogYCR7aG9zdH0vdXNlcnMvY3VycmVudC9hY2NvdW50cy8ke2FjY291bnRJZH0vaGlzdG9yaWNhbC1tYXJrZXQtZGF0YS9zeW1ib2xzLyR7c3ltYm9sfS90aWNrc2AsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsaW1pdFxuICAgICAgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlblxuICAgICAgfSxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuICAgIGxldCB0aWNrcyA9IGF3YWl0IHRoaXMuX2h0dHBDbGllbnQucmVxdWVzdChvcHRzLCAnZ2V0SGlzdG9yaWNhbFRpY2tzJyk7XG4gICAgdGlja3MgPSB0aWNrcyB8fCBbXTtcbiAgICB0aWNrcy5mb3JFYWNoKHQgPT4gdC50aW1lID0gbmV3IERhdGUodC50aW1lKSk7XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJIaXN0b3JpY2FsTWFya2V0RGF0YUNsaWVudCIsIk1ldGFBcGlDbGllbnQiLCJnZXRIaXN0b3JpY2FsQ2FuZGxlcyIsImFjY291bnRJZCIsInJlZ2lvbiIsInN5bWJvbCIsInRpbWVmcmFtZSIsInN0YXJ0VGltZSIsImxpbWl0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaG9zdCIsIl9kb21haW5DbGllbnQiLCJnZXRVcmwiLCJfaG9zdCIsIm9wdHMiLCJ1cmwiLCJtZXRob2QiLCJwYXJhbXMiLCJoZWFkZXJzIiwiX3Rva2VuIiwianNvbiIsImNhbmRsZXMiLCJfaHR0cENsaWVudCIsInJlcXVlc3QiLCJmb3JFYWNoIiwiYyIsInRpbWUiLCJEYXRlIiwiZ2V0SGlzdG9yaWNhbFRpY2tzIiwib2Zmc2V0IiwidGlja3MiLCJ0IiwiY29uc3RydWN0b3IiLCJodHRwQ2xpZW50IiwiZG9tYWluQ2xpZW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztlQU9xQkE7OztzRUFMSzs7Ozs7O0FBS1gsSUFBQSxBQUFNQSw2QkFBTixNQUFNQSxtQ0FBbUNDLHNCQUFhO0lBWW5FOzs7Ozs7Ozs7Ozs7O0dBYUMsR0FDRCxNQUFNQyxxQkFBcUJDLFNBQVMsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxLQUFLLEVBQUU7UUFDakZILFNBQVNJLG1CQUFtQko7UUFDNUIsTUFBTUssT0FBTyxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDQyxLQUFLLEVBQUVUO1FBQ3pELE1BQU1VLE9BQU87WUFDWEMsS0FBSyxDQUFDLEVBQUVMLEtBQUssd0JBQXdCLEVBQUVQLFVBQVUsZ0NBQWdDLEVBQUVFLE9BQU8sQ0FBQyxDQUFDLEdBQzFGLENBQUMsV0FBVyxFQUFFQyxVQUFVLFFBQVEsQ0FBQztZQUNuQ1UsUUFBUTtZQUNSQyxRQUFRO2dCQUNOVjtnQkFDQUM7WUFDRjtZQUNBVSxTQUFTO2dCQUNQLGNBQWMsSUFBSSxDQUFDQyxNQUFNO1lBQzNCO1lBQ0FDLE1BQU07UUFDUjtRQUNBLElBQUlDLFVBQVUsTUFBTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsT0FBTyxDQUFDVCxNQUFNO1FBQ25ETyxVQUFVQSxXQUFXLEVBQUU7UUFDdkJBLFFBQVFHLE9BQU8sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSSxHQUFHLElBQUlDLEtBQUtGLEVBQUVDLElBQUk7UUFDN0MsT0FBT0w7SUFDVDtJQUVBOzs7Ozs7Ozs7Ozs7O0dBYUMsR0FDRCxNQUFNTyxtQkFBbUJ6QixTQUFTLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFRSxTQUFTLEVBQUVzQixNQUFNLEVBQUVyQixLQUFLLEVBQUU7UUFDNUVILFNBQVNJLG1CQUFtQko7UUFDNUIsTUFBTUssT0FBTyxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDQyxLQUFLLEVBQUVUO1FBQ3pELE1BQU1VLE9BQU87WUFDWEMsS0FBSyxDQUFDLEVBQUVMLEtBQUssd0JBQXdCLEVBQUVQLFVBQVUsZ0NBQWdDLEVBQUVFLE9BQU8sTUFBTSxDQUFDO1lBQ2pHVyxRQUFRO1lBQ1JDLFFBQVE7Z0JBQ05WO2dCQUNBc0I7Z0JBQ0FyQjtZQUNGO1lBQ0FVLFNBQVM7Z0JBQ1AsY0FBYyxJQUFJLENBQUNDLE1BQU07WUFDM0I7WUFDQUMsTUFBTTtRQUNSO1FBQ0EsSUFBSVUsUUFBUSxNQUFNLElBQUksQ0FBQ1IsV0FBVyxDQUFDQyxPQUFPLENBQUNULE1BQU07UUFDakRnQixRQUFRQSxTQUFTLEVBQUU7UUFDbkJBLE1BQU1OLE9BQU8sQ0FBQ08sQ0FBQUEsSUFBS0EsRUFBRUwsSUFBSSxHQUFHLElBQUlDLEtBQUtJLEVBQUVMLElBQUk7UUFDM0MsT0FBT0k7SUFDVDtJQWhGQTs7OztHQUlDLEdBQ0RFLFlBQVlDLFVBQVUsRUFBRUMsWUFBWSxDQUFFO1FBQ3BDLEtBQUssQ0FBQ0QsWUFBWUM7UUFDbEIsSUFBSSxDQUFDckIsS0FBSyxHQUFHO0lBQ2Y7QUEwRUYifQ==