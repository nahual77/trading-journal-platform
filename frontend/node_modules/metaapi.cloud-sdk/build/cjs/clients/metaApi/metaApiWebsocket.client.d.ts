import TimeoutError from '../timeoutError';
import { ValidationError, NotFoundError, InternalError, UnauthorizedError, TooManyRequestsError, ForbiddenError } from '../errorHandler';
import NotSynchronizedError from './notSynchronizedError';
import NotConnectedError from './notConnectedError';
import TradeError from './tradeError';
import SynchronizationThrottler from './synchronizationThrottler';
import LatencyService from './latencyService';
import MetatraderAccount from '../../metaApi/metatraderAccount';
export * from './metaApiWebsocket.client.schemas';
/**
 * MetaApi websocket API client (see https://metaapi.cloud/docs/client/websocket/overview/)
 */
declare class MetaApiWebsocketClient {
    private _domainClient;
    private _application;
    private _domain;
    private _region;
    private _hostname;
    private _metaApi;
    private _url;
    private _requestTimeout;
    private _connectTimeout;
    private _retries;
    private _minRetryDelayInSeconds;
    private _maxRetryDelayInSeconds;
    private _maxAccountsPerInstance;
    private _subscribeCooldownInSeconds;
    private _sequentialEventProcessing;
    private _useSharedClientApi;
    private _unsubscribeThrottlingInterval;
    private _socketMinimumReconnectTimeout;
    private _latencyService;
    private _token;
    private _synchronizationListeners;
    private _latencyListeners;
    private _reconnectListeners;
    private _connectedHosts;
    private _socketInstances;
    private _socketInstancesByAccounts;
    private _regionsByAccounts;
    private _accountsByReplicaId;
    private _accountReplicas;
    private _synchronizationThrottlerOpts;
    private _subscriptionManager;
    private _statusTimers;
    private _eventQueues;
    private _synchronizationFlags;
    private _synchronizationIdByInstance;
    private _subscribeLock;
    private _firstConnect;
    private _lastRequestsTime;
    private _packetOrderer;
    private _synchronizationHashes;
    private _updateEvents;
    private _packetLogger;
    private _logger;
    private _clearAccountCacheInterval;
    private _clearInactiveSyncDataInterval;
    /**
     * @typedef MetaApiWebsocketClientOptions MetaApi websocket client options
     * @property {string} [region] region to connect
     * @property {Boolean} [disableInternalJobs] whether to not run internal interval jobs. Used for tests only
     */
    /**
     * Constructs MetaApi websocket API client instance
     * @param {MetaApi} metaApi metaApi instance
     * @param {DomainClient} domainClient domain client
     * @param {String} token authorization token
     * @param {MetaApiWebsocketClientOptions} opts websocket client options
     */
    constructor(metaApi: any, domainClient: any, token: any, opts: any);
    /**
     * Restarts the account synchronization process on an out of order packet
     * @param {String} accountId account id
     * @param {Number} instanceIndex instance index
     * @param {Number} expectedSequenceNumber expected s/n
     * @param {Number} actualSequenceNumber actual s/n
     * @param {Object} packet packet data
     * @param {Date} receivedAt time the packet was received at
     */
    onOutOfOrderPacket(accountId: any, instanceIndex: any, expectedSequenceNumber: any, actualSequenceNumber: any, packet: any, receivedAt: any): void;
    /**
     * Patch server URL for use in unit tests
     * @param {String} url patched server URL
     */
    set url(url: any);
    /**
     * Websocket client predefined region
     * @returns {String} predefined region
     */
    get region(): any;
    /**
     * Returns the list of socket instance dictionaries
     * @return {Object[]} list of socket instance dictionaries
     */
    get socketInstances(): SocketInstances;
    /**
     * Returns the dictionary of socket instances by account ids
     * @return {Object} dictionary of socket instances by account ids
     */
    get socketInstancesByAccounts(): {
        [instanceNumber: number]: {
            [accountId: string]: number;
        };
    };
    /**
     * Returns the dictionary of account replicas by region
     * @return {Object} dictionary of account replicas by region
     */
    get accountReplicas(): MetaApiWebsocketClient.AccountReplicas;
    /**
     * Returns the dictionary of primary account ids by replica ids
     * @return {Object} dictionary of primary account ids by replica ids
     */
    get accountsByReplicaId(): MetaApiWebsocketClient.AccountsByReplica;
    /**
     * Returns clear account cache job. Used for tests
     * @return {Function} clear account cache job
     */
    get clearAccountCacheJob(): any;
    /**
     * Returns latency service
     * @returns {LatencyService} latency service
     */
    get latencyService(): LatencyService;
    /**
     * Returns the list of subscribed account ids
     * @param {Number} instanceNumber instance index number
     * @param {String} socketInstanceIndex socket instance index
     * @param {String} region server region
     * @return {string[]} list of subscribed account ids
     */
    subscribedAccountIds(instanceNumber: any, socketInstanceIndex: any, region: any): any[];
    /**
     * Returns websocket client connection status
     * @param {Number} instanceNumber instance index number
     * @param {Number} socketInstanceIndex socket instance index
     * @param {String} region server region
     * @returns {Boolean} websocket client connection status
     */
    connected(instanceNumber: any, socketInstanceIndex: any, region: any): any;
    /**
     * Returns list of accounts assigned to instance
     * @param {Number} instanceNumber instance index number
     * @param {String} socketInstanceIndex socket instance index
     * @param {String} region server region
     * @returns
     */
    private _getAssignedAccounts;
    /**
     * Returns account region by id
     * @param {String} accountId account id
     * @returns {String} account region
     */
    getAccountRegion(accountId: any): string;
    /**
     * Adds account cache info
     * @param {String} accountId account id
     * @param {Object} replicas account replicas, including primary replica
     */
    addAccountCache(accountId: string, replicas: MetatraderAccount.AccountsByRegion): void;
    /**
     * Updates account cache info
     * @param {String} accountId account id
     * @param {Object} replicas account replicas
     */
    updateAccountCache(accountId: string, replicas: MetatraderAccount.AccountsByRegion): void;
    /**
     * Removes account region info
     * @param {String} accountId account id
     */
    removeAccountCache(accountId: string): void;
    /**
     * Locks subscription for a socket instance based on TooManyRequestsError metadata
     * @param {Number} instanceNumber instance index number
     * @param {String} socketInstanceIndex socket instance index
     * @param {String} region server region
     * @param {Object} metadata TooManyRequestsError metadata
     */
    lockSocketInstance(instanceNumber: any, socketInstanceIndex: any, region: any, metadata: any): Promise<void>;
    /**
     * Connects to MetaApi server via socket.io protocol
     * @param {Number} instanceNumber instance index number
     * @param {String} region server region
     * @returns {Promise} promise which resolves when connection is established
     */
    connect(instanceNumber: any, region: any): Promise<unknown>;
    /**
     * Closes connection to MetaApi server
     */
    close(): void;
    /**
     * Stops the client
     */
    stop(): void;
    /**
     * Returns account information for a specified MetaTrader account.
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {GetAccountInformationOptions} [options] additional request options
     * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
     */
    getAccountInformation(accountId: any, options: any): Promise<any>;
    /**
     * Returns positions for a specified MetaTrader account.
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {GetPositionsOptions} [options] additional request options
     * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
     */
    getPositions(accountId: any, options: any): Promise<any>;
    /**
     * Returns specific position for a MetaTrader account.
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {String} positionId position id
     * @param {GetPositionOptions} [options] additional request options
     * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
     */
    getPosition(accountId: any, positionId: any, options: any): Promise<any>;
    /**
     * Returns open orders for a specified MetaTrader account.
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {GetOrdersOptions} [options] additional request options
     * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
     */
    getOrders(accountId: any, options: any): Promise<any>;
    /**
     * Returns specific open order for a MetaTrader account.
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {String} orderId order id (ticket number)
     * @param {GetOrderOptions} [options] additional request options
     * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
     */
    getOrder(accountId: any, orderId: any, options: any): Promise<any>;
    /**
     * MetaTrader history orders search query response
     * @typedef {Object} MetatraderHistoryOrders
     * @property {Array<MetatraderOrder>} historyOrders array of history orders returned
     * @property {Boolean} synchronizing flag indicating that history order initial synchronization is still in progress
     * and thus search results may be incomplete
     */
    /**
     * Returns the history of completed orders for a specific ticket number.
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {String} ticket ticket number (order id)
     * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
     */
    getHistoryOrdersByTicket(accountId: any, ticket: any): Promise<{
        historyOrders: any;
        synchronizing: any;
    }>;
    /**
     * Returns the history of completed orders for a specific position id
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {String} positionId position id
     * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
     */
    getHistoryOrdersByPosition(accountId: any, positionId: any): Promise<{
        historyOrders: any;
        synchronizing: any;
    }>;
    /**
     * Returns the history of completed orders for a specific time range
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {Date} startTime start of time range, inclusive
     * @param {Date} endTime end of time range, exclusive
     * @param {Number} offset pagination offset, default is 0
     * @param {Number} limit pagination limit, default is 1000
     * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
     */
    getHistoryOrdersByTimeRange(accountId: any, startTime: any, endTime: any, offset?: number, limit?: number): Promise<{
        historyOrders: any;
        synchronizing: any;
    }>;
    /**
     * MetaTrader history deals search query response
     * @typedef {Object} MetatraderDeals
     * @property {Array<MetatraderDeal>} deals array of history deals returned
     * @property {Boolean} synchronizing flag indicating that deal initial synchronization is still in progress
     * and thus search results may be incomplete
     */
    /**
     * MetaTrader deal
     * @typedef {Object} MetatraderDeal
     * @property {String} id deal id (ticket number)
     * @property {String} type deal type (one of DEAL_TYPE_BUY, DEAL_TYPE_SELL, DEAL_TYPE_BALANCE, DEAL_TYPE_CREDIT,
     * DEAL_TYPE_CHARGE, DEAL_TYPE_CORRECTION, DEAL_TYPE_BONUS, DEAL_TYPE_COMMISSION, DEAL_TYPE_COMMISSION_DAILY,
     * DEAL_TYPE_COMMISSION_MONTHLY, DEAL_TYPE_COMMISSION_AGENT_DAILY, DEAL_TYPE_COMMISSION_AGENT_MONTHLY,
     * DEAL_TYPE_INTEREST, DEAL_TYPE_BUY_CANCELED, DEAL_TYPE_SELL_CANCELED, DEAL_DIVIDEND, DEAL_DIVIDEND_FRANKED,
     * DEAL_TAX). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_type
     * @property {String} entryType deal entry type (one of DEAL_ENTRY_IN, DEAL_ENTRY_OUT, DEAL_ENTRY_INOUT,
     * DEAL_ENTRY_OUT_BY). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_entry
     * @property {String} [symbol] symbol deal relates to
     * @property {Number} [magic] deal magic number, identifies the EA which initiated the deal
     * @property {Date} time time the deal was conducted at
     * @property {String} brokerTime time time the deal was conducted at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
     * @property {Number} [volume] deal volume
     * @property {Number} [price] the price the deal was conducted at
     * @property {Number} [commission] deal commission
     * @property {Number} [swap] deal swap
     * @property {Number} profit deal profit
     * @property {String} [positionId] id of position the deal relates to
     * @property {String} [orderId] id of order the deal relates to
     * @property {String} [comment] deal comment. The sum of the line lengths of the comment and the clientId
     * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
     * @property {String} [brokerComment] current comment value on broker side (possibly overriden by the broker)
     * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
     * will be present on position, history orders and history deals related to the trade. You can use this field to bind
     * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
     * comment and the clientId must be less than or equal to 26. For more information see
     * https://metaapi.cloud/docs/client/clientIdUsage/
     * @property {String} platform platform id (mt4 or mt5)
     * @property {String} [reason] optional deal execution reason. One of DEAL_REASON_CLIENT, DEAL_REASON_MOBILE,
     * DEAL_REASON_WEB, DEAL_REASON_EXPERT, DEAL_REASON_SL, DEAL_REASON_TP, DEAL_REASON_SO, DEAL_REASON_ROLLOVER,
     * DEAL_REASON_VMARGIN, DEAL_REASON_SPLIT, DEAL_REASON_UNKNOWN. See
     * https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_reason.
     * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
     * currency (USD if you did not override it)
     * @property {number} [stopLoss] deal stop loss. For MT5 opening deal this is the SL of the order opening the
     * position. For MT4 deals or MT5 closing deal this is the last known position SL.
     * @property {number} [takeProfit] deal take profit. For MT5 opening deal this is the TP of the order opening the
     * position. For MT4 deals or MT5 closing deal this is the last known position TP.
     */
    /**
     * Returns history deals with a specific ticket number
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
     * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
     */
    getDealsByTicket(accountId: any, ticket: any): Promise<{
        deals: any;
        synchronizing: any;
    }>;
    /**
     * Returns history deals for a specific position id
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {String} positionId position id
     * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
     */
    getDealsByPosition(accountId: any, positionId: any): Promise<{
        deals: any;
        synchronizing: any;
    }>;
    /**
     * Returns history deals with for a specific time range
     * @param {String} accountId id of the MetaTrader account to return information for
     * @param {Date} startTime start of time range, inclusive
     * @param {Date} endTime end of time range, exclusive
     * @param {Number} offset pagination offset, default is 0
     * @param {Number} limit pagination limit, default is 1000
     * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
     */
    getDealsByTimeRange(accountId: any, startTime: any, endTime: any, offset?: number, limit?: number): Promise<{
        deals: any;
        synchronizing: any;
    }>;
    /**
     * Clears the order and transaction history of a specified application and removes the application
     * @param {String} accountId id of the MetaTrader account to remove history and application for
     * @return {Promise} promise resolving when the history is cleared
     */
    removeApplication(accountId: any): Promise<any>;
    /**
     * MetaTrader trade response
     * @typedef {Object} MetatraderTradeResponse
     * @property {Number} numericCode numeric response code, see
     * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
     * https://book.mql4.com/appendix/errors. Response codes which indicate success are 0, 10008-10010, 10025. The rest
     * codes are errors
     * @property {String} stringCode string response code, see
     * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
     * https://book.mql4.com/appendix/errors. Response codes which indicate success are ERR_NO_ERROR,
     * TRADE_RETCODE_PLACED, TRADE_RETCODE_DONE, TRADE_RETCODE_DONE_PARTIAL, TRADE_RETCODE_NO_CHANGES. The rest codes are
     * errors.
     * @property {String} message human-readable response message
     * @property {String} orderId order id which was created/modified during the trade
     * @property {String} positionId position id which was modified during the trade
     */
    /**
     * Execute a trade on a connected MetaTrader account
     * @param {String} accountId id of the MetaTrader account to execute trade for
     * @param {MetatraderTrade} trade trade to execute (see docs for possible trade types)
     * @param {String} [application] application to use
     * @param {String} [reliability] account reliability
     * @returns {Promise<MetatraderTradeResponse>} promise resolving with trade result
     * @throws {TradeError} on trade error, check error properties for error code details
     */
    trade(accountId: any, trade: any, application: any, reliability: any): Promise<any>;
    /**
     * Creates a task that ensures the account gets subscribed to the server
     * @param {String} accountId account id to subscribe
     * @param {Number} instanceNumber instance index number
     */
    ensureSubscribe(accountId: any, instanceNumber: any): void;
    /**
     * Subscribes to the Metatrader terminal events
     * @param {String} accountId id of the MetaTrader account to subscribe to
     * @param {Number} instanceNumber instance index number
     * @returns {Promise} promise which resolves when subscription started
     */
    subscribe(accountId: any, instanceNumber: any): any;
    /**
     * Requests the terminal to start synchronization process
     * @param {String} accountId id of the MetaTrader account to synchronize
     * @param {Number} instanceIndex instance index
     * @param {String} host name of host to synchronize with
     * @param {String} synchronizationId synchronization request id
     * @param {Date} startingHistoryOrderTime from what date to start synchronizing history orders from. If not specified,
     * the entire order history will be downloaded.
     * @param {Date} startingDealTime from what date to start deal synchronization from. If not specified, then all
     * history deals will be downloaded.
     * @param {Function} getHashes function to get terminal state hashes
     * @returns {Promise} promise which resolves when synchronization started
     */
    synchronize(accountId: any, instanceIndex: any, host: any, synchronizationId: any, startingHistoryOrderTime: any, startingDealTime: any, hashes: any): Promise<boolean>;
    /**
     * Waits for server-side terminal state synchronization to complete
     * @param {String} accountId id of the MetaTrader account to synchronize
     * @param {Number} [instanceNumber] instance index number
     * @param {String} applicationPattern MetaApi application regular expression pattern, default is .*
     * @param {Number} timeoutInSeconds timeout in seconds, default is 300 seconds
     * @param {String} [application] application to synchronize with
     * @returns {Promise} promise which resolves when synchronization started
     */
    waitSynchronized(accountId: any, instanceNumber: any, applicationPattern: any, timeoutInSeconds: any, application?: any): Promise<any>;
    /**
     * Market data subscription
     * @typedef {Object} MarketDataSubscription
     * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
     * @property {string} [timeframe] when subscription type is candles, defines the timeframe according to which the
     * candles must be generated. Allowed values for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h,
     * 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
     * @property {number} [intervalInMilliseconds] defines how frequently the terminal will stream data to client. If not
     * set, then the value configured in account will be used
     */
    /**
     * Subscribes on market data of specified symbol
     * @param {String} accountId id of the MetaTrader account
     * @param {String} symbol symbol (e.g. currency pair or an index)
     * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update
     * @param {String} [reliability] account reliability
     * @returns {Promise} promise which resolves when subscription request was processed
     */
    subscribeToMarketData(accountId: any, symbol: any, subscriptions: any, reliability: any): Promise<any>;
    /**
     * Refreshes market data subscriptions on the server to prevent them from expiring
     * @param {String} accountId id of the MetaTrader account
     * @param {Number} instanceNumber instance index number
     * @param {Array} subscriptions array of subscriptions to refresh
     */
    refreshMarketDataSubscriptions(accountId: any, instanceNumber: any, subscriptions: any): Promise<any>;
    /**
     * Market data unsubscription
     * @typedef {Object} MarketDataUnsubscription
     * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
     */
    /**
     * Unsubscribes from market data of specified symbol
     * @param {String} accountId id of the MetaTrader account
     * @param {String} symbol symbol (e.g. currency pair or an index)
     * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
     * @param {String} [reliability] account reliability
     * @returns {Promise} promise which resolves when unsubscription request was processed
     */
    unsubscribeFromMarketData(accountId: any, symbol: any, subscriptions: any, reliability: any): Promise<any>;
    /**
     * Retrieves symbols available on an account
     * @param {String} accountId id of the MetaTrader account to retrieve symbols for
     * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
     */
    getSymbols(accountId: any): Promise<any>;
    /**
     * Retrieves specification for a symbol
     * @param {String} accountId id of the MetaTrader account to retrieve symbol specification for
     * @param {String} symbol symbol to retrieve specification for
     * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
     */
    getSymbolSpecification(accountId: any, symbol: any): Promise<any>;
    /**
     * Retrieves price for a symbol
     * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
     * @param {String} symbol symbol to retrieve price for
     * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
     * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
     * not set, the subscription will be set to expire in 12 minutes.
     * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
     */
    getSymbolPrice(accountId: any, symbol: any, keepSubscription?: boolean): Promise<any>;
    /**
     * Retrieves price for a symbol
     * @param {string} accountId id of the MetaTrader account to retrieve candle for
     * @param {string} symbol symbol to retrieve candle for
     * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
     * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
     * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
     * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
     * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
     * not set, the subscription will be set to expire in 12 minutes.
     * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
     */
    getCandle(accountId: any, symbol: any, timeframe: any, keepSubscription?: boolean): Promise<any>;
    /**
     * Retrieves latest tick for a symbol. MT4 G1 accounts do not support this API
     * @param {string} accountId id of the MetaTrader account to retrieve symbol tick for
     * @param {string} symbol symbol to retrieve tick for
     * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
     * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
     * not set, the subscription will be set to expire in 12 minutes.
     * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
     */
    getTick(accountId: any, symbol: any, keepSubscription?: boolean): Promise<any>;
    /**
     * Retrieves latest order book for a symbol. MT4 accounts do not support this API
     * @param {string} accountId id of the MetaTrader account to retrieve symbol order book for
     * @param {string} symbol symbol to retrieve order book for
     * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
     * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
     * not set, the subscription will be set to expire in 12 minutes.
     * @returns {Promise<MetatraderBook>} promise which resolves when order book is retrieved
     */
    getBook(accountId: any, symbol: any, keepSubscription?: boolean): Promise<any>;
    /**
     * Forces refresh of most recent quote updates for symbols subscribed to by the terminal
     * @param {string} accountId id of the MetaTrader account
     * @returns {Promise<string[]>} promise which resolves with recent quote symbols that was initiated to process
     */
    refreshTerminalState(accountId: any): Promise<any>;
    /**
     * Forces refresh and retrieves latest quotes for a subset of symbols the terminal is subscribed to
     * @param {string} accountId id of the MetaTrader account
     * @param {string[]} symbols quote symbols to refresh
     * @returns {Promise<RefreshedQuotes>} refreshed quotes and basic account information info
     */
    refreshSymbolQuotes(accountId: any, symbols: any): Promise<any>;
    /**
     * Sends client uptime stats to the server.
     * @param {String} accountId id of the MetaTrader account to save uptime
     * @param {Object} uptime uptime statistics to send to the server
     * @returns {Promise} promise which resolves when uptime statistics is submitted
     */
    saveUptime(accountId: any, uptime: any): Promise<any>;
    /**
     * Unsubscribe from account
     * @param {String} accountId id of the MetaTrader account to unsubscribe
     * @returns {Promise} promise which resolves when socket unsubscribed
     */
    unsubscribe(accountId: any): Promise<void>;
    /**
     * Current server time (see https://metaapi.cloud/docs/client/models/serverTime/)
     * @typedef {Object} ServerTime
     * @property {Date} time current server time
     * @property {String} brokerTime current broker time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
     * @property {Date} [lastQuoteTime] last quote time
     * @property {String} [lastQuoteBrokerTime] last quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
     */
    /**
     * Returns server time for a specified MetaTrader account
     * @param {string} accountId id of the MetaTrader account to return server time for
     * @returns {Promise<ServerTime>} promise resolving with server time
     */
    getServerTime(accountId: any): Promise<any>;
    /**
     * Margin required to open a trade (see https://metaapi.cloud/docs/client/models/margin/)
     * @typedef {Object} Margin
     * @property {number} [margin] margin required to open a trade. If margin can not be calculated, then this field is
     * not defined
     */
    /**
     * Contains order to calculate margin for (see https://metaapi.cloud/docs/client/models/marginOrder/)
     * @typedef {Object} MarginOrder
     * @property {string} symbol order symbol
     * @property {string} type order type, one of ORDER_TYPE_BUY or ORDER_TYPE_SELL
     * @property {number} volume order volume, must be greater than 0
     * @property {number} openPrice order open price, must be greater than 0
     */
    /**
     * Calculates margin required to open a trade on the specified trading account
     * @param {string} accountId id of the trading account to calculate margin for
     * @param {string} application application to send the request to
     * @param {string} reliability account reliability
     * @param {MarginOrder} order order to calculate margin for
     * @returns {Promise<Margin>} promise resolving with margin calculation result
     */
    calculateMargin(accountId: any, application: any, reliability: any, order: any): Promise<any>;
    /**
     * Calls onUnsubscribeRegion listener event
     * @param {String} accountId account id
     * @param {String} region account region to unsubscribe
     */
    unsubscribeAccountRegion(accountId: any, region: any): Promise<void>;
    /**
     * Adds synchronization listener for specific account
     * @param {String} accountId account id
     * @param {SynchronizationListener} listener synchronization listener to add
     */
    addSynchronizationListener(accountId: any, listener: any): void;
    /**
     * Removes synchronization listener for specific account
     * @param {String} accountId account id
     * @param {SynchronizationListener} listener synchronization listener to remove
     */
    removeSynchronizationListener(accountId: any, listener: any): void;
    /**
     * Adds latency listener
     * @param {LatencyListener} listener latency listener to add
     */
    addLatencyListener(listener: any): void;
    /**
     * Removes latency listener
     * @param {LatencyListener} listener latency listener to remove
     */
    removeLatencyListener(listener: any): void;
    /**
     * Adds reconnect listener
     * @param {ReconnectListener} listener reconnect listener to add
     * @param {String} accountId account id of listener
     */
    addReconnectListener(listener: any, accountId: any): void;
    /**
     * Removes reconnect listener
     * @param {ReconnectListener} listener listener to remove
     */
    removeReconnectListener(listener: any): void;
    /**
     * Removes all listeners. Intended for use in unit tests.
     */
    removeAllListeners(): void;
    /**
     * Clears account or replica data from client records and unsubscribes
     * @param {string} accountId account id to process the removal of
     */
    onAccountDeleted(accountId: any): void;
    /**
     * Queues an account packet for processing
     * @param {Object} packet packet to process
     */
    queuePacket(socket: MetaApiWebsocketClient.SocketInstance, packet: any): void;
    /**
     * Queues account event for processing
     * @param {String} accountId account id
     * @param {String} name event label name
     * @param {Function} callable async or regular function to execute
     */
    queueEvent(accountId: any, name: any, callable: any): void;
    _callAccountEvents(accountId: any): Promise<void>;
    _reconnect(instanceNumber: any, socketInstanceIndex: any, region: any): Promise<void>;
    _tryReconnect(instanceNumber: any, socketInstanceIndex: any, region: any): Promise<void>;
    /**
     * Simulataneously sends RPC requests to all synchronized instances
     * @param {String} accountId metatrader account id
     * @param {Object} request base request data
     * @param {String} [reliability] account reliability
     * @param {Number} [timeoutInSeconds] request timeout in seconds
     */
    rpcRequestAllInstances(accountId: any, request: any, reliability?: any, timeoutInSeconds?: any): Promise<any>;
    /**
     * Makes a RPC request
     * @param {String} accountId replica account id
     * @param {Object} request base request data
     * @param {Number} [timeoutInSeconds] request timeout in seconds
     */
    rpcRequest(accountId: string, request: any, timeoutInSeconds?: any): Promise<any>;
    private _makeRequest;
    _convertError(data: any): TimeoutError | NotFoundError | ForbiddenError | UnauthorizedError | ValidationError | InternalError | TooManyRequestsError | NotSynchronizedError | NotConnectedError | TradeError;
    _convertIsoTimeToDate(packet: any): void;
    /**
     * MetaTrader symbol price. Contains current price for a symbol (see
     * https://metaapi.cloud/docs/client/models/metatraderSymbolPrice/)
     * @typedef {Object} MetatraderSymbolPrice
     * @property {String} symbol symbol (e.g. a currency pair or an index)
     * @property {Number} bid bid price
     * @property {Number} ask ask price
     * @property {Number} profitTickValue tick value for a profitable position
     * @property {Number} lossTickValue tick value for a losing position
     * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
     * currency (USD if you did not override it)
     * @property {Date} time quote time, in ISO format
     * @property {String} brokerTime time quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
     */
    /**
     * MetaTrader candle
     * @typedef {Object} MetatraderCandle
     * @property {string} symbol symbol (e.g. currency pair or an index)
     * @property {string} timeframe timeframe candle was generated for, e.g. 1h. One of 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m,
     * 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn
     * @property {Date} time candle opening time
     * @property {string} brokerTime candle opening time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
     * @property {number} open open price
     * @property {number} high high price
     * @property {number} low low price
     * @property {number} close close price
     * @property {number} tickVolume tick volume, i.e. number of ticks inside the candle
     * @property {number} spread spread in points
     * @property {number} volume trade volume
     */
    /**
     * MetaTrader tick data
     * @typedef {Object} MetatraderTick
     * @property {string} symbol symbol (e.g. a currency pair or an index)
     * @property {Date} time time
     * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
     * @property {number} [bid] bid price
     * @property {number} [ask] ask price
     * @property {number} [last] last deal price
     * @property {number} [volume] volume for the current last deal price
     * @property {string} side is tick a result of buy or sell deal, one of buy or sell
     */
    /**
     * MetaTrader order book
     * @typedef {Object} MetatraderBook
     * @property {string} symbol symbol (e.g. a currency pair or an index)
     * @property {Date} time time
     * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
     * @property {Array<MetatraderBookEntry>} book list of order book entries
     */
    /**
     * MetaTrader order book entry
     * @typedef {Object} MetatraderBookEntry
     * @property {string} type entry type, one of BOOK_TYPE_SELL, BOOK_TYPE_BUY, BOOK_TYPE_SELL_MARKET,
     * BOOK_TYPE_BUY_MARKET
     * @property {number} price price
     * @property {number} volume volume
     */
    private _processSynchronizationPacket;
    _processEvent(callable: any, label: any, throwError?: any): Promise<void>;
    _fireReconnected(instanceNumber: any, socketInstanceIndex: any, region: any): Promise<void>;
    _getSocketInstanceByAccount(accountId: any, instanceNumber: any): MetaApiWebsocketClient.SocketInstance;
    getUrlSettings(instanceNumber: any, region: any): Promise<{
        url: any;
        isSharedClientApi: boolean;
    }>;
    private _getServerUrl;
    _throttleRequest(type: any, accountId: any, instanceNumber: any, timeInMs: any): boolean;
    _refreshAccountRegion(accountId: any): void;
    _createSocketInstanceByAccount(accountId: any, instanceNumber: any): Promise<void>;
    private _clearAccountCacheJob;
    _clearInactiveSyncDataJob(): void;
}
declare namespace MetaApiWebsocketClient {
    /** Account replicas by region (including primary replica) by primary ID */
    type AccountReplicas = {
        [primaryId: string]: MetatraderAccount.AccountsByRegion;
    };
    /**
     * Account IDs by replica
     * - keys are replica or primary account IDs
     * - values are primary account IDs
     */
    type AccountsByReplica = {
        [replicaId: string]: string;
    };
    /**
     * Socket instance
     * @todo describe fields
     */
    type SocketInstance = {
        id: number;
        reconnectWaitTime: number;
        connected: boolean;
        requestResolves: any;
        resolved: boolean;
        connectResult: Promise<any>;
        sessionId: string;
        isReconnecting: boolean;
        socket?: any;
        /** The final client API hostname the SDK has connected to behind load balancer */
        clientApiHostname?: string;
        synchronizationThrottler: SynchronizationThrottler;
        subscribeLock?: any;
        instanceNumber: number;
    };
}
export default MetaApiWebsocketClient;
type SocketInstances = {
    [region: string]: {
        [instanceNumber: number]: MetaApiWebsocketClient.SocketInstance[];
    };
};
