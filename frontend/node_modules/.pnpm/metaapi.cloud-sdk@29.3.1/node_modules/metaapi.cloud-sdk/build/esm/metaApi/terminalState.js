'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import randomstring from 'randomstring';
import SynchronizationListener from '../clients/metaApi/synchronizationListener';
import LoggerManager from '../logger';
import { ConditionPromise } from '../helpers/promises';
let TerminalState = class TerminalState extends SynchronizationListener {
    get id() {
        return this._id;
    }
    /**
   * Returns true if MetaApi have connected to MetaTrader terminal
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal
   */ get connected() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.connected, false);
    }
    /**
   * Returns true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to broker
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to
   * broker
   */ get connectedToBroker() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.connectedToBroker, false);
    }
    /**
   * Returns a local copy of account information
   * @returns {MetatraderAccountInformation} local copy of account information
   */ get accountInformation() {
        return this._combinedState.accountInformation;
    }
    /**
   * Returns a local copy of MetaTrader positions opened
   * @returns {Array<MetatraderPosition>} a local copy of MetaTrader positions opened
   */ get positions() {
        const hash = this._combinedState.positionsHash;
        return hash ? Object.values(this._terminalHashManager.getPositionsByHash(hash) || {}) : [];
    }
    /**
   * Returns a local copy of MetaTrader orders opened
   * @returns {Array<MetatraderOrder>} a local copy of MetaTrader orders opened
   */ get orders() {
        const hash = this._combinedState.ordersHash;
        return hash ? Object.values(this._terminalHashManager.getOrdersByHash(hash) || {}) : [];
    }
    /**
   * Returns a local copy of symbol specifications available in MetaTrader trading terminal
   * @returns {Array<MetatraderSymbolSpecification>} a local copy of symbol specifications available in MetaTrader
   * trading terminal
   */ get specifications() {
        const hash = this._combinedState.specificationsHash;
        return hash ? Object.values(this._terminalHashManager.getSpecificationsByHash(this._combinedState.specificationsHash) || {}) : [];
    }
    /**
   * Returns hashes of terminal state data for incremental synchronization
   * @returns {Promise<Object>} promise resolving with hashes of terminal state data
   */ // eslint-disable-next-line complexity
    getHashes() {
        const specificationsHashes = this._terminalHashManager.getLastUsedSpecificationHashes(this._account.server);
        const positionsHashes = this._terminalHashManager.getLastUsedPositionHashes(this._account.id);
        const ordersHashes = this._terminalHashManager.getLastUsedOrderHashes(this._account.id);
        return {
            specificationsHashes: specificationsHashes,
            positionsHashes: positionsHashes,
            ordersHashes: ordersHashes
        };
    }
    /**
   * Returns MetaTrader symbol specification by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolSpecification} MetatraderSymbolSpecification found or undefined if specification for a
   * symbol is not found
   */ specification(symbol) {
        if (this._combinedState.specificationsHash) {
            const state = this._terminalHashManager.getSpecificationsByHash(this._combinedState.specificationsHash);
            return state[symbol];
        } else {
            return null;
        }
    }
    /**
   * Returns MetaTrader symbol price by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolPrice} MetatraderSymbolPrice found or undefined if price for a symbol is not found
   */ price(symbol) {
        return this._combinedState.pricesBySymbol[symbol];
    }
    /**
   * Quote time
   * @typdef {Object} QuoteTime
   * @property {Date} time quote time
   * @property {String} brokerTime quote time in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */ /**
   * Returns time of the last received quote
   * @return {QuoteTime} time of the last received quote
   */ get lastQuoteTime() {
        if (this._combinedState.lastQuoteTime) {
            return {
                time: this._combinedState.lastQuoteTime,
                brokerTime: this._combinedState.lastQuoteBrokerTime
            };
        } else {
            return undefined;
        }
    }
    /**
   * Waits for price to be received
   * @param {string} symbol symbol (e.g. currency pair or an index)
   * @param {number} [timeoutInSeconds] timeout in seconds, default is 30
   * @return {Promise<MetatraderSymbolPrice>} promise resolving with price or undefined if price has not been received
   */ waitForPrice(symbol, timeoutInSeconds = 30) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._waitForPriceResolves[symbol] = _this._waitForPriceResolves[symbol] || [];
            if (!_this.price(symbol)) {
                yield Promise.race([
                    new Promise((res)=>_this._waitForPriceResolves[symbol].push(res)),
                    new Promise((res)=>setTimeout(res, timeoutInSeconds * 1000))
                ]);
            }
            return _this.price(symbol);
        })();
    }
    /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   */ onConnected(instanceIndex) {
        this._getState(instanceIndex).connected = true;
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */ onDisconnected(instanceIndex) {
        let state = this._getState(instanceIndex);
        state.connected = false;
        state.connectedToBroker = false;
    }
    /**
   * Invoked when broker connection status have changed
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} connected is MetaTrader terminal is connected to broker
   */ onBrokerConnectionStatusChanged(instanceIndex, connected) {
        this._combinedState.lastStatusTime = Date.now();
        this._getState(instanceIndex).connectedToBroker = connected;
    }
    /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {string} instanceIndex index of an account instance connected
   * @param {string} specificationsHash specifications hash
   * @param {string} positionsHash positions hash
   * @param {string} ordersHash orders hash
   * @param {string} synchronizationId synchronization id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, synchronizationId) {
        const unsynchronizedStates = this._getStateIndicesOfSameInstanceNumber(instanceIndex).filter((stateIndex)=>!this._stateByInstanceIndex[stateIndex].ordersInitialized);
        unsynchronizedStates.sort((a, b)=>b.lastSyncUpdateTime - a.lastSyncUpdateTime);
        unsynchronizedStates.slice(1).forEach((stateIndex)=>this._removeState(stateIndex));
        let state = this._getState(instanceIndex);
        state.isSpecificationsExpected = !specificationsHash;
        state.isPositionsExpected = !positionsHash;
        state.isOrdersExpected = !ordersHash;
        state.lastSyncUpdateTime = Date.now();
        state.accountInformation = undefined;
        state.pricesBySymbol = {};
        state.positions = [];
        if (!positionsHash) {
            state.positionsInitialized = false;
            state.positionsHash = null;
        } else {
            state.positionsHash = positionsHash;
        }
        state.orders = [];
        if (!ordersHash) {
            state.ordersInitialized = false;
            state.ordersHash = null;
        } else {
            state.ordersHash = ordersHash;
        }
        state.specificationsBySymbol = {};
        if (!specificationsHash) {
            this._logger.trace(()=>`${this._account.id}:${instanceIndex}:${synchronizationId}: cleared specifications ` + 'on synchronization start');
            state.specificationsHash = null;
        } else {
            this._logger.trace(()=>`${this._account.id}:${instanceIndex}:${synchronizationId}: no need to clear ` + `specifications on synchronization start, ${Object.keys(state.specificationsBySymbol || {}).length} ` + 'specifications reused');
            state.specificationsHash = specificationsHash;
        }
    }
    /**
   * Invoked when MetaTrader account information is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderAccountInformation} accountInformation updated MetaTrader account information
   */ onAccountInformationUpdated(instanceIndex, accountInformation) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        state.accountInformation = accountInformation;
        if (accountInformation) {
            this._combinedState.accountInformation = Object.assign({}, accountInformation);
        }
    }
    /**
   * Invoked when the positions are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderPosition>} positions updated array of positions
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPositionsReplaced(instanceIndex, positions) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        if (state.isPositionsExpected) {
            state.positions = positions;
        }
    }
    /**
   * Invoked when position synchronization fnished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPositionsSynchronized(instanceIndex, synchronizationId) {
        let state = this._getState(instanceIndex);
        state.positionsInitialized = true;
    }
    /**
   * Invoked when MetaTrader positions are updated
   * @param {string} instanceIndex index of an account instance connected
   * @param {MetatraderPosition[]} positions updated MetaTrader positions
   * @param {string[]} removedPositionIds removed position ids
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPositionsUpdated(instanceIndex, positions, removedPositionIds) {
        var _this = this;
        return _async_to_generator(function*() {
            let instanceState = _this._getState(instanceIndex);
            _this._refreshStateUpdateTime(instanceIndex);
            const date = Date.now();
            removedPositionIds.forEach((id)=>_this._combinedState.removedPositions[id] = date);
            positions = _this._filterRemovedPositions(positions);
            Object.keys(_this._combinedState.removedPositions).forEach((id)=>{
                if (_this._combinedState.removedPositions[id] < date - 24 * 60 * 60 * 1000) {
                    delete _this._combinedState.removedPositions[id];
                }
            });
            if (instanceState.ordersInitialized) {
                const updatePositions = function() {
                    var _ref = _async_to_generator(function*(state, instance) {
                        const hash = yield _this._terminalHashManager.updatePositions(_this._account.id, _this._account.type, _this._id, instance, positions, removedPositionIds, state.positionsHash);
                        state.positionsHash = hash;
                    });
                    return function updatePositions(state, instance) {
                        return _ref.apply(this, arguments);
                    };
                }();
                yield updatePositions(instanceState, instanceIndex);
                yield updatePositions(_this._combinedState, _this._combinedInstanceIndex);
            } else {
                instanceState.positions = instanceState.positions.filter((position)=>!removedPositionIds.includes(position.id));
                positions.forEach((position)=>{
                    let index = instanceState.positions.findIndex((p)=>p.id === position.id);
                    if (index !== -1) {
                        instanceState.positions[index] = position;
                    } else {
                        instanceState.positions.push(position);
                    }
                });
            }
        })();
    }
    /**
   * Invoked when the orders are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderOrder>} orders updated array of pending orders
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPendingOrdersReplaced(instanceIndex, orders) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        if (state.isOrdersExpected) {
            state.orders = orders;
        }
    }
    /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ // eslint-disable-next-line complexity, max-statements
    onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            state.positionsInitialized = true;
            state.ordersInitialized = true;
            _this._combinedState.accountInformation = state.accountInformation ? Object.assign({}, state.accountInformation) : undefined;
            state.positions = _this._filterRemovedPositions(state.positions);
            if (state.positions.length) {
                const hash = _this._terminalHashManager.recordPositions(_this._account.id, _this._account.type, _this._id, instanceIndex, state.positions);
                state.positionsHash = hash;
                _this._combinedState.positions = (state.positions || []).map((p)=>Object.assign({}, p));
                _this._combinedState.positionsHash = hash;
            } else if (state.positionsHash) {
                _this._terminalHashManager.removePositionReference(_this.id, instanceIndex);
                _this._terminalHashManager.addPositionReference(state.positionsHash, _this.id, instanceIndex);
                _this._combinedState.positionsHash = state.positionsHash;
                _this._terminalHashManager.removePositionReference(_this.id, _this._combinedInstanceIndex);
                _this._terminalHashManager.addPositionReference(state.positionsHash, _this.id, _this._combinedInstanceIndex);
            }
            state.orders = _this._filterRemovedOrders(state.orders);
            if (state.orders.length) {
                const hash = _this._terminalHashManager.recordOrders(_this._account.id, _this._account.type, _this._id, instanceIndex, state.orders);
                state.ordersHash = hash;
                _this._combinedState.orders = (state.orders || []).map((o)=>Object.assign({}, o));
                _this._combinedState.ordersHash = hash;
            } else if (state.ordersHash) {
                _this._terminalHashManager.removeOrderReference(_this.id, instanceIndex);
                _this._terminalHashManager.addOrderReference(state.ordersHash, _this.id, instanceIndex);
                _this._combinedState.ordersHash = state.ordersHash;
                _this._terminalHashManager.removeOrderReference(_this.id, _this._combinedInstanceIndex);
                _this._terminalHashManager.addOrderReference(state.ordersHash, _this.id, _this._combinedInstanceIndex);
            }
            _this._logger.trace(()=>`${_this._account.id}:${instanceIndex}:${synchronizationId}: assigned specifications to ` + 'combined state from ' + `${instanceIndex}, ${Object.keys(state.specificationsBySymbol || {}).length} specifications assigned`);
            _this._combinedState.positionsInitialized = true;
            _this._combinedState.ordersInitialized = true;
            if (Object.keys(state.specificationsBySymbol || {}).length) {
                if (state.isSpecificationsExpected) {
                    const hash = yield _this._terminalHashManager.recordSpecifications(_this._account.server, _this._account.type, _this._id, instanceIndex, Object.values(state.specificationsBySymbol));
                    _this._combinedState.specificationsHash = hash;
                    state.specificationsHash = hash;
                    state.specificationsBySymbol = null;
                } else if (state.specificationsHash) {
                    const hash = yield _this._terminalHashManager.updateSpecifications(_this._account.server, _this._account.type, _this._id, instanceIndex, Object.values(state.specificationsBySymbol), [], state.specificationsHash);
                    state.specificationsHash = hash;
                }
            } else if (state.specificationsHash) {
                _this._terminalHashManager.removeSpecificationReference(_this.id, instanceIndex);
                _this._terminalHashManager.addSpecificationReference(state.specificationsHash, _this.id, instanceIndex);
                _this._combinedState.specificationsHash = state.specificationsHash;
                _this._terminalHashManager.removeSpecificationReference(_this.id, _this._combinedInstanceIndex);
                _this._terminalHashManager.addSpecificationReference(state.specificationsHash, _this.id, _this._combinedInstanceIndex);
            }
            for (let stateIndex of _this._getStateIndicesOfSameInstanceNumber(instanceIndex)){
                if (!_this._stateByInstanceIndex[stateIndex].connected) {
                    _this._removeState(stateIndex);
                }
            }
        })();
    }
    /**
   * Invoked when MetaTrader pending orders are updated or completed
   * @param {string} instanceIndex index of an account instance connected
   * @param {MetatraderOrder[]} orders updated MetaTrader pending orders
   * @param {string[]} completedOrderIds completed MetaTrader pending order ids
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPendingOrdersUpdated(instanceIndex, orders, completedOrderIds) {
        var _this = this;
        return _async_to_generator(function*() {
            let instanceState = _this._getState(instanceIndex);
            _this._refreshStateUpdateTime(instanceIndex);
            const date = Date.now();
            completedOrderIds.forEach((id)=>_this._combinedState.completedOrders[id] = date);
            orders = _this._filterRemovedOrders(orders);
            Object.keys(_this._combinedState.completedOrders).forEach((id)=>{
                if (_this._combinedState.completedOrders[id] < date - 24 * 60 * 60 * 1000) {
                    delete _this._combinedState.completedOrders[id];
                }
            });
            if (instanceState.ordersInitialized) {
                const updatePendingOrders = function() {
                    var _ref = _async_to_generator(function*(state, instance) {
                        const hash = yield _this._terminalHashManager.updateOrders(_this._account.id, _this._account.type, _this._id, instance, orders, completedOrderIds, state.ordersHash);
                        state.ordersHash = hash;
                    });
                    return function updatePendingOrders(state, instance) {
                        return _ref.apply(this, arguments);
                    };
                }();
                yield updatePendingOrders(instanceState, instanceIndex);
                yield updatePendingOrders(_this._combinedState, _this._combinedInstanceIndex);
            } else {
                instanceState.orders = instanceState.orders.filter((order)=>!completedOrderIds.includes(order.id));
                orders.forEach((order)=>{
                    let index = instanceState.orders.findIndex((o)=>o.id === order.id);
                    if (index !== -1) {
                        instanceState.orders[index] = order;
                    } else {
                        instanceState.orders.push(order);
                    }
                });
            }
        })();
    }
    /**
   * Invoked when a symbol specification was updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */ onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
        var _this = this;
        return _async_to_generator(function*() {
            let instanceState = _this._getState(instanceIndex);
            _this._refreshStateUpdateTime(instanceIndex);
            if (!instanceState.ordersInitialized) {
                for (let specification of specifications){
                    instanceState.specificationsBySymbol[specification.symbol] = specification;
                }
            } else {
                const hash = _this._terminalHashManager.updateSpecifications(_this._account.server, _this._account.type, _this._id, instanceIndex, specifications, removedSymbols, instanceState.specificationsHash);
                instanceState.specificationsHash = hash;
                const combinedHash = _this._terminalHashManager.updateSpecifications(_this._account.server, _this._account.type, _this._id, _this._combinedInstanceIndex, specifications, removedSymbols, _this._combinedState.specificationsHash);
                _this._combinedState.specificationsHash = combinedHash;
            }
            _this._logger.trace(()=>`${_this._account.id}:${instanceIndex}: updated ${specifications.length} specifications, ` + `removed ${removedSymbols.length} specifications. There are ` + `${Object.keys(instanceState.specificationsBySymbol || {}).length} specifications after update`);
        })();
    }
    /**
   * Invoked when prices for several symbols were updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderSymbolPrice>} prices updated MetaTrader symbol prices
   * @param {Number} equity account liquidation value
   * @param {Number} margin margin used
   * @param {Number} freeMargin free margin
   * @param {Number} marginLevel margin level calculated as % of equity/margin
   */ // eslint-disable-next-line complexity
    onSymbolPricesUpdated(instanceIndex, prices, equity, margin, freeMargin, marginLevel) {
        let instanceState = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        // eslint-disable-next-line complexity,max-statements
        const updateSymbolPrices = (state)=>{
            let pricesInitialized = false;
            let priceUpdated = false;
            for (let price of prices || []){
                let currentPrice = state.pricesBySymbol[price.symbol];
                if (currentPrice && currentPrice.time.getTime() > price.time.getTime()) {
                    continue;
                } else {
                    priceUpdated = true;
                }
                if (!state.lastQuoteTime || state.lastQuoteTime.getTime() < price.time.getTime()) {
                    state.lastQuoteTime = price.time;
                    state.lastQuoteBrokerTime = price.brokerTime;
                }
                state.pricesBySymbol[price.symbol] = price;
                const allPositions = Object.values(this._terminalHashManager.getPositionsByHash(state.positionsHash) || {});
                const allOrders = Object.values(this._terminalHashManager.getOrdersByHash(state.ordersHash) || {});
                let positions = allPositions.filter((p)=>p.symbol === price.symbol);
                let otherPositions = allPositions.filter((p)=>p.symbol !== price.symbol);
                let orders = allOrders.filter((o)=>o.symbol === price.symbol);
                pricesInitialized = true;
                for (let position of otherPositions){
                    let p = state.pricesBySymbol[position.symbol];
                    if (p) {
                        if (position.unrealizedProfit === undefined) {
                            this._updatePositionProfits(position, p);
                        }
                    } else {
                        pricesInitialized = false;
                    }
                }
                for (let position of positions){
                    this._updatePositionProfits(position, price);
                }
                for (let order of orders){
                    order.currentPrice = order.type === 'ORDER_TYPE_BUY' || order.type === 'ORDER_TYPE_BUY_LIMIT' || order.type === 'ORDER_TYPE_BUY_STOP' || order.type === 'ORDER_TYPE_BUY_STOP_LIMIT' ? price.ask : price.bid;
                }
                let priceResolves = this._waitForPriceResolves[price.symbol] || [];
                if (priceResolves.length) {
                    for (let resolve of priceResolves){
                        resolve();
                    }
                    delete this._waitForPriceResolves[price.symbol];
                }
            }
            if (priceUpdated && state.accountInformation) {
                const positions = Object.values(this._terminalHashManager.getPositionsByHash(state.positionsHash) || {});
                if (state.positionsInitialized && pricesInitialized) {
                    if (state.accountInformation.platform === 'mt5') {
                        state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + positions.reduce((acc, p)=>acc + Math.round((p.unrealizedProfit || 0) * 100) / 100 + Math.round((p.swap || 0) * 100) / 100, 0);
                    } else {
                        state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + positions.reduce((acc, p)=>acc + Math.round((p.swap || 0) * 100) / 100 + Math.round((p.commission || 0) * 100) / 100 + Math.round((p.unrealizedProfit || 0) * 100) / 100, 0);
                    }
                    state.accountInformation.equity = Math.round(state.accountInformation.equity * 100) / 100;
                } else {
                    state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.equity;
                }
                var _prices__accountCurrencyExchangeRate;
                state.accountInformation.accountCurrencyExchangeRate = (_prices__accountCurrencyExchangeRate = prices[0].accountCurrencyExchangeRate) !== null && _prices__accountCurrencyExchangeRate !== void 0 ? _prices__accountCurrencyExchangeRate : state.accountInformation.accountCurrencyExchangeRate;
                state.accountInformation.margin = margin !== undefined ? margin : state.accountInformation.margin;
                state.accountInformation.freeMargin = freeMargin !== undefined ? freeMargin : state.accountInformation.freeMargin;
                state.accountInformation.marginLevel = freeMargin !== undefined ? marginLevel : state.accountInformation.marginLevel;
            }
        };
        updateSymbolPrices(instanceState);
        updateSymbolPrices(this._combinedState);
        for (let price of prices){
            for (let call of Object.values(this._processThrottledQuotesCalls)){
                var _call_expectedSymbols;
                this._logger.trace(`${this._account.id}:${instanceIndex}: refreshed ${price.symbol} price`);
                (_call_expectedSymbols = call.expectedSymbols) === null || _call_expectedSymbols === void 0 ? void 0 : _call_expectedSymbols.delete(price.symbol);
                call.receivedSymbols.add(price.symbol);
                call.promise.check();
            }
        }
    }
    /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onStreamClosed(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._stateByInstanceIndex[instanceIndex]) {
                for (let stateIndex of _this._getStateIndicesOfSameInstanceNumber(instanceIndex)){
                    const instanceState = _this._stateByInstanceIndex[stateIndex];
                    if (!_this._stateByInstanceIndex[instanceIndex].ordersInitialized && _this._stateByInstanceIndex[instanceIndex].lastSyncUpdateTime <= instanceState.lastSyncUpdateTime) {
                        _this._removeState(instanceIndex);
                        break;
                    }
                    if (instanceState.connected && instanceState.ordersInitialized) {
                        _this._removeState(instanceIndex);
                        break;
                    }
                }
            }
        })();
    }
    /**
   * Forces refresh of most recent quote updates for symbols subscribed to by the terminal, and waits for them all to
   * be processed by this terminal state. This method does not waits for all other listeners to receive and process the
   * quote updates
   * @param {RefreshTerminalStateOptions} [options] additional options
   * @returns {Promise} promise resolving when the terminal state received and processed the latest quotes
   */ refreshTerminalState(options) {
        var _this = this;
        return _async_to_generator(function*() {
            let callData = {
                receivedSymbols: new Set()
            };
            let callId = randomstring.generate(8);
            _this._processThrottledQuotesCalls[callId] = callData;
            callData.promise = new ConditionPromise(()=>callData.expectedSymbols && !callData.expectedSymbols.size);
            var _options_timeoutInSeconds;
            callData.promise.timeout(1000 * ((_options_timeoutInSeconds = options === null || options === void 0 ? void 0 : options.timeoutInSeconds) !== null && _options_timeoutInSeconds !== void 0 ? _options_timeoutInSeconds : 10), 'refreshing terminal state timed out');
            try {
                let symbols = yield Promise.race([
                    _this._websocketClient.refreshTerminalState(_this._account.id),
                    callData.promise // will only throw timeout error at this point
                ]);
                _this._logger.debug(`${_this._account.id}: expecting for ${symbols.length ? symbols : 0} symbols to refresh`);
                let expectedSymbols = new Set();
                for (let symbol of symbols){
                    if (!callData.receivedSymbols.has(symbol)) {
                        expectedSymbols.add(symbol);
                    }
                }
                callData.expectedSymbols = expectedSymbols;
                callData.promise.check();
                yield callData.promise;
            } finally{
                delete _this._processThrottledQuotesCalls[callId];
            }
        })();
    }
    /**
   * Removes connection related data from terminal hash manager
   */ close() {
        clearInterval(this._checkCombinedStateActivityJobInterval);
        Object.keys(this._stateByInstanceIndex).forEach((instanceIndex)=>{
            this._removeFromHashManager(instanceIndex);
        });
        this._removeFromHashManager(this._combinedInstanceIndex);
    }
    // resets combined state and removes from hash manager if has been disconnected for a long time
    _checkCombinedStateActivityJob() {
        if (!this.connectedToBroker && this._combinedState.lastStatusTime < Date.now() - 30 * 60 * 1000) {
            this._removeFromHashManager(this._combinedInstanceIndex);
            this._combinedState.accountInformation = undefined;
            this._combinedState.specificationsBySymbol = null;
            this._combinedState.pricesBySymbol = {};
            this._combinedState.specificationsHash = null;
            this._combinedState.orders = [];
            this._combinedState.ordersHash = null;
            this._combinedState.positions = [];
            this._combinedState.positionsHash = null;
            this._combinedState.ordersInitialized = false;
            this._combinedState.positionsInitialized = false;
            this._combinedState.lastStatusTime = 0;
            this._combinedState.lastQuoteTime = undefined;
            this._combinedState.lastQuoteBrokerTime = undefined;
        }
    }
    _removeState(instanceIndex) {
        delete this._stateByInstanceIndex[instanceIndex];
        this._removeFromHashManager(instanceIndex);
    }
    _removeFromHashManager(instanceIndex) {
        this._terminalHashManager.removeConnectionReferences(this._account.server, this._account.id, this._id, instanceIndex);
    }
    _refreshStateUpdateTime(instanceIndex) {
        const state = this._stateByInstanceIndex[instanceIndex];
        if (state && state.ordersInitialized) {
            state.lastSyncUpdateTime = Date.now();
        }
    }
    _getStateIndicesOfSameInstanceNumber(instanceIndex) {
        const region = instanceIndex.split(':')[0];
        const instanceNumber = instanceIndex.split(':')[1];
        return Object.keys(this._stateByInstanceIndex).filter((stateInstanceIndex)=>stateInstanceIndex.startsWith(`${region}:${instanceNumber}:`) && instanceIndex !== stateInstanceIndex);
    }
    // eslint-disable-next-line complexity
    _updatePositionProfits(position, price) {
        let specification = this.specification(position.symbol);
        if (specification) {
            let multiplier = Math.pow(10, specification.digits);
            if (position.profit !== undefined) {
                position.profit = Math.round(position.profit * multiplier) / multiplier;
            }
            if (position.unrealizedProfit === undefined || position.realizedProfit === undefined) {
                position.unrealizedProfit = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (position.currentPrice - position.openPrice) * position.currentTickValue * position.volume / specification.tickSize;
                position.unrealizedProfit = Math.round(position.unrealizedProfit * multiplier) / multiplier;
                position.realizedProfit = position.profit - position.unrealizedProfit;
            }
            let newPositionPrice = position.type === 'POSITION_TYPE_BUY' ? price.bid : price.ask;
            let isProfitable = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (newPositionPrice - position.openPrice);
            let currentTickValue = isProfitable > 0 ? price.profitTickValue : price.lossTickValue;
            let unrealizedProfit = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (newPositionPrice - position.openPrice) * currentTickValue * position.volume / specification.tickSize;
            unrealizedProfit = Math.round(unrealizedProfit * multiplier) / multiplier;
            position.unrealizedProfit = unrealizedProfit;
            position.profit = position.unrealizedProfit + position.realizedProfit;
            position.profit = Math.round(position.profit * multiplier) / multiplier;
            position.currentPrice = newPositionPrice;
            position.currentTickValue = currentTickValue;
        }
    }
    _filterRemovedPositions(positions) {
        return positions.filter((position)=>!this._combinedState.removedPositions[position.id]);
    }
    _filterRemovedOrders(orders) {
        return orders.filter((order)=>!this._combinedState.completedOrders[order.id]);
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex['' + instanceIndex]) {
            this._logger.trace(`${this._account.id}:${instanceIndex}: constructed new state`);
            this._stateByInstanceIndex['' + instanceIndex] = this._constructTerminalState(instanceIndex);
        }
        return this._stateByInstanceIndex['' + instanceIndex];
    }
    _constructTerminalState(instanceIndex) {
        return {
            instanceIndex,
            connected: false,
            connectedToBroker: false,
            accountInformation: undefined,
            positions: [],
            orders: [],
            specificationsBySymbol: {},
            pricesBySymbol: {},
            ordersInitialized: false,
            positionsInitialized: false,
            lastSyncUpdateTime: 0,
            positionsHash: null,
            ordersHash: null,
            specificationsHash: null,
            isSpecificationsExpected: true,
            isPositionsExpected: true,
            isOrdersExpected: true,
            lastQuoteTime: undefined,
            lastQuoteBrokerTime: undefined
        };
    }
    /**
   * Constructs the instance of terminal state class
   * @param {MetatraderAccount} account mt account
   * @param {TerminalHashManager} terminalHashManager terminal hash manager
   * @param {MetaApiWebsocketClient} websocketClient websocket client
   */ constructor(account, terminalHashManager, websocketClient){
        super();
        this._id = randomstring.generate(32);
        this._account = account;
        this._terminalHashManager = terminalHashManager;
        this._websocketClient = websocketClient;
        this._stateByInstanceIndex = {};
        this._waitForPriceResolves = {};
        this._combinedInstanceIndex = 'combined';
        this._combinedState = {
            accountInformation: undefined,
            positions: [],
            orders: [],
            specificationsBySymbol: null,
            pricesBySymbol: {},
            removedPositions: {},
            completedOrders: {},
            specificationsHash: null,
            positionsHash: null,
            ordersHash: null,
            ordersInitialized: false,
            positionsInitialized: false,
            lastStatusTime: 0,
            lastQuoteTime: undefined,
            lastQuoteBrokerTime: undefined
        };
        this._processThrottledQuotesCalls = {};
        this._logger = LoggerManager.getLogger('TerminalState');
        this._checkCombinedStateActivityJob = this._checkCombinedStateActivityJob.bind(this);
        this._checkCombinedStateActivityJobInterval = setInterval(this._checkCombinedStateActivityJob, 5 * 60 * 1000);
    }
};
/**
 * Responsible for storing a local copy of remote terminal state
 */ export { TerminalState as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciBmcm9tICcuLi9jbGllbnRzL21ldGFBcGkvc3luY2hyb25pemF0aW9uTGlzdGVuZXInO1xuaW1wb3J0IE1ldGFBcGlXZWJzb2NrZXRDbGllbnQgZnJvbSAnLi4vY2xpZW50cy9tZXRhQXBpL21ldGFBcGlXZWJzb2NrZXQuY2xpZW50JztcbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgVGVybWluYWxIYXNoTWFuYWdlciBmcm9tICcuL3Rlcm1pbmFsSGFzaE1hbmFnZXInO1xuaW1wb3J0IE1ldGF0cmFkZXJBY2NvdW50IGZyb20gJy4vbWV0YXRyYWRlckFjY291bnQnO1xuaW1wb3J0IHtDb25kaXRpb25Qcm9taXNlfSBmcm9tICcuLi9oZWxwZXJzL3Byb21pc2VzJztcblxuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhIGxvY2FsIGNvcHkgb2YgcmVtb3RlIHRlcm1pbmFsIHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsU3RhdGUgZXh0ZW5kcyBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlIG9mIHRlcm1pbmFsIHN0YXRlIGNsYXNzXG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnR9IGFjY291bnQgbXQgYWNjb3VudFxuICAgKiBAcGFyYW0ge1Rlcm1pbmFsSGFzaE1hbmFnZXJ9IHRlcm1pbmFsSGFzaE1hbmFnZXIgdGVybWluYWwgaGFzaCBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gd2Vic29ja2V0Q2xpZW50IHdlYnNvY2tldCBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFjY291bnQsIHRlcm1pbmFsSGFzaE1hbmFnZXIsIHdlYnNvY2tldENsaWVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX2FjY291bnQgPSBhY2NvdW50O1xuICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIgPSB0ZXJtaW5hbEhhc2hNYW5hZ2VyO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudCA9IHdlYnNvY2tldENsaWVudDtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICAgIHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzID0ge307XG4gICAgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4ID0gJ2NvbWJpbmVkJztcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlID0ge1xuICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgb3JkZXJzOiBbXSxcbiAgICAgIHNwZWNpZmljYXRpb25zQnlTeW1ib2w6IG51bGwsXG4gICAgICBwcmljZXNCeVN5bWJvbDoge30sXG4gICAgICByZW1vdmVkUG9zaXRpb25zOiB7fSxcbiAgICAgIGNvbXBsZXRlZE9yZGVyczoge30sXG4gICAgICBzcGVjaWZpY2F0aW9uc0hhc2g6IG51bGwsXG4gICAgICBwb3NpdGlvbnNIYXNoOiBudWxsLFxuICAgICAgb3JkZXJzSGFzaDogbnVsbCxcbiAgICAgIG9yZGVyc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIGxhc3RTdGF0dXNUaW1lOiAwLFxuICAgICAgbGFzdFF1b3RlVGltZTogdW5kZWZpbmVkLFxuICAgICAgbGFzdFF1b3RlQnJva2VyVGltZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHMgPSB7fTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignVGVybWluYWxTdGF0ZScpO1xuICAgIHRoaXMuX2NoZWNrQ29tYmluZWRTdGF0ZUFjdGl2aXR5Sm9iID0gdGhpcy5fY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2IuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jaGVja0NvbWJpbmVkU3RhdGVBY3Rpdml0eUpvYkludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5fY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2IsIDUgKiA2MCAqIDEwMDApO1xuICB9XG5cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgTWV0YUFwaSBoYXZlIGNvbm5lY3RlZCB0byBNZXRhVHJhZGVyIHRlcm1pbmFsXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgTWV0YUFwaSBoYXZlIGNvbm5lY3RlZCB0byBNZXRhVHJhZGVyIHRlcm1pbmFsXG4gICAqL1xuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5yZWR1Y2UoKGFjYywgcykgPT4gYWNjIHx8IHMuY29ubmVjdGVkLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIE1ldGFBcGkgaGF2ZSBjb25uZWN0ZWQgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBhbmQgTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb25uZWN0ZWQgdG8gYnJva2VyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgTWV0YUFwaSBoYXZlIGNvbm5lY3RlZCB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIGFuZCBNZXRhVHJhZGVyIHRlcm1pbmFsIGlzIGNvbm5lY3RlZCB0b1xuICAgKiBicm9rZXJcbiAgICovXG4gIGdldCBjb25uZWN0ZWRUb0Jyb2tlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IGFjYyB8fCBzLmNvbm5lY3RlZFRvQnJva2VyLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsIGNvcHkgb2YgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbn0gbG9jYWwgY29weSBvZiBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqL1xuICBnZXQgYWNjb3VudEluZm9ybWF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21iaW5lZFN0YXRlLmFjY291bnRJbmZvcm1hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWwgY29weSBvZiBNZXRhVHJhZGVyIHBvc2l0aW9ucyBvcGVuZWRcbiAgICogQHJldHVybnMge0FycmF5PE1ldGF0cmFkZXJQb3NpdGlvbj59IGEgbG9jYWwgY29weSBvZiBNZXRhVHJhZGVyIHBvc2l0aW9ucyBvcGVuZWRcbiAgICovXG4gIGdldCBwb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2NvbWJpbmVkU3RhdGUucG9zaXRpb25zSGFzaDtcbiAgICByZXR1cm4gaGFzaCA/IE9iamVjdC52YWx1ZXModGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRQb3NpdGlvbnNCeUhhc2goaGFzaCkgfHwge30pIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsIGNvcHkgb2YgTWV0YVRyYWRlciBvcmRlcnMgb3BlbmVkXG4gICAqIEByZXR1cm5zIHtBcnJheTxNZXRhdHJhZGVyT3JkZXI+fSBhIGxvY2FsIGNvcHkgb2YgTWV0YVRyYWRlciBvcmRlcnMgb3BlbmVkXG4gICAqL1xuICBnZXQgb3JkZXJzKCkge1xuICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0hhc2g7XG4gICAgcmV0dXJuIGhhc2ggPyBPYmplY3QudmFsdWVzKHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0T3JkZXJzQnlIYXNoKGhhc2gpIHx8IHt9KSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIHN5bWJvbCBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgaW4gTWV0YVRyYWRlciB0cmFkaW5nIHRlcm1pbmFsXG4gICAqIEByZXR1cm5zIHtBcnJheTxNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbj59IGEgbG9jYWwgY29weSBvZiBzeW1ib2wgc3BlY2lmaWNhdGlvbnMgYXZhaWxhYmxlIGluIE1ldGFUcmFkZXJcbiAgICogdHJhZGluZyB0ZXJtaW5hbFxuICAgKi9cbiAgZ2V0IHNwZWNpZmljYXRpb25zKCkge1xuICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaDtcbiAgICByZXR1cm4gaGFzaCA/IE9iamVjdC52YWx1ZXModGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRTcGVjaWZpY2F0aW9uc0J5SGFzaChcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKSB8fCB7fSkgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhhc2hlcyBvZiB0ZXJtaW5hbCBzdGF0ZSBkYXRhIGZvciBpbmNyZW1lbnRhbCBzeW5jaHJvbml6YXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBoYXNoZXMgb2YgdGVybWluYWwgc3RhdGUgZGF0YVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgZ2V0SGFzaGVzKCkge1xuICAgIGNvbnN0IHNwZWNpZmljYXRpb25zSGFzaGVzID0gdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRMYXN0VXNlZFNwZWNpZmljYXRpb25IYXNoZXModGhpcy5fYWNjb3VudC5zZXJ2ZXIpO1xuICAgIGNvbnN0IHBvc2l0aW9uc0hhc2hlcyA9IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0TGFzdFVzZWRQb3NpdGlvbkhhc2hlcyh0aGlzLl9hY2NvdW50LmlkKTtcbiAgICBjb25zdCBvcmRlcnNIYXNoZXMgPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldExhc3RVc2VkT3JkZXJIYXNoZXModGhpcy5fYWNjb3VudC5pZCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3BlY2lmaWNhdGlvbnNIYXNoZXM6IHNwZWNpZmljYXRpb25zSGFzaGVzLFxuICAgICAgcG9zaXRpb25zSGFzaGVzOiBwb3NpdGlvbnNIYXNoZXMsXG4gICAgICBvcmRlcnNIYXNoZXM6IG9yZGVyc0hhc2hlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNZXRhVHJhZGVyIHN5bWJvbCBzcGVjaWZpY2F0aW9uIGJ5IHN5bWJvbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcmV0dXJuIHtNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbn0gTWV0YXRyYWRlclN5bWJvbFNwZWNpZmljYXRpb24gZm91bmQgb3IgdW5kZWZpbmVkIGlmIHNwZWNpZmljYXRpb24gZm9yIGFcbiAgICogc3ltYm9sIGlzIG5vdCBmb3VuZFxuICAgKi9cbiAgc3BlY2lmaWNhdGlvbihzeW1ib2wpIHtcbiAgICBpZih0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldFNwZWNpZmljYXRpb25zQnlIYXNoKFxuICAgICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCk7XG4gICAgICByZXR1cm4gc3RhdGVbc3ltYm9sXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YVRyYWRlciBzeW1ib2wgcHJpY2UgYnkgc3ltYm9sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJTeW1ib2xQcmljZX0gTWV0YXRyYWRlclN5bWJvbFByaWNlIGZvdW5kIG9yIHVuZGVmaW5lZCBpZiBwcmljZSBmb3IgYSBzeW1ib2wgaXMgbm90IGZvdW5kXG4gICAqL1xuICBwcmljZShzeW1ib2wpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tYmluZWRTdGF0ZS5wcmljZXNCeVN5bWJvbFtzeW1ib2xdO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1b3RlIHRpbWVcbiAgICogQHR5cGRlZiB7T2JqZWN0fSBRdW90ZVRpbWVcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHF1b3RlIHRpbWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgcXVvdGUgdGltZSBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyB0aW1lIG9mIHRoZSBsYXN0IHJlY2VpdmVkIHF1b3RlXG4gICAqIEByZXR1cm4ge1F1b3RlVGltZX0gdGltZSBvZiB0aGUgbGFzdCByZWNlaXZlZCBxdW90ZVxuICAgKi9cbiAgZ2V0IGxhc3RRdW90ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbWJpbmVkU3RhdGUubGFzdFF1b3RlVGltZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGltZTogdGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0UXVvdGVUaW1lLFxuICAgICAgICBicm9rZXJUaW1lOiB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZUJyb2tlclRpbWUsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgcHJpY2UgdG8gYmUgcmVjZWl2ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgMzBcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyU3ltYm9sUHJpY2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHByaWNlIG9yIHVuZGVmaW5lZCBpZiBwcmljZSBoYXMgbm90IGJlZW4gcmVjZWl2ZWRcbiAgICovXG4gIGFzeW5jIHdhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMgPSAzMCkge1xuICAgIHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzW3N5bWJvbF0gPSB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1tzeW1ib2xdIHx8IFtdO1xuICAgIGlmICghdGhpcy5wcmljZShzeW1ib2wpKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICBuZXcgUHJvbWlzZShyZXMgPT4gdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbc3ltYm9sXS5wdXNoKHJlcykpLFxuICAgICAgICBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSlcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmljZShzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgZXN0YWJsaXNoZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICovXG4gIG9uQ29ubmVjdGVkKGluc3RhbmNlSW5kZXgpIHtcbiAgICB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KS5jb25uZWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgdGVybWluYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKi9cbiAgb25EaXNjb25uZWN0ZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHN0YXRlLmNvbm5lY3RlZFRvQnJva2VyID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGJyb2tlciBjb25uZWN0aW9uIHN0YXR1cyBoYXZlIGNoYW5nZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb25uZWN0ZWQgaXMgTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb25uZWN0ZWQgdG8gYnJva2VyXG4gICAqL1xuICBvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkKGluc3RhbmNlSW5kZXgsIGNvbm5lY3RlZCkge1xuICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUubGFzdFN0YXR1c1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpLmNvbm5lY3RlZFRvQnJva2VyID0gY29ubmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvbiBpcyBzdGFydGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcGVjaWZpY2F0aW9uc0hhc2ggc3BlY2lmaWNhdGlvbnMgaGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25zSGFzaCBwb3NpdGlvbnMgaGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JkZXJzSGFzaCBvcmRlcnMgaGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25TeW5jaHJvbml6YXRpb25TdGFydGVkKGluc3RhbmNlSW5kZXgsIHNwZWNpZmljYXRpb25zSGFzaCwgcG9zaXRpb25zSGFzaCwgb3JkZXJzSGFzaCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBjb25zdCB1bnN5bmNocm9uaXplZFN0YXRlcyA9IHRoaXMuX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpXG4gICAgICAuZmlsdGVyKHN0YXRlSW5kZXggPT4gIXRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W3N0YXRlSW5kZXhdLm9yZGVyc0luaXRpYWxpemVkKTtcbiAgICB1bnN5bmNocm9uaXplZFN0YXRlcy5zb3J0KChhLGIpID0+IGIubGFzdFN5bmNVcGRhdGVUaW1lIC0gYS5sYXN0U3luY1VwZGF0ZVRpbWUpO1xuICAgIHVuc3luY2hyb25pemVkU3RhdGVzLnNsaWNlKDEpLmZvckVhY2goc3RhdGVJbmRleCA9PiB0aGlzLl9yZW1vdmVTdGF0ZShzdGF0ZUluZGV4KSk7XG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5pc1NwZWNpZmljYXRpb25zRXhwZWN0ZWQgPSAhc3BlY2lmaWNhdGlvbnNIYXNoO1xuICAgIHN0YXRlLmlzUG9zaXRpb25zRXhwZWN0ZWQgPSAhcG9zaXRpb25zSGFzaDtcbiAgICBzdGF0ZS5pc09yZGVyc0V4cGVjdGVkID0gIW9yZGVyc0hhc2g7XG4gICAgc3RhdGUubGFzdFN5bmNVcGRhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgc3RhdGUucHJpY2VzQnlTeW1ib2wgPSB7fTtcbiAgICBzdGF0ZS5wb3NpdGlvbnMgPSBbXTtcbiAgICBpZighcG9zaXRpb25zSGFzaCkge1xuICAgICAgc3RhdGUucG9zaXRpb25zSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uc0hhc2ggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbnNIYXNoID0gcG9zaXRpb25zSGFzaDtcbiAgICB9XG4gICAgc3RhdGUub3JkZXJzID0gW107XG4gICAgaWYoIW9yZGVyc0hhc2gpIHtcbiAgICAgIHN0YXRlLm9yZGVyc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICBzdGF0ZS5vcmRlcnNIYXNoID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUub3JkZXJzSGFzaCA9IG9yZGVyc0hhc2g7XG4gICAgfVxuICAgIHN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wgPSB7fTtcbiAgICBpZighc3BlY2lmaWNhdGlvbnNIYXNoKSB7XG4gICAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fToke3N5bmNocm9uaXphdGlvbklkfTogY2xlYXJlZCBzcGVjaWZpY2F0aW9ucyBgICtcbiAgICAgICAgJ29uIHN5bmNocm9uaXphdGlvbiBzdGFydCcpO1xuICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06JHtzeW5jaHJvbml6YXRpb25JZH06IG5vIG5lZWQgdG8gY2xlYXIgYCArXG4gICAgICAgIGBzcGVjaWZpY2F0aW9ucyBvbiBzeW5jaHJvbml6YXRpb24gc3RhcnQsICR7T2JqZWN0LmtleXMoc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCB8fCB7fSkubGVuZ3RofSBgICtcbiAgICAgICAgJ3NwZWNpZmljYXRpb25zIHJldXNlZCcpO1xuICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gc3BlY2lmaWNhdGlvbnNIYXNoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gTWV0YVRyYWRlciBhY2NvdW50IGluZm9ybWF0aW9uIGlzIHVwZGF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudEluZm9ybWF0aW9ufSBhY2NvdW50SW5mb3JtYXRpb24gdXBkYXRlZCBNZXRhVHJhZGVyIGFjY291bnQgaW5mb3JtYXRpb25cbiAgICovXG4gIG9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZChpbnN0YW5jZUluZGV4LCBhY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA9IGFjY291bnRJbmZvcm1hdGlvbjtcbiAgICBpZiAoYWNjb3VudEluZm9ybWF0aW9uKSB7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIGFjY291bnRJbmZvcm1hdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgcG9zaXRpb25zIGFyZSByZXBsYWNlZCBhcyBhIHJlc3VsdCBvZiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJQb3NpdGlvbj59IHBvc2l0aW9ucyB1cGRhdGVkIGFycmF5IG9mIHBvc2l0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uUG9zaXRpb25zUmVwbGFjZWQoaW5zdGFuY2VJbmRleCwgcG9zaXRpb25zKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5fcmVmcmVzaFN0YXRlVXBkYXRlVGltZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZihzdGF0ZS5pc1Bvc2l0aW9uc0V4cGVjdGVkKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwb3NpdGlvbiBzeW5jaHJvbml6YXRpb24gZm5pc2hlZCB0byBpbmRpY2F0ZSBwcm9ncmVzcyBvZiBhbiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBvblBvc2l0aW9uc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gTWV0YVRyYWRlciBwb3NpdGlvbnMgYXJlIHVwZGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyUG9zaXRpb25bXX0gcG9zaXRpb25zIHVwZGF0ZWQgTWV0YVRyYWRlciBwb3NpdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gcmVtb3ZlZFBvc2l0aW9uSWRzIHJlbW92ZWQgcG9zaXRpb24gaWRzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25Qb3NpdGlvbnNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHBvc2l0aW9ucywgcmVtb3ZlZFBvc2l0aW9uSWRzKSB7XG4gICAgbGV0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIHJlbW92ZWRQb3NpdGlvbklkcy5mb3JFYWNoKGlkID0+IHRoaXMuX2NvbWJpbmVkU3RhdGUucmVtb3ZlZFBvc2l0aW9uc1tpZF0gPSBkYXRlKTtcbiAgICBwb3NpdGlvbnMgPSB0aGlzLl9maWx0ZXJSZW1vdmVkUG9zaXRpb25zKHBvc2l0aW9ucyk7XG4gICAgT2JqZWN0LmtleXModGhpcy5fY29tYmluZWRTdGF0ZS5yZW1vdmVkUG9zaXRpb25zKS5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGlmKHRoaXMuX2NvbWJpbmVkU3RhdGUucmVtb3ZlZFBvc2l0aW9uc1tpZF0gPCBkYXRlIC0gMjQgKiA2MCAqIDYwICogMTAwMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fY29tYmluZWRTdGF0ZS5yZW1vdmVkUG9zaXRpb25zW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKGluc3RhbmNlU3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IGFzeW5jIChzdGF0ZSwgaW5zdGFuY2UpID0+IHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIudXBkYXRlUG9zaXRpb25zKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2FjY291bnQudHlwZSwgdGhpcy5faWQsXG4gICAgICAgICAgaW5zdGFuY2UsIHBvc2l0aW9ucywgcmVtb3ZlZFBvc2l0aW9uSWRzLCBzdGF0ZS5wb3NpdGlvbnNIYXNoKTtcbiAgICAgICAgc3RhdGUucG9zaXRpb25zSGFzaCA9IGhhc2g7XG4gICAgICB9O1xuICAgICAgYXdhaXQgdXBkYXRlUG9zaXRpb25zKGluc3RhbmNlU3RhdGUsIGluc3RhbmNlSW5kZXgpO1xuICAgICAgYXdhaXQgdXBkYXRlUG9zaXRpb25zKHRoaXMuX2NvbWJpbmVkU3RhdGUsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlU3RhdGUucG9zaXRpb25zID0gaW5zdGFuY2VTdGF0ZS5wb3NpdGlvbnMuZmlsdGVyKHBvc2l0aW9uID0+ICFyZW1vdmVkUG9zaXRpb25JZHMuaW5jbHVkZXMocG9zaXRpb24uaWQpKTtcbiAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKHBvc2l0aW9uID0+IHtcbiAgICAgICAgbGV0IGluZGV4ID0gaW5zdGFuY2VTdGF0ZS5wb3NpdGlvbnMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gcG9zaXRpb24uaWQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgaW5zdGFuY2VTdGF0ZS5wb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdGFuY2VTdGF0ZS5wb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIG9yZGVycyBhcmUgcmVwbGFjZWQgYXMgYSByZXN1bHQgb2YgaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheTxNZXRhdHJhZGVyT3JkZXI+fSBvcmRlcnMgdXBkYXRlZCBhcnJheSBvZiBwZW5kaW5nIG9yZGVyc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uUGVuZGluZ09yZGVyc1JlcGxhY2VkKGluc3RhbmNlSW5kZXgsIG9yZGVycykge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYoc3RhdGUuaXNPcmRlcnNFeHBlY3RlZCkge1xuICAgICAgc3RhdGUub3JkZXJzID0gb3JkZXJzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcGVuZGluZyBvcmRlciBzeW5jaHJvbml6YXRpb24gZm5pc2hlZCB0byBpbmRpY2F0ZSBwcm9ncmVzcyBvZiBhbiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlXG4gICAqIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHNcbiAgYXN5bmMgb25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUucG9zaXRpb25zSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHN0YXRlLm9yZGVyc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA9IHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA/IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbikgOlxuICAgICAgdW5kZWZpbmVkO1xuICAgIHN0YXRlLnBvc2l0aW9ucyA9IHRoaXMuX2ZpbHRlclJlbW92ZWRQb3NpdGlvbnMoc3RhdGUucG9zaXRpb25zKTtcbiAgICBpZihzdGF0ZS5wb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoYXNoID0gdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZWNvcmRQb3NpdGlvbnModGhpcy5fYWNjb3VudC5pZCxcbiAgICAgICAgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCwgaW5zdGFuY2VJbmRleCwgc3RhdGUucG9zaXRpb25zKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uc0hhc2ggPSBoYXNoO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnMgPSAoc3RhdGUucG9zaXRpb25zIHx8IFtdKS5tYXAocCA9PiBPYmplY3QuYXNzaWduKHt9LCBwKSk7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9uc0hhc2ggPSBoYXNoO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb25zSGFzaCkge1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVQb3NpdGlvblJlZmVyZW5jZSh0aGlzLmlkLCBpbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuYWRkUG9zaXRpb25SZWZlcmVuY2Uoc3RhdGUucG9zaXRpb25zSGFzaCxcbiAgICAgICAgdGhpcy5pZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9uc0hhc2ggPSBzdGF0ZS5wb3NpdGlvbnNIYXNoO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVQb3NpdGlvblJlZmVyZW5jZSh0aGlzLmlkLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5hZGRQb3NpdGlvblJlZmVyZW5jZShzdGF0ZS5wb3NpdGlvbnNIYXNoLFxuICAgICAgICB0aGlzLmlkLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgIH1cbiAgICBzdGF0ZS5vcmRlcnMgPSB0aGlzLl9maWx0ZXJSZW1vdmVkT3JkZXJzKHN0YXRlLm9yZGVycyk7XG4gICAgaWYoc3RhdGUub3JkZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgaGFzaCA9IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVjb3JkT3JkZXJzKHRoaXMuX2FjY291bnQuaWQsXG4gICAgICAgIHRoaXMuX2FjY291bnQudHlwZSwgdGhpcy5faWQsIGluc3RhbmNlSW5kZXgsIHN0YXRlLm9yZGVycyk7XG4gICAgICBzdGF0ZS5vcmRlcnNIYXNoID0gaGFzaDtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUub3JkZXJzID0gKHN0YXRlLm9yZGVycyB8fCBbXSkubWFwKG8gPT4gT2JqZWN0LmFzc2lnbih7fSwgbykpO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5vcmRlcnNIYXNoID0gaGFzaDtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9yZGVyc0hhc2gpIHtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVtb3ZlT3JkZXJSZWZlcmVuY2UodGhpcy5pZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmFkZE9yZGVyUmVmZXJlbmNlKHN0YXRlLm9yZGVyc0hhc2gsXG4gICAgICAgIHRoaXMuaWQsIGluc3RhbmNlSW5kZXgpO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5vcmRlcnNIYXNoID0gc3RhdGUub3JkZXJzSGFzaDtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVtb3ZlT3JkZXJSZWZlcmVuY2UodGhpcy5pZCwgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuYWRkT3JkZXJSZWZlcmVuY2Uoc3RhdGUub3JkZXJzSGFzaCxcbiAgICAgICAgdGhpcy5pZCwgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06JHtzeW5jaHJvbml6YXRpb25JZH06IGFzc2lnbmVkIHNwZWNpZmljYXRpb25zIHRvIGAgK1xuICAgICAgJ2NvbWJpbmVkIHN0YXRlIGZyb20gJyArXG4gICAgICBgJHtpbnN0YW5jZUluZGV4fSwgJHtPYmplY3Qua2V5cyhzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sIHx8IHt9KS5sZW5ndGh9IHNwZWNpZmljYXRpb25zIGFzc2lnbmVkYCk7XG4gICAgdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5fY29tYmluZWRTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wgfHwge30pLmxlbmd0aCkge1xuICAgICAgaWYoc3RhdGUuaXNTcGVjaWZpY2F0aW9uc0V4cGVjdGVkKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlY29yZFNwZWNpZmljYXRpb25zKHRoaXMuX2FjY291bnQuc2VydmVyLFxuICAgICAgICAgIHRoaXMuX2FjY291bnQudHlwZSwgdGhpcy5faWQsIGluc3RhbmNlSW5kZXgsIE9iamVjdC52YWx1ZXMoc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCkpO1xuICAgICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IGhhc2g7XG4gICAgICAgIHN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IGhhc2g7XG4gICAgICAgIHN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmKHN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCkge1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci51cGRhdGVTcGVjaWZpY2F0aW9ucyh0aGlzLl9hY2NvdW50LnNlcnZlcixcbiAgICAgICAgICB0aGlzLl9hY2NvdW50LnR5cGUsIHRoaXMuX2lkLCBpbnN0YW5jZUluZGV4LCBPYmplY3QudmFsdWVzKHN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wpLFxuICAgICAgICAgIFtdLCBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gpO1xuICAgICAgICBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBoYXNoO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKSB7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlbW92ZVNwZWNpZmljYXRpb25SZWZlcmVuY2UodGhpcy5pZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmFkZFNwZWNpZmljYXRpb25SZWZlcmVuY2Uoc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoLFxuICAgICAgICB0aGlzLmlkLCBpbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVTcGVjaWZpY2F0aW9uUmVmZXJlbmNlKHRoaXMuaWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmFkZFNwZWNpZmljYXRpb25SZWZlcmVuY2Uoc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoLFxuICAgICAgICB0aGlzLmlkLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgIH1cbiAgICBmb3IobGV0IHN0YXRlSW5kZXggb2YgdGhpcy5fZ2V0U3RhdGVJbmRpY2VzT2ZTYW1lSW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCkpIHtcbiAgICAgIGlmICghdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbc3RhdGVJbmRleF0uY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVN0YXRlKHN0YXRlSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gTWV0YVRyYWRlciBwZW5kaW5nIG9yZGVycyBhcmUgdXBkYXRlZCBvciBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyT3JkZXJbXX0gb3JkZXJzIHVwZGF0ZWQgTWV0YVRyYWRlciBwZW5kaW5nIG9yZGVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb21wbGV0ZWRPcmRlcklkcyBjb21wbGV0ZWQgTWV0YVRyYWRlciBwZW5kaW5nIG9yZGVyIGlkc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uUGVuZGluZ09yZGVyc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgb3JkZXJzLCBjb21wbGV0ZWRPcmRlcklkcykge1xuICAgIGxldCBpbnN0YW5jZVN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5fcmVmcmVzaFN0YXRlVXBkYXRlVGltZShpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBjb21wbGV0ZWRPcmRlcklkcy5mb3JFYWNoKGlkID0+IHRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzW2lkXSA9IGRhdGUpO1xuICAgIG9yZGVycyA9IHRoaXMuX2ZpbHRlclJlbW92ZWRPcmRlcnMob3JkZXJzKTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9jb21iaW5lZFN0YXRlLmNvbXBsZXRlZE9yZGVycykuZm9yRWFjaChpZCA9PiB7XG4gICAgICBpZih0aGlzLl9jb21iaW5lZFN0YXRlLmNvbXBsZXRlZE9yZGVyc1tpZF0gPCBkYXRlIC0gMjQgKiA2MCAqIDYwICogMTAwMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fY29tYmluZWRTdGF0ZS5jb21wbGV0ZWRPcmRlcnNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYoaW5zdGFuY2VTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgdXBkYXRlUGVuZGluZ09yZGVycyA9IGFzeW5jIChzdGF0ZSwgaW5zdGFuY2UpID0+IHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIudXBkYXRlT3JkZXJzKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2FjY291bnQudHlwZSwgdGhpcy5faWQsXG4gICAgICAgICAgaW5zdGFuY2UsIG9yZGVycywgY29tcGxldGVkT3JkZXJJZHMsIHN0YXRlLm9yZGVyc0hhc2gpO1xuICAgICAgICBzdGF0ZS5vcmRlcnNIYXNoID0gaGFzaDtcbiAgICAgIH07XG4gICAgICBhd2FpdCB1cGRhdGVQZW5kaW5nT3JkZXJzKGluc3RhbmNlU3RhdGUsIGluc3RhbmNlSW5kZXgpO1xuICAgICAgYXdhaXQgdXBkYXRlUGVuZGluZ09yZGVycyh0aGlzLl9jb21iaW5lZFN0YXRlLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZVN0YXRlLm9yZGVycyA9IGluc3RhbmNlU3RhdGUub3JkZXJzLmZpbHRlcihvcmRlciA9PiAhY29tcGxldGVkT3JkZXJJZHMuaW5jbHVkZXMob3JkZXIuaWQpKTtcbiAgICAgIG9yZGVycy5mb3JFYWNoKG9yZGVyID0+IHtcbiAgICAgICAgbGV0IGluZGV4ID0gaW5zdGFuY2VTdGF0ZS5vcmRlcnMuZmluZEluZGV4KG8gPT4gby5pZCA9PT0gb3JkZXIuaWQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgaW5zdGFuY2VTdGF0ZS5vcmRlcnNbaW5kZXhdID0gb3JkZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdGFuY2VTdGF0ZS5vcmRlcnMucHVzaChvcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzeW1ib2wgc3BlY2lmaWNhdGlvbiB3YXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gc3BlY2lmaWNhdGlvbnMgdXBkYXRlZCBzcGVjaWZpY2F0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHJlbW92ZWRTeW1ib2xzIHJlbW92ZWQgc3ltYm9sc1xuICAgKi9cbiAgYXN5bmMgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzKSB7XG4gICAgbGV0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGlmKCFpbnN0YW5jZVN0YXRlLm9yZGVyc0luaXRpYWxpemVkKSB7XG4gICAgICBmb3IgKGxldCBzcGVjaWZpY2F0aW9uIG9mIHNwZWNpZmljYXRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlU3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbFtzcGVjaWZpY2F0aW9uLnN5bWJvbF0gPSBzcGVjaWZpY2F0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYXNoID0gdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci51cGRhdGVTcGVjaWZpY2F0aW9ucyh0aGlzLl9hY2NvdW50LnNlcnZlciwgdGhpcy5fYWNjb3VudC50eXBlLFxuICAgICAgICB0aGlzLl9pZCwgaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzLCBpbnN0YW5jZVN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCk7XG4gICAgICBpbnN0YW5jZVN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IGhhc2g7XG4gICAgICBjb25zdCBjb21iaW5lZEhhc2ggPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnVwZGF0ZVNwZWNpZmljYXRpb25zKHRoaXMuX2FjY291bnQuc2VydmVyLFxuICAgICAgICB0aGlzLl9hY2NvdW50LnR5cGUsIHRoaXMuX2lkLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgsIHNwZWNpZmljYXRpb25zLCByZW1vdmVkU3ltYm9scyxcbiAgICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gpO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBjb21iaW5lZEhhc2g7XG4gICAgfVxuICAgIHRoaXMuX2xvZ2dlci50cmFjZSgoKSA9PiBgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiB1cGRhdGVkICR7c3BlY2lmaWNhdGlvbnMubGVuZ3RofSBzcGVjaWZpY2F0aW9ucywgYCArXG4gICAgICBgcmVtb3ZlZCAke3JlbW92ZWRTeW1ib2xzLmxlbmd0aH0gc3BlY2lmaWNhdGlvbnMuIFRoZXJlIGFyZSBgICtcbiAgICAgIGAke09iamVjdC5rZXlzKGluc3RhbmNlU3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCB8fCB7fSkubGVuZ3RofSBzcGVjaWZpY2F0aW9ucyBhZnRlciB1cGRhdGVgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcHJpY2VzIGZvciBzZXZlcmFsIHN5bWJvbHMgd2VyZSB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclN5bWJvbFByaWNlPn0gcHJpY2VzIHVwZGF0ZWQgTWV0YVRyYWRlciBzeW1ib2wgcHJpY2VzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlcXVpdHkgYWNjb3VudCBsaXF1aWRhdGlvbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWFyZ2luIG1hcmdpbiB1c2VkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmVlTWFyZ2luIGZyZWUgbWFyZ2luXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXJnaW5MZXZlbCBtYXJnaW4gbGV2ZWwgY2FsY3VsYXRlZCBhcyAlIG9mIGVxdWl0eS9tYXJnaW5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIG9uU3ltYm9sUHJpY2VzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwcmljZXMsIGVxdWl0eSwgbWFyZ2luLCBmcmVlTWFyZ2luLCBtYXJnaW5MZXZlbCkge1xuICAgIGxldCBpbnN0YW5jZVN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5fcmVmcmVzaFN0YXRlVXBkYXRlVGltZShpbnN0YW5jZUluZGV4KTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LG1heC1zdGF0ZW1lbnRzXG4gICAgY29uc3QgdXBkYXRlU3ltYm9sUHJpY2VzID0gKHN0YXRlKSA9PiB7XG4gICAgICBsZXQgcHJpY2VzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBwcmljZVVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IHByaWNlIG9mIHByaWNlcyB8fCBbXSkge1xuICAgICAgICBsZXQgY3VycmVudFByaWNlID0gc3RhdGUucHJpY2VzQnlTeW1ib2xbcHJpY2Uuc3ltYm9sXTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmljZSAmJiBjdXJyZW50UHJpY2UudGltZS5nZXRUaW1lKCkgPiBwcmljZS50aW1lLmdldFRpbWUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaWNlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS5sYXN0UXVvdGVUaW1lIHx8IHN0YXRlLmxhc3RRdW90ZVRpbWUuZ2V0VGltZSgpIDwgcHJpY2UudGltZS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0UXVvdGVUaW1lID0gcHJpY2UudGltZTtcbiAgICAgICAgICBzdGF0ZS5sYXN0UXVvdGVCcm9rZXJUaW1lID0gcHJpY2UuYnJva2VyVGltZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wcmljZXNCeVN5bWJvbFtwcmljZS5zeW1ib2xdID0gcHJpY2U7XG4gICAgICAgIGNvbnN0IGFsbFBvc2l0aW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRQb3NpdGlvbnNCeUhhc2goXG4gICAgICAgICAgc3RhdGUucG9zaXRpb25zSGFzaCkgfHwge30pO1xuICAgICAgICBjb25zdCBhbGxPcmRlcnMgPSBPYmplY3QudmFsdWVzKHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0T3JkZXJzQnlIYXNoKFxuICAgICAgICAgIHN0YXRlLm9yZGVyc0hhc2gpIHx8IHt9KTtcbiAgICAgICAgbGV0IHBvc2l0aW9ucyA9IGFsbFBvc2l0aW9ucy5maWx0ZXIocCA9PiBwLnN5bWJvbCA9PT0gcHJpY2Uuc3ltYm9sKTtcbiAgICAgICAgbGV0IG90aGVyUG9zaXRpb25zID0gYWxsUG9zaXRpb25zLmZpbHRlcihwID0+IHAuc3ltYm9sICE9PSBwcmljZS5zeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJzID0gYWxsT3JkZXJzLmZpbHRlcihvID0+IG8uc3ltYm9sID09PSBwcmljZS5zeW1ib2wpO1xuICAgICAgICBwcmljZXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHBvc2l0aW9uIG9mIG90aGVyUG9zaXRpb25zKSB7XG4gICAgICAgICAgbGV0IHAgPSBzdGF0ZS5wcmljZXNCeVN5bWJvbFtwb3NpdGlvbi5zeW1ib2xdO1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24udW5yZWFsaXplZFByb2ZpdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uUHJvZml0cyhwb3NpdGlvbiwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByaWNlc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBvc2l0aW9uIG9mIHBvc2l0aW9ucykge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uUHJvZml0cyhwb3NpdGlvbiwgcHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG9yZGVyIG9mIG9yZGVycykge1xuICAgICAgICAgIG9yZGVyLmN1cnJlbnRQcmljZSA9IG9yZGVyLnR5cGUgPT09ICdPUkRFUl9UWVBFX0JVWScgfHwgb3JkZXIudHlwZSA9PT0gJ09SREVSX1RZUEVfQlVZX0xJTUlUJyB8fFxuICAgICAgICAgICAgb3JkZXIudHlwZSA9PT0gJ09SREVSX1RZUEVfQlVZX1NUT1AnIHx8IG9yZGVyLnR5cGUgPT09ICdPUkRFUl9UWVBFX0JVWV9TVE9QX0xJTUlUJyA/IHByaWNlLmFzayA6IHByaWNlLmJpZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJpY2VSZXNvbHZlcyA9IHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzW3ByaWNlLnN5bWJvbF0gfHwgW107XG4gICAgICAgIGlmIChwcmljZVJlc29sdmVzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAobGV0IHJlc29sdmUgb2YgcHJpY2VSZXNvbHZlcykge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbcHJpY2Uuc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByaWNlVXBkYXRlZCAmJiBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldFBvc2l0aW9uc0J5SGFzaChzdGF0ZS5wb3NpdGlvbnNIYXNoKSB8fCB7fSk7XG4gICAgICAgIGlmIChzdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCAmJiBwcmljZXNJbml0aWFsaXplZCkge1xuICAgICAgICAgIGlmIChzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24ucGxhdGZvcm0gPT09ICdtdDUnKSB7XG4gICAgICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5ID0gZXF1aXR5ICE9PSB1bmRlZmluZWQgPyBlcXVpdHkgOiBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uYmFsYW5jZSArXG4gICAgICAgICAgICAgIHBvc2l0aW9ucy5yZWR1Y2UoKGFjYywgcCkgPT4gYWNjICtcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKChwLnVucmVhbGl6ZWRQcm9maXQgfHwgMCkgKiAxMDApIC8gMTAwICsgTWF0aC5yb3VuZCgocC5zd2FwIHx8IDApICogMTAwKSAvIDEwMCwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHkgPSBlcXVpdHkgIT09IHVuZGVmaW5lZCA/IGVxdWl0eSA6IHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5iYWxhbmNlICtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5yZWR1Y2UoKGFjYywgcCkgPT4gYWNjICsgTWF0aC5yb3VuZCgocC5zd2FwIHx8IDApICogMTAwKSAvIDEwMCArXG4gICAgICAgICAgICAgIE1hdGgucm91bmQoKHAuY29tbWlzc2lvbiB8fCAwKSAqIDEwMCkgLyAxMDAgKyBNYXRoLnJvdW5kKChwLnVucmVhbGl6ZWRQcm9maXQgfHwgMCkgKiAxMDApIC8gMTAwLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSA9IE1hdGgucm91bmQoc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSA9IGVxdWl0eSAhPT0gdW5kZWZpbmVkID8gZXF1aXR5IDogc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlID0gKFxuICAgICAgICAgIHByaWNlc1swXS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUgPz8gc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZVxuICAgICAgICApO1xuICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24ubWFyZ2luID0gbWFyZ2luICE9PSB1bmRlZmluZWQgPyBtYXJnaW4gOiBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24ubWFyZ2luO1xuICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZnJlZU1hcmdpbiA9IGZyZWVNYXJnaW4gIT09IHVuZGVmaW5lZCA/IGZyZWVNYXJnaW4gOiBcbiAgICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZnJlZU1hcmdpbjtcbiAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLm1hcmdpbkxldmVsID0gZnJlZU1hcmdpbiAhPT0gdW5kZWZpbmVkID8gbWFyZ2luTGV2ZWwgOlxuICAgICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW5MZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZVN5bWJvbFByaWNlcyhpbnN0YW5jZVN0YXRlKTtcbiAgICB1cGRhdGVTeW1ib2xQcmljZXModGhpcy5fY29tYmluZWRTdGF0ZSk7XG4gICAgZm9yIChsZXQgcHJpY2Ugb2YgcHJpY2VzKSB7XG4gICAgICBmb3IgKGxldCBjYWxsIG9mIE9iamVjdC52YWx1ZXModGhpcy5fcHJvY2Vzc1Rocm90dGxlZFF1b3Rlc0NhbGxzKSkge1xuICAgICAgICB0aGlzLl9sb2dnZXIudHJhY2UoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogcmVmcmVzaGVkICR7cHJpY2Uuc3ltYm9sfSBwcmljZWApO1xuICAgICAgICBjYWxsLmV4cGVjdGVkU3ltYm9scz8uZGVsZXRlKHByaWNlLnN5bWJvbCk7XG4gICAgICAgIGNhbGwucmVjZWl2ZWRTeW1ib2xzLmFkZChwcmljZS5zeW1ib2wpO1xuICAgICAgICBjYWxsLnByb21pc2UuY2hlY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3RyZWFtIGZvciBhbiBpbnN0YW5jZSBpbmRleCBpcyBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblN0cmVhbUNsb3NlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgaWYodGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF0pIHtcbiAgICAgIGZvcihsZXQgc3RhdGVJbmRleCBvZiB0aGlzLl9nZXRTdGF0ZUluZGljZXNPZlNhbWVJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KSkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZVN0YXRlID0gdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbc3RhdGVJbmRleF07XG4gICAgICAgIGlmKCF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtpbnN0YW5jZUluZGV4XS5vcmRlcnNJbml0aWFsaXplZCBcbiAgICAgICAgICAgICYmIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdLmxhc3RTeW5jVXBkYXRlVGltZSA8PSBpbnN0YW5jZVN0YXRlLmxhc3RTeW5jVXBkYXRlVGltZSkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKGluc3RhbmNlU3RhdGUuY29ubmVjdGVkICYmIGluc3RhbmNlU3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgcmVmcmVzaCBvZiBtb3N0IHJlY2VudCBxdW90ZSB1cGRhdGVzIGZvciBzeW1ib2xzIHN1YnNjcmliZWQgdG8gYnkgdGhlIHRlcm1pbmFsLCBhbmQgd2FpdHMgZm9yIHRoZW0gYWxsIHRvXG4gICAqIGJlIHByb2Nlc3NlZCBieSB0aGlzIHRlcm1pbmFsIHN0YXRlLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB3YWl0cyBmb3IgYWxsIG90aGVyIGxpc3RlbmVycyB0byByZWNlaXZlIGFuZCBwcm9jZXNzIHRoZVxuICAgKiBxdW90ZSB1cGRhdGVzXG4gICAqIEBwYXJhbSB7UmVmcmVzaFRlcm1pbmFsU3RhdGVPcHRpb25zfSBbb3B0aW9uc10gYWRkaXRpb25hbCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSB0ZXJtaW5hbCBzdGF0ZSByZWNlaXZlZCBhbmQgcHJvY2Vzc2VkIHRoZSBsYXRlc3QgcXVvdGVzXG4gICAqL1xuICBhc3luYyByZWZyZXNoVGVybWluYWxTdGF0ZShvcHRpb25zKSB7XG4gICAgbGV0IGNhbGxEYXRhID0ge1xuICAgICAgcmVjZWl2ZWRTeW1ib2xzOiBuZXcgU2V0KClcbiAgICB9O1xuICAgIGxldCBjYWxsSWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoOCk7XG4gICAgdGhpcy5fcHJvY2Vzc1Rocm90dGxlZFF1b3Rlc0NhbGxzW2NhbGxJZF0gPSBjYWxsRGF0YTtcbiAgICBjYWxsRGF0YS5wcm9taXNlID0gbmV3IENvbmRpdGlvblByb21pc2UoKCkgPT4gY2FsbERhdGEuZXhwZWN0ZWRTeW1ib2xzICYmICFjYWxsRGF0YS5leHBlY3RlZFN5bWJvbHMuc2l6ZSk7XG4gICAgY2FsbERhdGEucHJvbWlzZS50aW1lb3V0KDEwMDAgKiAob3B0aW9ucz8udGltZW91dEluU2Vjb25kcyA/PyAxMCksICdyZWZyZXNoaW5nIHRlcm1pbmFsIHN0YXRlIHRpbWVkIG91dCcpO1xuICAgIHRyeSB7XG4gICAgICBsZXQgc3ltYm9scyA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZWZyZXNoVGVybWluYWxTdGF0ZSh0aGlzLl9hY2NvdW50LmlkKSxcbiAgICAgICAgY2FsbERhdGEucHJvbWlzZSAvLyB3aWxsIG9ubHkgdGhyb3cgdGltZW91dCBlcnJvciBhdCB0aGlzIHBvaW50XG4gICAgICBdKTtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfTogZXhwZWN0aW5nIGZvciAke3N5bWJvbHMubGVuZ3RoID8gc3ltYm9scyA6IDB9IHN5bWJvbHMgdG8gcmVmcmVzaGApO1xuICAgICAgbGV0IGV4cGVjdGVkU3ltYm9scyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAobGV0IHN5bWJvbCBvZiBzeW1ib2xzKSB7XG4gICAgICAgIGlmICghY2FsbERhdGEucmVjZWl2ZWRTeW1ib2xzLmhhcyhzeW1ib2wpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRTeW1ib2xzLmFkZChzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWxsRGF0YS5leHBlY3RlZFN5bWJvbHMgPSBleHBlY3RlZFN5bWJvbHM7XG4gICAgICBjYWxsRGF0YS5wcm9taXNlLmNoZWNrKCk7XG4gICAgICBhd2FpdCBjYWxsRGF0YS5wcm9taXNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZWxldGUgdGhpcy5fcHJvY2Vzc1Rocm90dGxlZFF1b3Rlc0NhbGxzW2NhbGxJZF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY29ubmVjdGlvbiByZWxhdGVkIGRhdGEgZnJvbSB0ZXJtaW5hbCBoYXNoIG1hbmFnZXJcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2JJbnRlcnZhbCk7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLmZvckVhY2goaW5zdGFuY2VJbmRleCA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tSGFzaE1hbmFnZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVtb3ZlRnJvbUhhc2hNYW5hZ2VyKHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvLyByZXNldHMgY29tYmluZWQgc3RhdGUgYW5kIHJlbW92ZXMgZnJvbSBoYXNoIG1hbmFnZXIgaWYgaGFzIGJlZW4gZGlzY29ubmVjdGVkIGZvciBhIGxvbmcgdGltZVxuICBfY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2IoKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZFRvQnJva2VyICYmIHRoaXMuX2NvbWJpbmVkU3RhdGUubGFzdFN0YXR1c1RpbWUgPCBEYXRlLm5vdygpIC0gMzAgKiA2MCAqIDEwMDApIHtcbiAgICAgIHRoaXMuX3JlbW92ZUZyb21IYXNoTWFuYWdlcih0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCA9IG51bGw7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnByaWNlc0J5U3ltYm9sID0ge307XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IG51bGw7XG4gICAgICBcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUub3JkZXJzID0gW107XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0hhc2ggPSBudWxsO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNIYXNoID0gbnVsbDtcbiAgICAgIFxuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0U3RhdHVzVGltZSA9IDA7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZVRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZUJyb2tlclRpbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgX3JlbW92ZVN0YXRlKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gICAgdGhpcy5fcmVtb3ZlRnJvbUhhc2hNYW5hZ2VyKGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgX3JlbW92ZUZyb21IYXNoTWFuYWdlcihpbnN0YW5jZUluZGV4KSB7XG4gICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVDb25uZWN0aW9uUmVmZXJlbmNlcyh0aGlzLl9hY2NvdW50LnNlcnZlcixcbiAgICAgIHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2lkLCBpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIF9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpe1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gICAgaWYoc3RhdGUgJiYgc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXRlLmxhc3RTeW5jVXBkYXRlVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpIHtcbiAgICBjb25zdCByZWdpb24gPSBpbnN0YW5jZUluZGV4LnNwbGl0KCc6JylbMF07XG4gICAgY29uc3QgaW5zdGFuY2VOdW1iZXIgPSBpbnN0YW5jZUluZGV4LnNwbGl0KCc6JylbMV07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KVxuICAgICAgLmZpbHRlcihzdGF0ZUluc3RhbmNlSW5kZXggPT4gc3RhdGVJbnN0YW5jZUluZGV4LnN0YXJ0c1dpdGgoYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTpgKSAmJiBcbiAgICAgIGluc3RhbmNlSW5kZXggIT09IHN0YXRlSW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBfdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwcmljZSkge1xuICAgIGxldCBzcGVjaWZpY2F0aW9uID0gdGhpcy5zcGVjaWZpY2F0aW9uKHBvc2l0aW9uLnN5bWJvbCk7XG4gICAgaWYgKHNwZWNpZmljYXRpb24pIHtcbiAgICAgIGxldCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHNwZWNpZmljYXRpb24uZGlnaXRzKTtcbiAgICAgIGlmIChwb3NpdGlvbi5wcm9maXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi5wcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24ucmVhbGl6ZWRQcm9maXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID0gKHBvc2l0aW9uLnR5cGUgPT09ICdQT1NJVElPTl9UWVBFX0JVWScgPyAxIDogLTEpICpcbiAgICAgICAgICAocG9zaXRpb24uY3VycmVudFByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIHBvc2l0aW9uLmN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICAgIHBvc2l0aW9uLnZvbHVtZSAvIHNwZWNpZmljYXRpb24udGlja1NpemU7XG4gICAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICAgIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0ID0gcG9zaXRpb24ucHJvZml0IC0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdDtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdQb3NpdGlvblByaWNlID0gcG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IHByaWNlLmJpZCA6IHByaWNlLmFzaztcbiAgICAgIGxldCBpc1Byb2ZpdGFibGUgPSAocG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IDEgOiAtMSkgKiAobmV3UG9zaXRpb25QcmljZSAtIHBvc2l0aW9uLm9wZW5QcmljZSk7XG4gICAgICBsZXQgY3VycmVudFRpY2tWYWx1ZSA9IChpc1Byb2ZpdGFibGUgPiAwID8gcHJpY2UucHJvZml0VGlja1ZhbHVlIDogcHJpY2UubG9zc1RpY2tWYWx1ZSk7XG4gICAgICBsZXQgdW5yZWFsaXplZFByb2ZpdCA9IChwb3NpdGlvbi50eXBlID09PSAnUE9TSVRJT05fVFlQRV9CVVknID8gMSA6IC0xKSAqXG4gICAgICAgIChuZXdQb3NpdGlvblByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIGN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICBwb3NpdGlvbi52b2x1bWUgLyBzcGVjaWZpY2F0aW9uLnRpY2tTaXplO1xuICAgICAgdW5yZWFsaXplZFByb2ZpdCA9IE1hdGgucm91bmQodW5yZWFsaXplZFByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSB1bnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdCArIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gTWF0aC5yb3VuZChwb3NpdGlvbi5wcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICBwb3NpdGlvbi5jdXJyZW50UHJpY2UgPSBuZXdQb3NpdGlvblByaWNlO1xuICAgICAgcG9zaXRpb24uY3VycmVudFRpY2tWYWx1ZSA9IGN1cnJlbnRUaWNrVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgX2ZpbHRlclJlbW92ZWRQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9ucy5maWx0ZXIocG9zaXRpb24gPT4gIXRoaXMuX2NvbWJpbmVkU3RhdGUucmVtb3ZlZFBvc2l0aW9uc1twb3NpdGlvbi5pZF0pO1xuICB9XG5cbiAgX2ZpbHRlclJlbW92ZWRPcmRlcnMob3JkZXJzKSB7XG4gICAgcmV0dXJuIG9yZGVycy5maWx0ZXIob3JkZXIgPT4gIXRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzW29yZGVyLmlkXSk7XG4gIH1cbiAgXG4gIF9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdKSB7XG4gICAgICB0aGlzLl9sb2dnZXIudHJhY2UoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogY29uc3RydWN0ZWQgbmV3IHN0YXRlYCk7XG4gICAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdID0gdGhpcy5fY29uc3RydWN0VGVybWluYWxTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICBfY29uc3RydWN0VGVybWluYWxTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbmNlSW5kZXgsXG4gICAgICBjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgY29ubmVjdGVkVG9Ccm9rZXI6IGZhbHNlLFxuICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgb3JkZXJzOiBbXSxcbiAgICAgIHNwZWNpZmljYXRpb25zQnlTeW1ib2w6IHt9LFxuICAgICAgcHJpY2VzQnlTeW1ib2w6IHt9LFxuICAgICAgb3JkZXJzSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgcG9zaXRpb25zSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgbGFzdFN5bmNVcGRhdGVUaW1lOiAwLFxuICAgICAgcG9zaXRpb25zSGFzaDogbnVsbCxcbiAgICAgIG9yZGVyc0hhc2g6IG51bGwsXG4gICAgICBzcGVjaWZpY2F0aW9uc0hhc2g6IG51bGwsXG4gICAgICBpc1NwZWNpZmljYXRpb25zRXhwZWN0ZWQ6IHRydWUsXG4gICAgICBpc1Bvc2l0aW9uc0V4cGVjdGVkOiB0cnVlLFxuICAgICAgaXNPcmRlcnNFeHBlY3RlZDogdHJ1ZSxcbiAgICAgIGxhc3RRdW90ZVRpbWU6IHVuZGVmaW5lZCxcbiAgICAgIGxhc3RRdW90ZUJyb2tlclRpbWU6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxufVxuIl0sIm5hbWVzIjpbInJhbmRvbXN0cmluZyIsIlN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiTG9nZ2VyTWFuYWdlciIsIkNvbmRpdGlvblByb21pc2UiLCJUZXJtaW5hbFN0YXRlIiwiaWQiLCJfaWQiLCJjb25uZWN0ZWQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJfc3RhdGVCeUluc3RhbmNlSW5kZXgiLCJyZWR1Y2UiLCJhY2MiLCJzIiwiY29ubmVjdGVkVG9Ccm9rZXIiLCJhY2NvdW50SW5mb3JtYXRpb24iLCJfY29tYmluZWRTdGF0ZSIsInBvc2l0aW9ucyIsImhhc2giLCJwb3NpdGlvbnNIYXNoIiwiX3Rlcm1pbmFsSGFzaE1hbmFnZXIiLCJnZXRQb3NpdGlvbnNCeUhhc2giLCJvcmRlcnMiLCJvcmRlcnNIYXNoIiwiZ2V0T3JkZXJzQnlIYXNoIiwic3BlY2lmaWNhdGlvbnMiLCJzcGVjaWZpY2F0aW9uc0hhc2giLCJnZXRTcGVjaWZpY2F0aW9uc0J5SGFzaCIsImdldEhhc2hlcyIsInNwZWNpZmljYXRpb25zSGFzaGVzIiwiZ2V0TGFzdFVzZWRTcGVjaWZpY2F0aW9uSGFzaGVzIiwiX2FjY291bnQiLCJzZXJ2ZXIiLCJwb3NpdGlvbnNIYXNoZXMiLCJnZXRMYXN0VXNlZFBvc2l0aW9uSGFzaGVzIiwib3JkZXJzSGFzaGVzIiwiZ2V0TGFzdFVzZWRPcmRlckhhc2hlcyIsInNwZWNpZmljYXRpb24iLCJzeW1ib2wiLCJzdGF0ZSIsInByaWNlIiwicHJpY2VzQnlTeW1ib2wiLCJsYXN0UXVvdGVUaW1lIiwidGltZSIsImJyb2tlclRpbWUiLCJsYXN0UXVvdGVCcm9rZXJUaW1lIiwidW5kZWZpbmVkIiwid2FpdEZvclByaWNlIiwidGltZW91dEluU2Vjb25kcyIsIl93YWl0Rm9yUHJpY2VSZXNvbHZlcyIsIlByb21pc2UiLCJyYWNlIiwicmVzIiwicHVzaCIsInNldFRpbWVvdXQiLCJvbkNvbm5lY3RlZCIsImluc3RhbmNlSW5kZXgiLCJfZ2V0U3RhdGUiLCJvbkRpc2Nvbm5lY3RlZCIsIm9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQiLCJsYXN0U3RhdHVzVGltZSIsIkRhdGUiLCJub3ciLCJvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQiLCJzeW5jaHJvbml6YXRpb25JZCIsInVuc3luY2hyb25pemVkU3RhdGVzIiwiX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyIiwiZmlsdGVyIiwic3RhdGVJbmRleCIsIm9yZGVyc0luaXRpYWxpemVkIiwic29ydCIsImEiLCJiIiwibGFzdFN5bmNVcGRhdGVUaW1lIiwic2xpY2UiLCJmb3JFYWNoIiwiX3JlbW92ZVN0YXRlIiwiaXNTcGVjaWZpY2F0aW9uc0V4cGVjdGVkIiwiaXNQb3NpdGlvbnNFeHBlY3RlZCIsImlzT3JkZXJzRXhwZWN0ZWQiLCJwb3NpdGlvbnNJbml0aWFsaXplZCIsInNwZWNpZmljYXRpb25zQnlTeW1ib2wiLCJfbG9nZ2VyIiwidHJhY2UiLCJrZXlzIiwibGVuZ3RoIiwib25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkIiwiX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUiLCJhc3NpZ24iLCJvblBvc2l0aW9uc1JlcGxhY2VkIiwib25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQiLCJvblBvc2l0aW9uc1VwZGF0ZWQiLCJyZW1vdmVkUG9zaXRpb25JZHMiLCJpbnN0YW5jZVN0YXRlIiwiZGF0ZSIsInJlbW92ZWRQb3NpdGlvbnMiLCJfZmlsdGVyUmVtb3ZlZFBvc2l0aW9ucyIsInVwZGF0ZVBvc2l0aW9ucyIsImluc3RhbmNlIiwidHlwZSIsIl9jb21iaW5lZEluc3RhbmNlSW5kZXgiLCJwb3NpdGlvbiIsImluY2x1ZGVzIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJwIiwib25QZW5kaW5nT3JkZXJzUmVwbGFjZWQiLCJvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQiLCJyZWNvcmRQb3NpdGlvbnMiLCJtYXAiLCJyZW1vdmVQb3NpdGlvblJlZmVyZW5jZSIsImFkZFBvc2l0aW9uUmVmZXJlbmNlIiwiX2ZpbHRlclJlbW92ZWRPcmRlcnMiLCJyZWNvcmRPcmRlcnMiLCJvIiwicmVtb3ZlT3JkZXJSZWZlcmVuY2UiLCJhZGRPcmRlclJlZmVyZW5jZSIsInJlY29yZFNwZWNpZmljYXRpb25zIiwidXBkYXRlU3BlY2lmaWNhdGlvbnMiLCJyZW1vdmVTcGVjaWZpY2F0aW9uUmVmZXJlbmNlIiwiYWRkU3BlY2lmaWNhdGlvblJlZmVyZW5jZSIsIm9uUGVuZGluZ09yZGVyc1VwZGF0ZWQiLCJjb21wbGV0ZWRPcmRlcklkcyIsImNvbXBsZXRlZE9yZGVycyIsInVwZGF0ZVBlbmRpbmdPcmRlcnMiLCJ1cGRhdGVPcmRlcnMiLCJvcmRlciIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkIiwicmVtb3ZlZFN5bWJvbHMiLCJjb21iaW5lZEhhc2giLCJvblN5bWJvbFByaWNlc1VwZGF0ZWQiLCJwcmljZXMiLCJlcXVpdHkiLCJtYXJnaW4iLCJmcmVlTWFyZ2luIiwibWFyZ2luTGV2ZWwiLCJ1cGRhdGVTeW1ib2xQcmljZXMiLCJwcmljZXNJbml0aWFsaXplZCIsInByaWNlVXBkYXRlZCIsImN1cnJlbnRQcmljZSIsImdldFRpbWUiLCJhbGxQb3NpdGlvbnMiLCJhbGxPcmRlcnMiLCJvdGhlclBvc2l0aW9ucyIsInVucmVhbGl6ZWRQcm9maXQiLCJfdXBkYXRlUG9zaXRpb25Qcm9maXRzIiwiYXNrIiwiYmlkIiwicHJpY2VSZXNvbHZlcyIsInJlc29sdmUiLCJwbGF0Zm9ybSIsImJhbGFuY2UiLCJNYXRoIiwicm91bmQiLCJzd2FwIiwiY29tbWlzc2lvbiIsImFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSIsImNhbGwiLCJfcHJvY2Vzc1Rocm90dGxlZFF1b3Rlc0NhbGxzIiwiZXhwZWN0ZWRTeW1ib2xzIiwiZGVsZXRlIiwicmVjZWl2ZWRTeW1ib2xzIiwiYWRkIiwicHJvbWlzZSIsImNoZWNrIiwib25TdHJlYW1DbG9zZWQiLCJyZWZyZXNoVGVybWluYWxTdGF0ZSIsIm9wdGlvbnMiLCJjYWxsRGF0YSIsIlNldCIsImNhbGxJZCIsImdlbmVyYXRlIiwic2l6ZSIsInRpbWVvdXQiLCJzeW1ib2xzIiwiX3dlYnNvY2tldENsaWVudCIsImRlYnVnIiwiaGFzIiwiY2xvc2UiLCJjbGVhckludGVydmFsIiwiX2NoZWNrQ29tYmluZWRTdGF0ZUFjdGl2aXR5Sm9iSW50ZXJ2YWwiLCJfcmVtb3ZlRnJvbUhhc2hNYW5hZ2VyIiwiX2NoZWNrQ29tYmluZWRTdGF0ZUFjdGl2aXR5Sm9iIiwicmVtb3ZlQ29ubmVjdGlvblJlZmVyZW5jZXMiLCJyZWdpb24iLCJzcGxpdCIsImluc3RhbmNlTnVtYmVyIiwic3RhdGVJbnN0YW5jZUluZGV4Iiwic3RhcnRzV2l0aCIsIm11bHRpcGxpZXIiLCJwb3ciLCJkaWdpdHMiLCJwcm9maXQiLCJyZWFsaXplZFByb2ZpdCIsIm9wZW5QcmljZSIsImN1cnJlbnRUaWNrVmFsdWUiLCJ2b2x1bWUiLCJ0aWNrU2l6ZSIsIm5ld1Bvc2l0aW9uUHJpY2UiLCJpc1Byb2ZpdGFibGUiLCJwcm9maXRUaWNrVmFsdWUiLCJsb3NzVGlja1ZhbHVlIiwiX2NvbnN0cnVjdFRlcm1pbmFsU3RhdGUiLCJjb25zdHJ1Y3RvciIsImFjY291bnQiLCJ0ZXJtaW5hbEhhc2hN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