import TerminalState from './terminalState';
import ConnectionHealthMonitor from './connectionHealthMonitor';
import MetaApiConnection from './metaApiConnection';
/**
 * Exposes MetaApi MetaTrader streaming API connection to consumers
 */
export default class StreamingMetaApiConnection extends MetaApiConnection {
    private _minSubscriptionRefreshInterval;
    private _maxSubscriptionRefreshInterval;
    private _historyStartTime;
    private _terminalHashManager;
    private _terminalState;
    private _historyStorage;
    private _healthMonitor;
    private _subscriptions;
    private _refreshMarketDataSubscriptionSessions;
    private _refreshMarketDataSubscriptionTimeouts;
    private _openedInstances;
    /**
     * Constructs MetaApi MetaTrader streaming Api connection
     * @param {MetaApiOpts} options metaapi options
     * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
     * @param {TerminalHashManager} terminalHashManager terminal hash manager
     * @param {MetatraderAccount} account MetaTrader account id to connect to
     * @param {HistoryStorage} historyStorage terminal history storage. By default an instance of MemoryHistoryStorage
     * will be used.
     * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
     * @param {Date} [historyStartTime] history start sync time
     * @param {RefreshSubscriptionsOpts} [refreshSubscriptionsOpts] subscriptions refresh options
     */
    constructor(options: any, websocketClient: any, terminalHashManager: any, account: any, historyStorage: any, connectionRegistry: any, historyStartTime: any, refreshSubscriptionsOpts: any);
    /**
     * Opens the connection. Can only be called the first time, next calls will be ignored.
     * @param {string} instanceId connection instance id
     * @return {Promise} promise resolving when the connection is opened
     */
    connect(instanceId: any): Promise<void>;
    /**
     * Clears the order and transaction history of a specified application and removes application
     * @return {Promise} promise resolving when the history is cleared and application is removed
     */
    removeApplication(): Promise<any>;
    /**
     * Requests the terminal to start synchronization process
     * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/)
     * @param {String} instanceIndex instance index
     * @returns {Promise} promise which resolves when synchronization started
     */
    synchronize(instanceIndex: any): Promise<boolean>;
    /**
     * Initializes meta api connection
     * @return {Promise} promise which resolves when meta api connection is initialized
     */
    initialize(): Promise<void>;
    /**
     * Initiates subscription to MetaTrader terminal
     * @returns {Promise} promise which resolves when subscription is initiated
     */
    subscribe(): Promise<void>;
    /**
     * Subscribes on market data of specified symbol (see
     * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
     * @param {String} symbol symbol (e.g. currency pair or an index)
     * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update. Please
     * note that this feature is not fully implemented on server-side yet
     * @param {number} [timeoutInSeconds] timeout to wait for prices in seconds, default is 30
     * @param {boolean} [waitForQuote] if set to false, the method will resolve without waiting for the first quote to
     * arrive. Default is to wait for quote if quotes subscription is requested.
     * @returns {Promise} promise which resolves when subscription request was processed
     */
    subscribeToMarketData(symbol: any, subscriptions: any, timeoutInSeconds?: any, waitForQuote?: boolean): Promise<import("..").MetatraderSymbolPrice>;
    /**
     * Unsubscribes from market data of specified symbol (see
     * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
     * @param {String} symbol symbol (e.g. currency pair or an index)
     * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
     * @returns {Promise} promise which resolves when unsubscription request was processed
     */
    unsubscribeFromMarketData(symbol: any, unsubscriptions: any): Promise<any>;
    /**
     * Invoked when subscription downgrade has occurred
     * @param {String} instanceIndex index of an account instance connected
     * @param {string} symbol symbol to update subscriptions for
     * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
     * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
     * @return {Promise} promise which resolves when the asynchronous event is processed
     */
    onSubscriptionDowngraded(instanceIndex: any, symbol: any, updates: any, unsubscriptions: any): Promise<void>;
    /**
     * Returns list of the symbols connection is subscribed to
     * @returns {Array<String>} list of the symbols connection is subscribed to
     */
    get subscribedSymbols(): string[];
    /**
     * Returns subscriptions for a symbol
     * @param {string} symbol symbol to retrieve subscriptions for
     * @returns {Array<MarketDataSubscription>} list of market data subscriptions for the symbol
     */
    subscriptions(symbol: any): any;
    /**
     * Returns local copy of terminal state
     * @returns {TerminalState} local copy of terminal state
     */
    get terminalState(): TerminalState;
    /**
     * Returns local history storage
     * @returns {HistoryStorage} local history storage
     */
    get historyStorage(): any;
    /**
     * Invoked when connection to MetaTrader terminal established
     * @param {String} instanceIndex index of an account instance connected
     * @param {Number} replicas number of account replicas launched
     * @return {Promise} promise which resolves when the asynchronous event is processed
     */
    onConnected(instanceIndex: any, replicas: any): Promise<void>;
    /**
     * Invoked when connection to MetaTrader terminal terminated
     * @param {String} instanceIndex index of an account instance connected
     */
    onDisconnected(instanceIndex: any): Promise<void>;
    /**
     * Invoked when a symbol specifications were updated
     * @param {String} instanceIndex index of account instance connected
     * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
     * @param {Array<String>} removedSymbols removed symbols
     */
    onSymbolSpecificationsUpdated(instanceIndex: any, specifications: any, removedSymbols: any): Promise<void>;
    /**
     * Invoked when position synchronization finished to indicate progress of an initial terminal state synchronization
     * @param {string} instanceIndex index of an account instance connected
     * @param {String} synchronizationId synchronization request id
     */
    onPositionsSynchronized(instanceIndex: any, synchronizationId: any): Promise<void>;
    /**
     * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
     * synchronization
     * @param {string} instanceIndex index of an account instance connected
     * @param {String} synchronizationId synchronization request id
     */
    onPendingOrdersSynchronized(instanceIndex: any, synchronizationId: any): Promise<void>;
    /**
     * Invoked when a synchronization of history deals on a MetaTrader account have finished to indicate progress of an
     * initial terminal state synchronization
     * @param {String} instanceIndex index of an account instance connected
     * @param {String} synchronizationId synchronization request id
     * @return {Promise} promise which resolves when the asynchronous event is processed
     */
    onDealsSynchronized(instanceIndex: any, synchronizationId: any): Promise<void>;
    /**
     * Invoked when a synchronization of history orders on a MetaTrader account have finished to indicate progress of an
     * initial terminal state synchronization
     * @param {String} instanceIndex index of an account instance connected
     * @param {String} synchronizationId synchronization request id
     * @return {Promise} promise which resolves when the asynchronous event is processed
     */
    onHistoryOrdersSynchronized(instanceIndex: any, synchronizationId: any): Promise<void>;
    /**
     * Invoked when connection to MetaApi websocket API restored after a disconnect
     * @param {String} region reconnected region
     * @param {Number} instanceNumber reconnected instance number
     * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
     */
    onReconnected(region: any, instanceNumber: any): Promise<void>;
    /**
     * Invoked when a stream for an instance index is closed
     * @param {String} instanceIndex index of an account instance connected
     * @return {Promise} promise which resolves when the asynchronous event is processed
     */
    onStreamClosed(instanceIndex: any): Promise<void>;
    /**
     * Invoked when MetaTrader terminal state synchronization is started
     * @param {string} instanceIndex index of an account instance connected
     * @param {string} specificationsHash specifications hash
     * @param {string} positionsHash positions hash
     * @param {string} ordersHash orders hash
     * @param {string} synchronizationId synchronization id
     * @return {Promise} promise which resolves when the asynchronous event is processed
     */
    onSynchronizationStarted(instanceIndex: any, specificationsHash: any, positionsHash: any, ordersHash: any, synchronizationId: any): Promise<void>;
    /**
     * Invoked when account region has been unsubscribed
     * @param {String} region account region unsubscribed
     * @return {Promise} promise which resolves when the asynchronous event is processed
     */
    onUnsubscribeRegion(region: any): Promise<void>;
    /**
     * Returns flag indicating status of state synchronization with MetaTrader terminal
     * @param {String} instanceIndex index of an account instance connected
     * @param {String} synchronizationId optional synchronization request id, last synchronization request id will be used
     * by default
     * @return {Promise<Boolean>} promise resolving with a flag indicating status of state synchronization with MetaTrader
     * terminal
     */
    isSynchronized(instanceIndex: any, synchronizationId: any): Promise<any>;
    /**
     * @typedef {Object} SynchronizationOptions
     * @property {String} [applicationPattern] application regular expression pattern, default is .*
     * @property {String} [synchronizationId] synchronization id, last synchronization request id will be used by
     * default
     * @property {Number} [instanceIndex] index of an account instance to ensure synchronization on, default is to wait
     * for the first instance to synchronize
     * @property {Number} [timeoutInSeconds] wait timeout in seconds, default is 5m
     * @property {Number} [intervalInMilliseconds] interval between account reloads while waiting for a change, default is 1s
     */
    /**
     * Waits until synchronization to MetaTrader terminal is completed
     * @param {SynchronizationOptions} opts synchronization options
     * @return {Promise} promise which resolves when synchronization to MetaTrader terminal is completed
     * @throws {TimeoutError} if application failed to synchronize with the teminal within timeout allowed
     */
    waitSynchronized(opts: any): Promise<void>;
    /**
     * Closes the connection. The instance of the class should no longer be used after this method is invoked.
     * @param {string} instanceId connection instance id
     */
    close(instanceId?: any): Promise<void>;
    /**
     * Returns synchronization status
     * @return {boolean} synchronization status
     */
    get synchronized(): any;
    /**
     * Returns MetaApi account
     * @return {MetatraderAccount} MetaApi account
     */
    get account(): import("./metatraderAccount").default;
    /**
     * Returns connection health monitor instance
     * @return {ConnectionHealthMonitor} connection health monitor instance
     */
    get healthMonitor(): ConnectionHealthMonitor;
    _refreshMarketDataSubscriptions(accountId: any, instanceNumber: any, session: any): Promise<void>;
    _generateStopOptions(stopLoss: any, takeProfit: any): any;
    _ensureSynchronized(instanceIndex: any, key: any): Promise<void>;
    _getState(instanceIndex: any): any;
    _scheduleSynchronizationTimeout(instanceIndex: any): void;
    _checkSynchronizationTimedOut(instanceIndex: any): void;
}
